make[1]: Entering directory `/home/bill/dev/later'
<!DOCTYPE html><html><head><title>Coverage</title><script>

headings = [];

onload = function(){
  headings = document.querySelectorAll('h2');
};

onscroll = function(e){
  var heading = find(window.scrollY);
  if (!heading) return;
  var links = document.querySelectorAll('#menu a')
    , link;

  for (var i = 0, len = links.length; i < len; ++i) {
    link = links[i];
    link.className = link.getAttribute('href') == '#' + heading.id
      ? 'active'
      : '';
  }
};

function find(y) {
  var i = headings.length
    , heading;

  while (i--) {
    heading = headings[i];
    if (y >= heading.offsetTop) {
      return heading;
    }
  }
}
</script>
<style>

body {
  font: 14px/1.6 "Helvetica Neue", Helvetica, Arial, sans-serif;
  margin: 0;
  color: #2C2C2C;
  border-top: 2px solid #ddd;
}

#coverage {
  padding: 60px;
}

h1 a {
  color: inherit;
  font-weight: inherit;
}

h1 a:hover {
  text-decoration: none;
}

.onload h1 {
  opacity: 1;
}

h2 {
  width: 80%;
  margin-top: 80px;
  margin-bottom: 0;
  font-weight: 100;
  letter-spacing: 1px;
  border-bottom: 1px solid #eee;
}

a {
  color: #8A6343;
  font-weight: bold;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

ul {
  margin-top: 20px;
  padding: 0 15px;
  width: 100%;
}

ul li {
  float: left;
  width: 40%;
  margin-top: 5px;
  margin-right: 60px;
  list-style: none;
  border-bottom: 1px solid #eee;
  padding: 5px 0;
  font-size: 12px;
}

ul::after {
  content: '.';
  height: 0;
  display: block;
  visibility: hidden;
  clear: both;
}

code {
  font: 12px monaco, monospace;
}

pre {
  margin: 30px;
  padding: 30px;
  border: 1px solid #eee;
  border-bottom-color: #ddd;
  -webkit-border-radius: 2px;
  -moz-border-radius: 2px;
  -webkit-box-shadow: inset 0 0 10px #eee;
  -moz-box-shadow: inset 0 0 10px #eee;
  overflow-x: auto;
}

img {
  margin: 30px;
  padding: 1px;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  -webkit-box-shadow: 0 3px 10px #dedede, 0 1px 5px #888;
  -moz-box-shadow: 0 3px 10px #dedede, 0 1px 5px #888;
  max-width: 100%;
}

footer {
  background: #eee;
  width: 100%;
  padding: 50px 0;
  text-align: right;
  border-top: 1px solid #ddd;
}

footer span {
  display: block;
  margin-right: 30px;
  color: #888;
  font-size: 12px;
}

#menu {
  position: fixed;
  font-size: 12px;
  overflow-y: auto;
  top: 0;
  right: 0;
  margin: 0;
  height: 100%;
  padding: 15px 0;
  text-align: right;
  border-left: 1px solid #eee;
  -moz-box-shadow: 0 0 2px #888
     , inset 5px 0 20px rgba(0,0,0,.5)
     , inset 5px 0 3px rgba(0,0,0,.3);
  -webkit-box-shadow: 0 0 2px #888
     , inset 5px 0 20px rgba(0,0,0,.5)
     , inset 5px 0 3px rgba(0,0,0,.3);
  -webkit-font-smoothing: antialiased;
  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGYAAABmCAMAAAAOARRQAAABelBMVEUjJSU6OzshIyM5OjoqKy02NjgsLS01NTYjJCUzNTUgISMlJSc0NTUvMDA6PDwlJyg1NjYoKis2NjYrLS02ODkpKyw0NDYrLC04ODovLzA4Ojo0NDUtLy86OjwjIyU4OTosLS82ODgtLS8hIyQvMTEnKCooKSsrKy0qLCwkJSUnKCkrLCwpKiwwMjIxMzMqLC0tLS0pKissLC00NTYwMDIwMTQpKysoKSovMDEtLzA2OTkxMzUrKywvLy8qKyszNTY5OzsqKiw6OjswMDExNDUoKiozNDUvMDIyNDY1Njg2Njk5OTozMzU0NjY4ODkiIyUiIyQ4OTkuMDEmKCowMjQwMTErLS4qKywwMTMhIiMpKiopKy0tLjAkJScxNDQvLzExNDYyNDQmKCk5OTslJig5OjskJSYxMzQrLS8gISIwMTIoKCk1NTUlJSUnJygwMDA4ODgiIiMhISI8PDw6Ojo5OTkpKSojIyQ7OzsyMjIpKSssLCw6Ozw1NjlrfLakAAAg2UlEQVR42jR6i3ea6rYvPgANIAhVXh8WvkQlioUiFlFcBtAmoiRNdzxqu9p0J7vrdK29zuPeex77nnvO/35n1r1ndHRktI0jTOacv/l7lCBK5UqVpOha/YxmWK7BC4TQFKVXrbYsnimqxuuMVlOQ0XltWjUdCwRJ1M+tC1KudOs9q6+da2adUewG0SC0SwELfHtgDds93VEuydEbl3QMWeNoYkR7b/0x1ZRobGI3mLwzAhePqTAwhg6aogjNsGy7/jwQ4rkdqe7CWLxF8k9LfMVFyRS7VJqtkrW8Vt/bkR8FZJao16ipknbC3Yw2lM7laO6HBEOadEZ2tpf65c4v8e3u7FyU6qbiNNyCuzXZ6pawgnwgmrpTT/Q7w2EZmiIJ0dzWDI7mhQ80IfRnMu2kzA5r5r1pIFoia+/d93HRYp1GV8TbrkWoU/+jdI0Ff6yGwTjT1Hn8J+8m1rKpGiYPuNiHnMtNMIv+zpsk84MYTNW1/+DpwXLvckdOCMYowVNPREe0QlM8xRHXXFhcNDzupwsSmb5pH+0t0RP2Qk+QtI7F1Qm6JRC6ZPBtPq/dq/kH+jxtCljn9TIpW6rQIgmSVyj6lPICIw4N/taka41PFUInth0je9+jO6Kt1G4/a7V2LEgG02B0pHVuCZrgltSKMuIl5SyufUv9mYuQi+mFgzbBEtFo2g+Dh4sSTrLNu8JPh00sQydpb00tqXBvqRN7Q7kqzcnIxCGnvZt/WmJacoOEO6Dcn8Qre03pOCSQxbMOXUuDNx9SxuLz4W1I18gvjViQ67zV0rxdWL8Te/TQkuo8STS41DR48W7L6YP2uWIqiUV8rd6Gbf/rnegKZeG8TpAM6afhGze9JAOxbLjsnUXEbrZ9vLYd7MT32cPF5mKKxmjy7huaoD9n62GOxni3iIJwv0IzZAZjdZkUtolCNLVfYZNaquFjGszVVf+J0vrz4CawoKdHnOzb0NMH7CDBOybfYNJ4rfeMyFNjkFYVTzMFs87rnPGXLUOeNKRVc0LnU7/UIgelzsy3CMuth0YfvnY0wsD3vODUL3eJcKqHQpm8yM3XZQWJxO6Un9iYloyyLpOwN2obHy6W6gbpcb44XmyC+mg+itAcaprGcrwZCqMj/GmtKn0zPvpTz/Cv1dw21XwP3cRupg3H3MF/S71eTKj1YrdwKdc2Mw0fRmb2sFf8lW3aU6JbIZSEPqvXvjM7G/aApyXlXeqKfMq0g/Su3rUGJPSPrtGElgknrZM3xUXqsAP6zMCNVn5u8aJnSNpJv2uru7t2jfRziW2+GuhqfldUNbPk71olwo+46ePUo1U3WKk/e5YK07F/wGRgcpODmQnIlVeHCWBE4puBi2jq28UKpqiN1/4UOrGz59TNYrrQHtd+11sG40BGD+pXdelNqGOg4NXe8W4eacJV/NS9/2Umtym6WQqveqR9xdCMElpxnbkalM4Vf9uaEcWZaKdyibEIjWKxJZPN95niCL3GiaXyssIrHxoLkqkzLCXULN46/f2h3tQJgyip+Tk9EAjJ9aJshq7t8X45aowSKspMSvPf7r9R8yxNptIaHS5ozuEm6luPDApugyNP8OaqiQ4BjaequXA54SLC83eHIY2r+CZp4409Xqw8Aa2oI7XkCrQi+in0w5AqF/kLNrcUz+qkl/lAobY1jSnx5OJNhyXIz3qfNFlXc0TKaglNwdWkWYt9QQ1Kr6W8zue21iNrdJk+N5oCr2O9nEtWKC7IS5J/zdDEYrmnAYfg6agCy+qcgz7ZofeDc4PbUWSvkshWuAc7OjiUyLkj+RAtdlwXJcjxdpkTTHDhK8lBCi8+JtvDVL1W6elmOM++YS0LuSlaP1oUvAeiW3cFnvTr8EbTz1tsSMYdGeZe40sRWu5uAfj7q+ZoKv2FNQ0p5XY1lmlcigHZqTPpabufEVrNuNPi165w3uCVQJHyJqmSJ7ZHnguqwtCmwViIJijj04ba2JNYtB+yORf5gg1/9t9iw4vUpeqiunSAbf+IBdj/b+iG2qrHvuNP0Vd/+ThVZT/lrvHYjjgDbbyxaqgHNM2uhxa1GW3UedZYhMMwM4mQhltouK+IV4NdbIQNM+8Yv311RZk9kT4tiYR4LkyFcuPpdcjuhUuFqBAWRZa11lcZ3gEBlXywsNhrt+plISZP5DlsV9l4EgY6J3yZPTUcMrgaWAT3oI79eSbGEbcJpr6BD8kyDiVt+G0/hXosQN4NFXKlfWIfsIs0BHODVok1/IGnKFHJYIquh8Xo+2+bkQNTGgWmN/fZ0Y33LSj6lr1GyV7mWIKg7ZTRZPGuhF/zjRNcQ1UPtSYgnWQxSs0yrVhwNDcdGMNSNe2JT3WuzbAM3HykyAajS3Uphf6STKEqxLas9EnmnhA/lyj9Uj+JoY7SVgVmGLl46Rm2u98sbkap2lzAdKBG4r6LgulQOSSjQv1GWdQ0jtDUK/mAaqM1Uqjpu4k3Rvfvxv7YTxLSK+wN3E5jVIzmF23uZ7hiH/sVP49D7tvoKp4S8b1LuvRlivVB/algbhcFITYVXvDpLzpDfplR2uD5V4XJFxpjmIpLc9Y5sB2TpBRix7Bme6GZIq+06v3XzNeTcA4obQIKxrnT4C2JpOqD92dbmSX8MGazly5EsZVMvSU1f4RZwyu8iQXbVdeLlZrjuTT1jrY1uk5c7iZ7RsvhhluqAkq4JpVQAg7RJFtSu+xgJ8Pv6O1j5DkLxT8mkbfyRW5DrQmG7hiDIjCgBsADbjuof6YHLGeV6a5Q1Smx9joUXPpdaaDx97A/Wq00oJkdR7ZYuQRfS533JtxO1erduqWOYIt3wh0wpbLuCNIYkwxbswbikCUu2CDCS+Q+7rgVtfRcm+SOcdKPRlZ/rE7wNVUEE39KTS5uvUKN1PUnkloPkyzhyGQ8qkouEjJ3H/VXdqG6asSRiw3ecMlBvDDt8dDhBHXMwZ2Cajzjr7/76T+IavqPYvz6r7//E/3X3+N//h/0QozbjPgPiir69P/8X3/9F/yv8b/827/++98WItPu5/Hvwd8YPf5bp/2/lX/T/+Of/0MJ/lYTa+L/Ef+d9vN/3/2T6P/+jyTzu/evf6U7vxN7B6pJkRtAF6jUr8I+P8RsP/ptGhfqFk+pQ/DgAy6NJtRYJdXmp4gK7WLqLKJ+MaKhGjOojvL+SnIWrkpy0SLHDe4QuyNzaEA15mLMCcmE8Em+4HdOihW4/ZWuppJEmzeAwcDtv7MuLc9y2V5atvxXNe3S4DUMt5/Qy2LM9kSYKiVWBuKlfp4nxTntpuW03JbIlkiRvBXmT23g1I2OYe6IizUHPIq6zm6mbfsbteKmi/sg9J+ocQBMctGFO7iljo8TPN+z3jxw4do+ZwfqoR9dkNTKHyM305GpTkfhcHexVkPVGEbUOjuo9f0UMPHBFlGEx0SLvJvVRKTwW7PSew5oPme+E42+frJa9cGt2njS3dK5kIif2eYbhuSEQXEqMVfUjhGIuin0G0/W5ezJyJQy3SpMLai4M0JUWb5u1k9tny5bd1pPwYBpQuDCXZl62xg4CdVEAtflXHs6JKmP/pH6mOl796Lgopj0o8d5kKh00hxG3OSdEE/QBo9Hgr8JJqAeLDwJohG5j/DGh61Rc/+tf22/8kEnxHNCEjo0ElvvGfESZkqmz2BDcKV1H1buSkhkdg7p1IMGs2s17nYjpblrWuE2K9WEO/hcRp5e9oOF/QBmOaDtgil+oaU6szPrdwW65fOB0KUTsVUn7LFU7J8e6cxJIl9+FHw5MQMzuQJ+4oxMH3iW/5GK+hWuG0T+gTLs+fAjdtUd58TmIUq04EeyRCYCjkldow234aIgR5bqwrtZosZ+6YEqAmDqatJ9lWasz4IquKALPtd92hGI3Z2BdzzZue+REl1Om4DIWD+RrtUTOJLI+S0jHowXXdAxsGLSd40zYNuEUlOGhrwL6c7tcOtUOvpJCP7QBQS19H+GvZn05ewjlVLz+IGKoC9TyfQjLMBNmXCuqqtTdOSukZW48B0HqgSTCBrBnlFvF4CG2Su7yFzqmJFURK3UmTT3ru050r0ptUpMilYnBJWfl2Bv6kPlUuE1kxxpdzui9AubsR2N2boVSu81OulAwBqoSr1LZ0LLYOomyZHmjqnXlP72s8LnDouEJjtodBvdHaG1jMySYO7crWd90MpCRyCG14vb5IE7Arupw/y/RcCm/Tm3zK6zYj8PYNaGldiUfkB/LHWcmf2lVM+mwyU27a0qq2tscrQ/vzBjN26DnntIrOyGizzXK35yKQdYnUABkyN4saz3WD/viF+eCcsXnIajdWYJWaYHRstIis9CS+tqnFGmz2j5uzfr3Z4prqgK4XOT/PyftvjZqIm8lhkfxJ7Ol3CJF1piYBGAG8wtAk56Drw1YwmOpcz+NdfkSpSLplRXLXHL0Rquj6YW/gabqgK7Dgr6NwtH0B/AN7XrN+MVJ6AmXmUuqmQulrNNYPmH0RoDogydOKLo/QbfYNARSQQKISRCzRXU+q9WWJFL3LZW6u34CkeG97xC0NNGaJ0bvK6SnZS3zPskr5EtuCgjMWR5o2x5BqhKmDWJPRe7JMEOyRb5uUKlHaGVtq5ivSOaSliSXp9SQm2qk8MRJh10MAp9QQ2H5t59J8rjiwSZtoIfMGjlLPVNdYl/LBR0AO6WLGDmkLkIPRE45Y9MftdAK/yNu1Hn6tzOQTesgQ+8fSzB19wO91vCnO23vOWQdwJ63SJrYjdfKFW6W281PKs2k8iT9ai1cgJ4sa3xqdvmtxR8/+D1B8AKc2u+6JftryRhMWSQtoSBgIyyQGyxcnELuAasXN12oSriU4RMz1DD6RL0TSV+om7i1Yt+jEE/jnawM8cX/UhN4nkiv/w9eALrzNhXuQfOzFL0Fi6SjF7/4Qn8rLYBoa85cvgAnkCEBP+HPbEnquVXCZsMS/yzYw2Vru60P/+nJPYKkzZFjmbykzUoEqV836T5q3fP/L383dF82tx18/AZgZczMAgyeWYKmSZIqtHL+e+O4ZRcq9VI3g/qPeCoiK4pcgEqdbS0S/Be54sbVQOuJVPNBblIghzeasNu7h/g+Sz1IdhI5lCwq1nUb3Ji4OCIcqQZqtqJ5w7rXrg/DA9IgVmEGhDgGecEwnCTHffXcXs0V3OCEVzYDKS1vp/oX+ng+6XVU86UjA6FMO2RXOOOrqY1GgPvrAk9HV/BXtCu5RuwF8qgdGDLsBcui4E33ymdBip1X8uKyhIWT8qNRDsXz+gvO9UiEC0d8RG4Tf2x8H4slljgHtCBcxHLTWOYJm5H/fCPCzOgf9qgOUxTRZ0Pc6ha5yLuLVT9ntvIa6gacE99mCovdUumTQdRP4RPsS9129eEe2uSvvGh0bV4Y3QPPhPZMqhZWSMa5R0Hc1SGO4IVOQc0FrirlibTVfKRrYkD8kz3b+X65/QkUNaZdrdl3mCap0Hf3YcCw/LiouJYNbqz88UqeDYv93yO7vvXtgl4XCyAO4ODkY6W+83+LZU//p3/zXNGGrUKClCiOnL27iJZbNWDF02XXAOeFlB7IaADoMH1Yqr+UP9biyZDEa/iJt4MDeIz6GKTdLVBfWGVtRN4fdT2rgReX8UXwF2zOrradm4J0nyTgdPnai3RvzpZvCKDUqjOwD/QA6EDaMCLewX6QWYVnHY1sx1bd8ovYnPm1ZvPH+rE20lWjOCnZ66/xDt0QAl15FjfBcZp+i9OU0RNPQ0t3x2pSNWo8eiYudwsnuP1Hq6iH1LJCJynkYsfgJ0p3pF6SoQk2l+jqE8CPk+ziGJRSKjs+W5AO185umPdkYzlK4wl7TC9NxyyDP7ZoyYVoXiuS6SjnInlLWrwz1i8bGTKXX0AVQWkSfIlglW3zRJRJ8bg5VgE6ZEnqNu9B++0GNQvDQJvFize4ESNKBJP+8vA3LM4AX5SIBq08Mob+7QMTCZx4nwP/64+4BnlZC+8WtlP/CXw6t1PwMwkJ3jhP1FiXLhDF/3I6FGUzO2DSi9ABxKyyL9paZxSEz40ZCPQToDAJu1959k7QdbVxgB4icsu2s4zsTPJhcEDo+N1GX4zSk/wriRh8AqwL62972i9HJHd1ydaLXVzvKvOfGGw5RVcUVMiKXFH4APdkQU/dc5BX0YfKTNZYXCW9mb8bc8mufoQP6BbdQmT99ZjoYfr/go4TgQX9IDgztim7wyFeGMfbNaeqj8Dzs38pgcqwSv2hbqB3oSGKWKy+sesY7p57wAHldqE6NDudk/W7s/zjrK4rZFlFvaGxnSZdHbc1y47qDN6xkoK8O3bfr2j41dlJZ71rB4dlDqapPFa8N6xBrprUdtenUCHwxKNhw1uuTBh+9uU45k4REpQABN2bAO9DSLqoIL26gNroWgup5pUMxHUNSq4Gyz47vBPvilpo5f9OYI2ddAqTqmnxXERxQJ3UK8fHbVE9HagHi3+tqNRoNsArdmAxHA5LwtQo9ZAaNKUTljnokljo2x8scqVpEEIPc01fPCdHOCg0DeWBz8D5TVAAfx8aRH5X2ZYNI3ebKDZdeJ+oBDAxmRqJ30Eh2/DaeAy5diVNMpEDmXiPDsGTzBLXy8eVDdJoIafgx/gxMyQi454QrW56nCyeELgSuNNEmYkflF+t3CZQOVRWjKhIuCclmQSlAXT3+4JGG75B4t/5hQ+ldMP4LsAW6z3XmU6IJJwpnGVnsgUZhoY1fZlwTR8wSU7xRejf2uCx9Z5trVTRRJP9KnEb134dEieil6eCOGWgboI7xsqsqM99jfJLTePjygKlH2CVxxsse9QRzTBFjD/Kjqitr/CCTBt/SJ6nLxz7cKP9pFqBpp0lN5y+adKNsZjrPuroemZauH9aTTFD3EKHW8S55XBLFQAt1jgxTQCTwxmx/JyfsZDN1RroN3VaxpSenpIX7K+ZbL8VdlQDcI4Cbzg3QJLa9yVqNxUelu+EtxLVqeekaAvSJkO6sSVqbUajxqhKshNpvZqoeApF0k/0P0ikkwUcbdwc4A1ejN7Oo0O15kG7hTMoK3hZRBCX7YYeLW0wvcXx/18n/u37yLgzBYVBUvORGli+sfRcX/74uD6P4hq+7xu54TlWJLFzT63uwUDwuEDdOjJQqx7JV+ZjaEAPi7t0MMrR4Q8Rkf18uxD6RK0RKh0hL8YU+DeL97i4pa5ZSyAfXKwZRS/8gXcxdZXm62RBDj8U3sN8x95b5PpPs/mCBKYvpaA50pN5Ct/499AFTtwQ5vgeSh+NHrKIi4NVpwM/XzRaNfJD856lPE6M21zWPguFsH7jbLVyEDfRmt4VwrhCJ5VTYmcSPfGgO5clfN+vbaDZ7sakU5+2vZ2WCDY031NxJarVytfDDVtiafcTGO2rJ/taoL3zChN2qmjxofczTOYQPPVQPh0JVtYgdUQINcSiNEEy58UdYXX1MpWUCEBx7LbcGtAm8XWRQTVOaoV3ySri4RShhs/B/0m4jX6OAwXOvcA09bNSG4czEGv/Wey6V/jbTCNTW6awXdNTcA1GsPe1E9fZdGl7R0vyoVpIdJtfC6d32NNErrvq/R+d65VG+YOwRXppXxOCYyGNSf1K3x6VxAW/vtz4EC1SgCOSPdN62sLsoIzuDfg8GwZAbquVO8HIuFP/ToVoeUB7nnwMF35a1wK1tI6fkrqFKhQdeJpwyls0pIy8AZde3/6LUUbFaYJthyUJSU/kqDXTLQElnn0Jr4B2RVghNrmNmoEn7pXIeshPguXVsvwoTdmClq49JJU3LWhHyWTrJL9bRP6VKv3tZoA/th77p5Jw++OEENvyvWy/pNeExiDUVQaXIRGh8xySZTI36yueFaSXo1uJY0RnXYgEOoWWOJHeaVuX/bGNhHsh2yinznl/++NJcE9j6fBPRcBdq9hb8awNw8U7Bl6GM7x69EDOIIbX/npZ++amlHR9L/35mE/2Ss4gb0xCcY4VyTFLRE796vHysLAamqcyO+aFQyJIDBNslbH2/MrAvZiSEIedc/cqjmv4fbda2pXbv+F5a2szSsdkm9noiNURXt8edUhGUF6fSZWd1IJaXKFwD+49R6eCXD4Bkef7j9tRtNMVgW8BhRz/Qpy1TmeYk0doyjZoJSbePOReVHgkFsCFuQJ+Lgc4BxeAsK/cOiNDRmdNw0ctYhn/nQ498dYI5znzGLoJi1rav7Cn88rL3wLePVtDK5gl77Tki3gHEsIAQ2+IKgarj7Y8W1IQzV5V9N+0TjLqbg68WfKcOmBCOj3JkwJhVIkwDhc+JorXuZEPMEh0vvH3x7iqf+VAwXgd4diZiaJD1zHL9Snx6Wfg4IugreyhabQkcir+y5XgDtdx3Avs7lkeeCBwDvZoTUCXx5QrZkcEqWfYEiEYRs/EphmRALSNGR1Iclgdr5VFoELpzF4++f35w3/j0t5ucW3n2ch4PQCLuUXupsPRR7UA5FjSKrMtPcKAZJfagO4lGE7FH3YKMjorpK0ZxAv+i2JkJhtAMWWWFej4RhPR/cJ3DxwocCvXDi4SGZU4cu+K32XndiFWgopAl+0GApcwf1XvymJcFs39jExIBO4yUjU9MExBLQYc9H+W7+IgdESPRpciT+rKZPebVtaVq+1GYO/5xTAL3HASjNTGIgMvdjWbgc7JvdE1zIFpuC0U9ESiZyzBixzxWxj4Kwh8My34q+FK3KNLtmsA1qyrmKSNQOXCPUZd+ONelBTvFoUI/CYsqa/RhtKiyMf2CgSFqEPk59Y3uqnlZ8gFpswfSYyko23yVZYxzKGxGm49Zqxg1l8oz5Ra9XaRwHkuxepmgyhm0SoNy2KlbcEqK+9QqS9PNx9Ihm9U7gsR55SSJ1FBDNnkuWKxIZ0SDpXuOGwZdoUbOMDPHP4vBAgz2VlSEJAHZGJVbYIg7l/FO5KfIVvxC8pPPxMGcNMoevFDeStt2iqztE10n2TA4dgJH76YS9HDhKHD3iCx6ieFX84BAI3QQnngh76f5ruPQVbr5qZmck/5UjDc26lfrOvUBWy0Ogl8bCoOkMOns81TnC3cuUS9KW8+9A+fe3XYZOFUPG1u5epSSmDLw0s5s2F0W30ANeo+zJkJQz9SPZgzwYpEoktofhGVfmLOAB20boCbW1QWq/NpET/hnMecw/uSyAH4NJc3ECOU4nnkK1fj3S/i5dwb3R7k00AqQQUwt7Ie1qV0aY/VQX0J8hLPy7eBNXMHYZYDNxHZ2Qh6AuXJxq+AeRec/Q+JLhZV6hpXwQEzw7bf5v9uUf2vpq3qlhmy0IIGTkwYdCfSAFmqbdo+3XvDTDjFJde0mbeQLcn2n31xaAqJ0ixO/CLsT4I4G4DoncVTgRGNBtsCcjISWT+oeXZ4Iedw/8OsJI1aPnNKLX/60VvcZb94uasRxCkqlPQ11u1Sa2hHvB80WQENxVyzjns0/PiEByyil21Te6oisk3mNCEMrhouCFO3yEZTHHOCMy9eb/4Tmi8cVf3Lf7P53SY2hX3PSN033As3ETIMLHWumWEO9JXHA2y2SIBlIPpLGG2qvNsCIlIr+B1SWAqRKm2w6Blf7U+zCSBwJrfHG5i8J5Gax/cVonMlon7aHJX/gSvucIncRP93XCqkv7D8IFKFsLiBgHqUpXhE3pYjEcV1dk/JD9zFVCfEaQIVX8Jmfz7IIofcBKQ4OaG+C3xC2veX9CD+iAFXDNaGg9eTVxvkbJRJlW4Nk9Wk13kn696jWppRDe/8pDrYMO9ZyxZ98ReKSz9kWKLLyk2zCZgAniCkLJVX3n1M9DYbomyahWiv/KixRIV9hj/oFz87I+HLznbPTjpa+D+bZQnMuRsljTpv90vQUt/pK7jCFnA30B/jtroSF2/m/gpWn1aQs5WeA6ghzF8SdqWI20fghdSeDOCSCmLgTkfaGgGDmw7nHFkRzGtag57IHS2na06I+gzEphXo1w/Zx2BM/jKL2nZoFjHggtFQjYi8nSVRSXIE58RPbBObXk7uuIL9+rs/5Zo7suJInEUxgsiZZAWS25iBtpEiZeBgDtghEoAE0sjcayNq85M4tbu/LF5h51335PsGzQ09O875+vUS89lkWMyNOFoip2PuyWyMP/iU2XIZdfCCJNDjebDoBLQdpy7QQZC7s9c0wjHJervQNDu2jWzBW5MSAJMr7bP+Iv92BkS/GGgzjEn7MF1IRKFwwzbjbS4/slGOmhx9cZrFu7HSEefojNv3r0UaKfKOWzXsq1zEugbzlMDFsacRJJI/iJlK3vtkZ+PLZIVMFlKA32wbq2Kd5T0uCLZ1CPkAfCdzkz2EYscjDcZq2AWfziN2covN4kXE1lQXPPLTNM1xx3tbiepcO/t3SWm4w87qfh99SL0ZnY+LKFPLPeXVM2mIIoVWt+9Nk0I7nY4O79iGYqxZ8RVz289an6NVdJWnSKZvJQCAuHNiVaDxPAFoH392t9wot5t0/qmU95eEWNbU2udUW5sN9JVqcYlvAIfLeYC33oUzzxZgSktsv21mA7Uly1FA5VnoJFh6N244Wmv3YJGFv/TCPryaw+ZORlpZjQdq/2DYXr3EZskfed0G61P09ipTKmlTQ1067Rg5+PAk5FlQ9e0SWbGf2B/08kqymOTMVOznsALHHNFH4LFRKl2F/NOiYFl9khNHnSu9Ak5sq26Ynl/i2fdTle29Y1ugqmR5Yj4YT9pvslFyYCbw0mNFr5rVQm1LvkG27QMq9ph3t8fmn6r6SQ4oSbr5tz+J1kIawGzDxb6VYOvvWhobDTXfBeNv3b4aNm5XUinsCGqG2q/45m3+LoCOsddFceYhRx1Tsss9PLdPfJdErFMjYd3gddjiP0+XQjcRadZP6bwNLySvunFf20Czy6JqdEW2a96KxdYdOryBv1BjbuUq2yCHeh+6sk7fGmmPi50pe/1l5TyPe5oHW9oPnhPswLyf2TFDdCyYlhwBCstv5C1HwlW7xWoGT9XZt4qVj5WryLPLLD6h/5cMLEjWzgCeAIKNsLak92aBqBsHl4AJwl2N4jfvbSkBExGimv0nFvv09uDScQbjx+w4kPQjgjlW+g9ws9VEJvI2k8N6XxVu0uIwovgTFdunG24gBtaDi+y1YLQwZ8mwbip5fVlO3k0n0AEr/ETbtu8Vjkm+nNSiEb7X/3fMjBL5A8PdgG+/FnbexbFFExmEfetXAnisEKy5z44WVPpQZjSy/jzeGn4yDRsFGqhh87QPaDBWhlo37IFbe/C0xynS91d2tP/AJoJS0sVF6iwAAAAAElFTkSuQmCC");
}

#menu::after {
  display: block;
  content: '';
  padding-top: 80px;
}

#logo {
  position: fixed;
  bottom: 10px;
  right: 10px;
  background: rgba(255,255,255,.1);
  font-size: 11px;
  display: block;
  width: 20px;
  height: 20px;
  line-height: 20px;
  text-align: center;
  -webkit-border-radius: 20px;
  -moz-border-radius: 20px;
  -webkit-box-shadow: 0 0 3px rgba(0,0,0,.2);
  -moz-box-shadow: 0 0 3px rgba(0,0,0,.2);
  color: inherit;
}

#menu li a {
  display: block;
  color: white;
  padding: 0 35px 0 25px;
  -webkit-transition: background 300ms;
  -moz-transition: background 300ms;
}

#menu li {
  position: relative;
  list-style: none;
}

#menu a:hover,
#menu a.active {
  text-decoration: none;
  background: rgba(255,255,255,.1);
}

#menu li:hover .cov {
  opacity: 1;
}

#menu li .dirname {
  opacity: .60;
  padding-right: 2px;
}

#menu li .basename {
  opacity: 1;
}

#menu .cov {
  background: rgba(0,0,0,.4);
  position: absolute;
  top: 0;
  right: 8px;
  font-size: 9px;
  opacity: .6;
  text-align: left;
  width: 17px;
  -webkit-border-radius: 10px;
  -moz-border-radius: 10px;
  padding: 2px 3px;
  text-align: center;
}

#stats:nth-child(2n) {
  display: inline-block;
  margin-top: 15px;
  border: 1px solid #eee;
  padding: 10px;
  -webkit-box-shadow: inset 0 0 2px #eee;
  -moz-box-shadow: inset 0 0 2px #eee;
  -webkit-border-radius: 5px;
  -moz-border-radius: 5px;
}

#stats div {
  float: left;
  padding: 0 5px;
}

#stats::after {
  display: block;
  content: '';
  clear: both;
}

#stats .sloc::after {
  content: ' SLOC';
  color: #b6b6b6;
}

#stats .percentage::after {
  content: ' coverage';
  color: #b6b6b6;
}

#stats .hits,
#stats .misses {
  display: none;
}

.high {
  color: #00d4b4;
}
.medium {
  color: #e87d0d;
}
.low {
  color: #d4081a;
}
.terrible {
  color: #d4081a;
  font-weight: bold;
}

table {
  width: 80%;
  margin-top: 10px;
  border-collapse: collapse;
  border: 1px solid #cbcbcb;
  color: #363636;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
}

table thead {
  display: none;
}

table td.line,
table td.hits {
  width: 20px;
  background: #eaeaea;
  text-align: center;
  font-size: 11px;
  padding: 0 10px;
  color: #949494;
}

table td.hits {
  width: 10px;
  padding: 2px 5px;
  color: rgba(0,0,0,.2);
  background: #f0f0f0;
}

tr.miss td.line,
tr.miss td.hits {
  background: #e6c3c7;
}

tr.miss td {
  background: #f8d5d8;
}

td.source {
  padding-left: 15px;
  line-height: 15px;
  white-space: pre;
  font: 12px monaco, monospace;
}

code .comment { color: #ddd }
code .init { color: #2F6FAD }
code .string { color: #5890AD }
code .keyword { color: #8A6343 }
code .number { color: #2F6FAD }
</style></head><body><div id="coverage"><h1 id="overview">Coverage</h1><div id="menu"><li><a href="#overview">overview</a></li><li><span class="cov high">100</span><a href="#array/array.js"><span class="dirname">array/</span><span class="basename">array.js</span></a></li><li><span class="cov high">100</span><a href="#array/next.js"><span class="dirname">array/</span><span class="basename">next.js</span></a></li><li><span class="cov high">100</span><a href="#array/nextinvalid.js"><span class="dirname">array/</span><span class="basename">nextinvalid.js</span></a></li><li><span class="cov high">100</span><a href="#array/prev.js"><span class="dirname">array/</span><span class="basename">prev.js</span></a></li><li><span class="cov high">100</span><a href="#array/previnvalid.js"><span class="dirname">array/</span><span class="basename">previnvalid.js</span></a></li><li><span class="cov high">100</span><a href="#array/sort.js"><span class="dirname">array/</span><span class="basename">sort.js</span></a></li><li><span class="cov terrible">4</span><a href="#compat/indexof.js"><span class="dirname">compat/</span><span class="basename">indexof.js</span></a></li><li><span class="cov low">33</span><a href="#compat/trim.js"><span class="dirname">compat/</span><span class="basename">trim.js</span></a></li><li><span class="cov high">100</span><a href="#constraint/day.js"><span class="dirname">constraint/</span><span class="basename">day.js</span></a></li><li><span class="cov high">100</span><a href="#constraint/dayofweek.js"><span class="dirname">constraint/</span><span class="basename">dayofweek.js</span></a></li><li><span class="cov high">100</span><a href="#constraint/dayofweekcount.js"><span class="dirname">constraint/</span><span class="basename">dayofweekcount.js</span></a></li><li><span class="cov high">100</span><a href="#constraint/dayofyear.js"><span class="dirname">constraint/</span><span class="basename">dayofyear.js</span></a></li><li><span class="cov high">100</span><a href="#constraint/fulldate.js"><span class="dirname">constraint/</span><span class="basename">fulldate.js</span></a></li><li><span class="cov high">100</span><a href="#constraint/hour.js"><span class="dirname">constraint/</span><span class="basename">hour.js</span></a></li><li><span class="cov high">91</span><a href="#constraint/minute.js"><span class="dirname">constraint/</span><span class="basename">minute.js</span></a></li><li><span class="cov high">100</span><a href="#constraint/month.js"><span class="dirname">constraint/</span><span class="basename">month.js</span></a></li><li><span class="cov high">91</span><a href="#constraint/second.js"><span class="dirname">constraint/</span><span class="basename">second.js</span></a></li><li><span class="cov high">92</span><a href="#constraint/time.js"><span class="dirname">constraint/</span><span class="basename">time.js</span></a></li><li><span class="cov high">100</span><a href="#constraint/weekofmonth.js"><span class="dirname">constraint/</span><span class="basename">weekofmonth.js</span></a></li><li><span class="cov high">100</span><a href="#constraint/weekofyear.js"><span class="dirname">constraint/</span><span class="basename">weekofyear.js</span></a></li><li><span class="cov high">100</span><a href="#constraint/year.js"><span class="dirname">constraint/</span><span class="basename">year.js</span></a></li><li><span class="cov high">100</span><a href="#core/compile.js"><span class="dirname">core/</span><span class="basename">compile.js</span></a></li><li><span class="cov high">100</span><a href="#core/schedule.js"><span class="dirname">core/</span><span class="basename">schedule.js</span></a></li><li><span class="cov high">100</span><a href="#core/setinterval.js"><span class="dirname">core/</span><span class="basename">setinterval.js</span></a></li><li><span class="cov high">100</span><a href="#core/settimeout.js"><span class="dirname">core/</span><span class="basename">settimeout.js</span></a></li><li><span class="cov high">100</span><a href="#date/constant.js"><span class="dirname">date/</span><span class="basename">constant.js</span></a></li><li><span class="cov high">100</span><a href="#date/date.js"><span class="dirname">date/</span><span class="basename">date.js</span></a></li><li><span class="cov high">100</span><a href="#date/next.js"><span class="dirname">date/</span><span class="basename">next.js</span></a></li><li><span class="cov high">100</span><a href="#date/nextrollover.js"><span class="dirname">date/</span><span class="basename">nextrollover.js</span></a></li><li><span class="cov high">100</span><a href="#date/prev.js"><span class="dirname">date/</span><span class="basename">prev.js</span></a></li><li><span class="cov high">100</span><a href="#date/prevrollover.js"><span class="dirname">date/</span><span class="basename">prevrollover.js</span></a></li><li><span class="cov high">100</span><a href="#date/timezone.js"><span class="dirname">date/</span><span class="basename">timezone.js</span></a></li><li><span class="cov high">100</span><a href="#modifier/after.js"><span class="dirname">modifier/</span><span class="basename">after.js</span></a></li><li><span class="cov high">100</span><a href="#modifier/before.js"><span class="dirname">modifier/</span><span class="basename">before.js</span></a></li><li><span class="cov high">100</span><a href="#modifier/modifier.js"><span class="dirname">modifier/</span><span class="basename">modifier.js</span></a></li><li><span class="cov high">100</span><a href="#parse/cron.js"><span class="dirname">parse/</span><span class="basename">cron.js</span></a></li><li><span class="cov high">100</span><a href="#parse/parse.js"><span class="dirname">parse/</span><span class="basename">parse.js</span></a></li><li><span class="cov high">90</span><a href="#parse/recur.js"><span class="dirname">parse/</span><span class="basename">recur.js</span></a></li><li><span class="cov high">99</span><a href="#parse/text.js"><span class="dirname">parse/</span><span class="basename">text.js</span></a></li><a id="logo" href="http://visionmedia.github.com/mocha/">m</a></div><div id="stats" class="high"><div class="percentage">95%</div><div class="sloc">799</div><div class="hits">762</div><div class="misses">37</div></div><div id="files"><div class="file"><h2 id="array/array.js">array/array.js</h2><div id="stats" class="high"><div class="percentage">100%</div><div class="sloc">1</div><div class="hits">1</div><div class="misses">0</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr class="hit"><td class="line">1</td><td class="hits">1</td><td class="source">later.array = {};</td></tr></tbody></table></div><div class="file"><h2 id="array/next.js">array/next.js</h2><div id="stats" class="high"><div class="percentage">100%</div><div class="sloc">11</div><div class="hits">11</div><div class="misses">0</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source">* Next</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source">* (c) 2013 Bill, BunKat LLC.</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source">* Returns the next valid value in a range of values, wrapping as needed. Assumes</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source">* the array has already been sorted.</td></tr><tr><td class="line">7</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source">* Later is freely distributable under the MIT license.</td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">* For all details and documentation:</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source">*     http://github.com/bunkat/later</td></tr><tr><td class="line">11</td><td class="hits"></td><td class="source">*/</td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">13</td><td class="hits">1</td><td class="source">later.array.next = function (val, values, extent) {</td></tr><tr><td class="line">14</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">15</td><td class="hits">9815</td><td class="source">  var cur,</td></tr><tr><td class="line">16</td><td class="hits"></td><td class="source">      zeroIsLargest = extent[0] !== 0,</td></tr><tr><td class="line">17</td><td class="hits"></td><td class="source">      nextIdx = 0;</td></tr><tr><td class="line">18</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">19</td><td class="hits">9815</td><td class="source">  for(var i = values.length-1; i &gt; -1; --i) {</td></tr><tr class="hit"><td class="line">20</td><td class="hits">29761</td><td class="source">    cur = values[i];</td></tr><tr><td class="line">21</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">22</td><td class="hits">29761</td><td class="source">    if(cur === val) {</td></tr><tr class="hit"><td class="line">23</td><td class="hits">6579</td><td class="source">      return cur;</td></tr><tr><td class="line">24</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">25</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">26</td><td class="hits">23182</td><td class="source">    if(cur &gt; val || (cur === 0 &amp;&amp; zeroIsLargest &amp;&amp; extent[1] &gt; val)) {</td></tr><tr class="hit"><td class="line">27</td><td class="hits">21233</td><td class="source">      nextIdx = i;</td></tr><tr class="hit"><td class="line">28</td><td class="hits">21233</td><td class="source">      continue;</td></tr><tr><td class="line">29</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">30</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">31</td><td class="hits">1949</td><td class="source">    break;</td></tr><tr><td class="line">32</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">33</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">34</td><td class="hits">3236</td><td class="source">  return values[nextIdx];</td></tr><tr><td class="line">35</td><td class="hits"></td><td class="source">};</td></tr></tbody></table></div><div class="file"><h2 id="array/nextinvalid.js">array/nextinvalid.js</h2><div id="stats" class="high"><div class="percentage">100%</div><div class="sloc">12</div><div class="hits">12</div><div class="misses">0</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source">* Next Invalid</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source">* (c) 2013 Bill, BunKat LLC.</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source">* Returns the next invalid value in a range of values, wrapping as needed. Assumes</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source">* the array has already been sorted.</td></tr><tr><td class="line">7</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source">* Later is freely distributable under the MIT license.</td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">* For all details and documentation:</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source">*     http://github.com/bunkat/later</td></tr><tr><td class="line">11</td><td class="hits"></td><td class="source">*/</td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">13</td><td class="hits">1</td><td class="source">later.array.nextInvalid = function (val, values, extent) {</td></tr><tr><td class="line">14</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">15</td><td class="hits">1255</td><td class="source">  var min = extent[0], max = extent[1], len = values.length,</td></tr><tr><td class="line">16</td><td class="hits"></td><td class="source">      zeroVal = values[len-1] === 0 &amp;&amp; min !== 0 ? max : 0,</td></tr><tr><td class="line">17</td><td class="hits"></td><td class="source">      next = val,</td></tr><tr><td class="line">18</td><td class="hits"></td><td class="source">      i = values.indexOf(val),</td></tr><tr><td class="line">19</td><td class="hits"></td><td class="source">      start = next;</td></tr><tr><td class="line">20</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">21</td><td class="hits">1255</td><td class="source">  while(next === (values[i] || zeroVal)) {</td></tr><tr><td class="line">22</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">23</td><td class="hits">1448</td><td class="source">    next++;</td></tr><tr class="hit"><td class="line">24</td><td class="hits">1448</td><td class="source">    if(next &gt; max) {</td></tr><tr class="hit"><td class="line">25</td><td class="hits">17</td><td class="source">      next = min;</td></tr><tr><td class="line">26</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">27</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">28</td><td class="hits">1448</td><td class="source">    i++;</td></tr><tr class="hit"><td class="line">29</td><td class="hits">1448</td><td class="source">    if(i === len) {</td></tr><tr class="hit"><td class="line">30</td><td class="hits">66</td><td class="source">      i = 0;</td></tr><tr><td class="line">31</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">32</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">33</td><td class="hits">1448</td><td class="source">    if(next === start) {</td></tr><tr class="hit"><td class="line">34</td><td class="hits">3</td><td class="source">      return undefined;</td></tr><tr><td class="line">35</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">36</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">37</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">38</td><td class="hits">1252</td><td class="source">  return next;</td></tr><tr><td class="line">39</td><td class="hits"></td><td class="source">};</td></tr></tbody></table></div><div class="file"><h2 id="array/prev.js">array/prev.js</h2><div id="stats" class="high"><div class="percentage">100%</div><div class="sloc">11</div><div class="hits">11</div><div class="misses">0</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source">* Previous</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source">* (c) 2013 Bill, BunKat LLC.</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source">* Returns the previous valid value in a range of values, wrapping as needed. Assumes</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source">* the array has already been sorted.</td></tr><tr><td class="line">7</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source">* Later is freely distributable under the MIT license.</td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">* For all details and documentation:</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source">*     http://github.com/bunkat/later</td></tr><tr><td class="line">11</td><td class="hits"></td><td class="source">*/</td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">13</td><td class="hits">1</td><td class="source">later.array.prev = function (val, values, extent) {</td></tr><tr><td class="line">14</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">15</td><td class="hits">3574</td><td class="source">  var cur, len = values.length,</td></tr><tr><td class="line">16</td><td class="hits"></td><td class="source">      zeroIsLargest = extent[0] !== 0,</td></tr><tr><td class="line">17</td><td class="hits"></td><td class="source">      prevIdx = len-1;</td></tr><tr><td class="line">18</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">19</td><td class="hits">3574</td><td class="source">  for(var i = 0; i &lt; len; i++) {</td></tr><tr class="hit"><td class="line">20</td><td class="hits">5660</td><td class="source">    cur = values[i];</td></tr><tr><td class="line">21</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">22</td><td class="hits">5660</td><td class="source">    if(cur === val) {</td></tr><tr class="hit"><td class="line">23</td><td class="hits">1983</td><td class="source">      return cur;</td></tr><tr><td class="line">24</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">25</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">26</td><td class="hits">3677</td><td class="source">    if(cur &lt; val || (cur === 0 &amp;&amp; zeroIsLargest &amp;&amp; extent[1] &lt; val)) {</td></tr><tr class="hit"><td class="line">27</td><td class="hits">2897</td><td class="source">      prevIdx = i;</td></tr><tr class="hit"><td class="line">28</td><td class="hits">2897</td><td class="source">      continue;</td></tr><tr><td class="line">29</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">30</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">31</td><td class="hits">780</td><td class="source">    break;</td></tr><tr><td class="line">32</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">33</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">34</td><td class="hits">1591</td><td class="source">  return values[prevIdx];</td></tr><tr><td class="line">35</td><td class="hits"></td><td class="source">};</td></tr></tbody></table></div><div class="file"><h2 id="array/previnvalid.js">array/previnvalid.js</h2><div id="stats" class="high"><div class="percentage">100%</div><div class="sloc">12</div><div class="hits">12</div><div class="misses">0</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source">* Previous Invalid</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source">* (c) 2013 Bill, BunKat LLC.</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source">* Returns the previous invalid value in a range of values, wrapping as needed. Assumes</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source">* the array has already been sorted.</td></tr><tr><td class="line">7</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source">* Later is freely distributable under the MIT license.</td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">* For all details and documentation:</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source">*     http://github.com/bunkat/later</td></tr><tr><td class="line">11</td><td class="hits"></td><td class="source">*/</td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">13</td><td class="hits">1</td><td class="source">later.array.prevInvalid = function (val, values, extent) {</td></tr><tr><td class="line">14</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">15</td><td class="hits">187</td><td class="source">  var min = extent[0], max = extent[1], len = values.length,</td></tr><tr><td class="line">16</td><td class="hits"></td><td class="source">      zeroVal = values[len-1] === 0 &amp;&amp; min !== 0 ? max : 0,</td></tr><tr><td class="line">17</td><td class="hits"></td><td class="source">      next = val,</td></tr><tr><td class="line">18</td><td class="hits"></td><td class="source">      i = values.indexOf(val),</td></tr><tr><td class="line">19</td><td class="hits"></td><td class="source">      start = next;</td></tr><tr><td class="line">20</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">21</td><td class="hits">187</td><td class="source">  while(next === (values[i] || zeroVal)) {</td></tr><tr class="hit"><td class="line">22</td><td class="hits">366</td><td class="source">    next--;</td></tr><tr><td class="line">23</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">24</td><td class="hits">366</td><td class="source">    if(next &lt; min) {</td></tr><tr class="hit"><td class="line">25</td><td class="hits">22</td><td class="source">      next = max;</td></tr><tr><td class="line">26</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">27</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">28</td><td class="hits">366</td><td class="source">    i--;</td></tr><tr class="hit"><td class="line">29</td><td class="hits">366</td><td class="source">    if(i === -1) {</td></tr><tr class="hit"><td class="line">30</td><td class="hits">46</td><td class="source">      i = len-1;</td></tr><tr><td class="line">31</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">32</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">33</td><td class="hits">366</td><td class="source">    if(next === start) {</td></tr><tr class="hit"><td class="line">34</td><td class="hits">4</td><td class="source">      return undefined;</td></tr><tr><td class="line">35</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">36</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">37</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">38</td><td class="hits">183</td><td class="source">  return next;</td></tr><tr><td class="line">39</td><td class="hits"></td><td class="source">};</td></tr></tbody></table></div><div class="file"><h2 id="array/sort.js">array/sort.js</h2><div id="stats" class="high"><div class="percentage">100%</div><div class="sloc">5</div><div class="hits">5</div><div class="misses">0</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source">* Sort</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source">* (c) 2013 Bill, BunKat LLC.</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source">* Sorts an array in natural ascending order, placing zero at the end</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source">* if zeroIsLast is true.</td></tr><tr><td class="line">7</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source">* Later is freely distributable under the MIT license.</td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">* For all details and documentation:</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source">*     http://github.com/bunkat/later</td></tr><tr><td class="line">11</td><td class="hits"></td><td class="source">*/</td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">13</td><td class="hits">1</td><td class="source">later.array.sort = function (arr, zeroIsLast) {</td></tr><tr class="hit"><td class="line">14</td><td class="hits">4</td><td class="source">  arr.sort(function(a,b) {</td></tr><tr class="hit"><td class="line">15</td><td class="hits">40</td><td class="source">    return +a - +b;</td></tr><tr><td class="line">16</td><td class="hits"></td><td class="source">  });</td></tr><tr><td class="line">17</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">18</td><td class="hits">4</td><td class="source">  if(zeroIsLast &amp;&amp; arr[0] === 0) {</td></tr><tr class="hit"><td class="line">19</td><td class="hits">1</td><td class="source">    arr.push(arr.shift());</td></tr><tr><td class="line">20</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">21</td><td class="hits"></td><td class="source">};</td></tr></tbody></table></div><div class="file"><h2 id="compat/indexof.js">compat/indexof.js</h2><div id="stats" class="terrible"><div class="percentage">4%</div><div class="sloc">23</div><div class="hits">1</div><div class="misses">22</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">// indexOf compares searchElement to elements of the Array using strict</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source">// equality (the same method used by the ===, or triple-equals, operator).</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source">//</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source">// https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/indexOf</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source">//</td></tr><tr class="hit"><td class="line">6</td><td class="hits">1</td><td class="source">if (!Array.prototype.indexOf) {</td></tr><tr class="miss"><td class="line">7</td><td class="hits">0</td><td class="source">    Array.prototype.indexOf = function (searchElement /*, fromIndex */ ) {</td></tr><tr class="miss"><td class="line">8</td><td class="hits">0</td><td class="source">        &quot;use strict&quot;;</td></tr><tr class="miss"><td class="line">9</td><td class="hits">0</td><td class="source">        if (this == null) {</td></tr><tr class="miss"><td class="line">10</td><td class="hits">0</td><td class="source">            throw new TypeError();</td></tr><tr><td class="line">11</td><td class="hits"></td><td class="source">        }</td></tr><tr class="miss"><td class="line">12</td><td class="hits">0</td><td class="source">        var t = Object(this);</td></tr><tr class="miss"><td class="line">13</td><td class="hits">0</td><td class="source">        var len = t.length &gt;&gt;&gt; 0;</td></tr><tr class="miss"><td class="line">14</td><td class="hits">0</td><td class="source">        if (len === 0) {</td></tr><tr class="miss"><td class="line">15</td><td class="hits">0</td><td class="source">            return -1;</td></tr><tr><td class="line">16</td><td class="hits"></td><td class="source">        }</td></tr><tr class="miss"><td class="line">17</td><td class="hits">0</td><td class="source">        var n = 0;</td></tr><tr class="miss"><td class="line">18</td><td class="hits">0</td><td class="source">        if (arguments.length &gt; 1) {</td></tr><tr class="miss"><td class="line">19</td><td class="hits">0</td><td class="source">            n = Number(arguments[1]);</td></tr><tr class="miss"><td class="line">20</td><td class="hits">0</td><td class="source">            if (n != n) { // shortcut for verifying if it's NaN</td></tr><tr class="miss"><td class="line">21</td><td class="hits">0</td><td class="source">                n = 0;</td></tr><tr class="miss"><td class="line">22</td><td class="hits">0</td><td class="source">            } else if (n != 0 &amp;&amp; n != Infinity &amp;&amp; n != -Infinity) {</td></tr><tr class="miss"><td class="line">23</td><td class="hits">0</td><td class="source">                n = (n &gt; 0 || -1) * Math.floor(Math.abs(n));</td></tr><tr><td class="line">24</td><td class="hits"></td><td class="source">            }</td></tr><tr><td class="line">25</td><td class="hits"></td><td class="source">        }</td></tr><tr class="miss"><td class="line">26</td><td class="hits">0</td><td class="source">        if (n &gt;= len) {</td></tr><tr class="miss"><td class="line">27</td><td class="hits">0</td><td class="source">            return -1;</td></tr><tr><td class="line">28</td><td class="hits"></td><td class="source">        }</td></tr><tr class="miss"><td class="line">29</td><td class="hits">0</td><td class="source">        var k = n &gt;= 0 ? n : Math.max(len - Math.abs(n), 0);</td></tr><tr class="miss"><td class="line">30</td><td class="hits">0</td><td class="source">        for (; k &lt; len; k++) {</td></tr><tr class="miss"><td class="line">31</td><td class="hits">0</td><td class="source">            if (k in t &amp;&amp; t[k] === searchElement) {</td></tr><tr class="miss"><td class="line">32</td><td class="hits">0</td><td class="source">                return k;</td></tr><tr><td class="line">33</td><td class="hits"></td><td class="source">            }</td></tr><tr><td class="line">34</td><td class="hits"></td><td class="source">        }</td></tr><tr class="miss"><td class="line">35</td><td class="hits">0</td><td class="source">        return -1;</td></tr><tr><td class="line">36</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">37</td><td class="hits"></td><td class="source">}</td></tr></tbody></table></div><div class="file"><h2 id="compat/trim.js">compat/trim.js</h2><div id="stats" class="low"><div class="percentage">33%</div><div class="sloc">3</div><div class="hits">1</div><div class="misses">2</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">// The trim method returns the string stripped of whitespace from both ends.</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source">// trim does not affect the value of the string itself.</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source">//</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source">// https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/String/Trim</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source">//</td></tr><tr class="hit"><td class="line">6</td><td class="hits">1</td><td class="source">if(!String.prototype.trim) {</td></tr><tr class="miss"><td class="line">7</td><td class="hits">0</td><td class="source">  String.prototype.trim = function () {</td></tr><tr class="miss"><td class="line">8</td><td class="hits">0</td><td class="source">    return this.replace(/^\s+|\s+$/g,'');</td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">  };</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source">}</td></tr></tbody></table></div><div class="file"><h2 id="constraint/day.js">constraint/day.js</h2><div id="stats" class="high"><div class="percentage">100%</div><div class="sloc">16</div><div class="hits">16</div><div class="misses">0</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source">* Day Constraint (D)</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source">* (c) 2013 Bill, BunKat LLC.</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source">* Definition for a day of month (date) constraint type.</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">7</td><td class="hits"></td><td class="source">* Later is freely distributable under the MIT license.</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source">* For all details and documentation:</td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">*     http://github.com/bunkat/later</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source">*/</td></tr><tr class="hit"><td class="line">11</td><td class="hits">1</td><td class="source">later.day = later.D = {</td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">13</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">14</td><td class="hits"></td><td class="source">  * The name of this constraint.</td></tr><tr><td class="line">15</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">16</td><td class="hits"></td><td class="source">  name: 'day',</td></tr><tr><td class="line">17</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">18</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">19</td><td class="hits"></td><td class="source">  * The rough amount of seconds between start and end for this constraint.</td></tr><tr><td class="line">20</td><td class="hits"></td><td class="source">  * (doesn't need to be exact)</td></tr><tr><td class="line">21</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">22</td><td class="hits"></td><td class="source">  range: 86400,</td></tr><tr><td class="line">23</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">24</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">25</td><td class="hits"></td><td class="source">  * The day value of the specified date.</td></tr><tr><td class="line">26</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">27</td><td class="hits"></td><td class="source">  * @param {Date} d: The date to calculate the value of</td></tr><tr><td class="line">28</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">29</td><td class="hits"></td><td class="source">  val: function(d) {</td></tr><tr class="hit"><td class="line">30</td><td class="hits">104249</td><td class="source">    return d.D || (d.D = later.date.getDate.call(d));</td></tr><tr><td class="line">31</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">32</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">33</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">34</td><td class="hits"></td><td class="source">  * Returns true if the val is valid for the date specified.</td></tr><tr><td class="line">35</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">36</td><td class="hits"></td><td class="source">  * @param {Date} d: The date to check the value on</td></tr><tr><td class="line">37</td><td class="hits"></td><td class="source">  * @param {Integer} val: The value to validate</td></tr><tr><td class="line">38</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">39</td><td class="hits"></td><td class="source">  isValid: function(d, val) {</td></tr><tr class="hit"><td class="line">40</td><td class="hits">3600</td><td class="source">    return later.D.val(d) === (val || later.D.extent(d)[1]);</td></tr><tr><td class="line">41</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">42</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">43</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">44</td><td class="hits"></td><td class="source">  * The minimum and maximum valid day values of the month specified.</td></tr><tr><td class="line">45</td><td class="hits"></td><td class="source">  * Zero to specify the last day of the month.</td></tr><tr><td class="line">46</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">47</td><td class="hits"></td><td class="source">  * @param {Date} d: The date indicating the month to find the extent of</td></tr><tr><td class="line">48</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">49</td><td class="hits"></td><td class="source">  extent: function(d) {</td></tr><tr class="hit"><td class="line">50</td><td class="hits">45462</td><td class="source">    if(d.DExtent) return d.DExtent;</td></tr><tr><td class="line">51</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">52</td><td class="hits">35934</td><td class="source">    var month = later.M.val(d),</td></tr><tr><td class="line">53</td><td class="hits"></td><td class="source">        max = later.DAYS_IN_MONTH[month-1];</td></tr><tr><td class="line">54</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">55</td><td class="hits">35934</td><td class="source">    if(month === 2 &amp;&amp; later.dy.extent(d)[1] === 366) {</td></tr><tr class="hit"><td class="line">56</td><td class="hits">607</td><td class="source">      max = max+1;</td></tr><tr><td class="line">57</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">58</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">59</td><td class="hits">35934</td><td class="source">    return (d.DExtent = [1, max]);</td></tr><tr><td class="line">60</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">61</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">62</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">63</td><td class="hits"></td><td class="source">  * The start of the day of the specified date.</td></tr><tr><td class="line">64</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">65</td><td class="hits"></td><td class="source">  * @param {Date} d: The specified date</td></tr><tr><td class="line">66</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">67</td><td class="hits"></td><td class="source">  start: function(d) {</td></tr><tr class="hit"><td class="line">68</td><td class="hits">20568</td><td class="source">    return d.DStart || (d.DStart = later.date.next(</td></tr><tr><td class="line">69</td><td class="hits"></td><td class="source">      later.Y.val(d), later.M.val(d), later.D.val(d)));</td></tr><tr><td class="line">70</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">71</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">72</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">73</td><td class="hits"></td><td class="source">  * The end of the day of the specified date.</td></tr><tr><td class="line">74</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">75</td><td class="hits"></td><td class="source">  * @param {Date} d: The specified date</td></tr><tr><td class="line">76</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">77</td><td class="hits"></td><td class="source">  end: function(d) {</td></tr><tr class="hit"><td class="line">78</td><td class="hits">6079</td><td class="source">    return d.DEnd || (d.DEnd = later.date.prev(</td></tr><tr><td class="line">79</td><td class="hits"></td><td class="source">      later.Y.val(d), later.M.val(d), later.D.val(d)));</td></tr><tr><td class="line">80</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">81</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">82</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">83</td><td class="hits"></td><td class="source">  * Returns the start of the next instance of the day value indicated. Returns</td></tr><tr><td class="line">84</td><td class="hits"></td><td class="source">  * the first day of the next month if val is greater than the number of</td></tr><tr><td class="line">85</td><td class="hits"></td><td class="source">  * days in the following month.</td></tr><tr><td class="line">86</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">87</td><td class="hits"></td><td class="source">  * @param {Date} d: The starting date</td></tr><tr><td class="line">88</td><td class="hits"></td><td class="source">  * @param {int} val: The desired value, must be within extent</td></tr><tr><td class="line">89</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">90</td><td class="hits"></td><td class="source">  next: function(d, val) {</td></tr><tr class="hit"><td class="line">91</td><td class="hits">1245</td><td class="source">    val = val &gt; later.D.extent(d)[1] ? 1 : val;</td></tr><tr class="hit"><td class="line">92</td><td class="hits">1245</td><td class="source">    var month = later.date.nextRollover(d, val, later.D, later.M),</td></tr><tr><td class="line">93</td><td class="hits"></td><td class="source">        DMax = later.D.extent(month)[1];</td></tr><tr><td class="line">94</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">95</td><td class="hits">1245</td><td class="source">    val = val &gt; DMax ? 1 : val || DMax;</td></tr><tr><td class="line">96</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">97</td><td class="hits">1245</td><td class="source">    return later.date.next(</td></tr><tr><td class="line">98</td><td class="hits"></td><td class="source">      later.Y.val(month),</td></tr><tr><td class="line">99</td><td class="hits"></td><td class="source">      later.M.val(month),</td></tr><tr><td class="line">100</td><td class="hits"></td><td class="source">      val</td></tr><tr><td class="line">101</td><td class="hits"></td><td class="source">    );</td></tr><tr><td class="line">102</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">103</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">104</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">105</td><td class="hits"></td><td class="source">  * Returns the end of the previous instance of the day value indicated. Returns</td></tr><tr><td class="line">106</td><td class="hits"></td><td class="source">  * the last day in the previous month if val is greater than the number of days</td></tr><tr><td class="line">107</td><td class="hits"></td><td class="source">  * in the previous month.</td></tr><tr><td class="line">108</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">109</td><td class="hits"></td><td class="source">  * @param {Date} d: The starting date</td></tr><tr><td class="line">110</td><td class="hits"></td><td class="source">  * @param {int} val: The desired value, must be within extent</td></tr><tr><td class="line">111</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">112</td><td class="hits"></td><td class="source">  prev: function(d, val) {</td></tr><tr class="hit"><td class="line">113</td><td class="hits">1029</td><td class="source">    var month = later.date.prevRollover(d, val, later.D, later.M),</td></tr><tr><td class="line">114</td><td class="hits"></td><td class="source">        DMax = later.D.extent(month)[1];</td></tr><tr><td class="line">115</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">116</td><td class="hits">1029</td><td class="source">    return later.date.prev(</td></tr><tr><td class="line">117</td><td class="hits"></td><td class="source">      later.Y.val(month),</td></tr><tr><td class="line">118</td><td class="hits"></td><td class="source">      later.M.val(month),</td></tr><tr><td class="line">119</td><td class="hits"></td><td class="source">      val &gt; DMax ? DMax : val || DMax</td></tr><tr><td class="line">120</td><td class="hits"></td><td class="source">    );</td></tr><tr><td class="line">121</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">122</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">123</td><td class="hits"></td><td class="source">};</td></tr></tbody></table></div><div class="file"><h2 id="constraint/dayofweek.js">constraint/dayofweek.js</h2><div id="stats" class="high"><div class="percentage">100%</div><div class="sloc">10</div><div class="hits">10</div><div class="misses">0</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source">* Day of Week Constraint (dw)</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source">* (c) 2013 Bill, BunKat LLC.</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source">* Definition for a day of week constraint type.</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">7</td><td class="hits"></td><td class="source">* Later is freely distributable under the MIT license.</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source">* For all details and documentation:</td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">*     http://github.com/bunkat/later</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source">*/</td></tr><tr class="hit"><td class="line">11</td><td class="hits">1</td><td class="source">later.dayOfWeek = later.dw = later.d = {</td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">13</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">14</td><td class="hits"></td><td class="source">  * The name of this constraint.</td></tr><tr><td class="line">15</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">16</td><td class="hits"></td><td class="source">  name: 'day of week',</td></tr><tr><td class="line">17</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">18</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">19</td><td class="hits"></td><td class="source">  * The rough amount of seconds between start and end for this constraint.</td></tr><tr><td class="line">20</td><td class="hits"></td><td class="source">  * (doesn't need to be exact)</td></tr><tr><td class="line">21</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">22</td><td class="hits"></td><td class="source">  range: 86400,</td></tr><tr><td class="line">23</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">24</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">25</td><td class="hits"></td><td class="source">  * The day of week value of the specified date.</td></tr><tr><td class="line">26</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">27</td><td class="hits"></td><td class="source">  * @param {Date} d: The date to calculate the value of</td></tr><tr><td class="line">28</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">29</td><td class="hits"></td><td class="source">  val: function(d) {</td></tr><tr class="hit"><td class="line">30</td><td class="hits">111085</td><td class="source">    return d.dw || (d.dw = later.date.getDay.call(d)+1);</td></tr><tr><td class="line">31</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">32</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">33</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">34</td><td class="hits"></td><td class="source">  * Returns true if the val is valid for the date specified.</td></tr><tr><td class="line">35</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">36</td><td class="hits"></td><td class="source">  * @param {Date} d: The date to check the value on</td></tr><tr><td class="line">37</td><td class="hits"></td><td class="source">  * @param {Integer} val: The value to validate</td></tr><tr><td class="line">38</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">39</td><td class="hits"></td><td class="source">  isValid: function(d, val) {</td></tr><tr class="hit"><td class="line">40</td><td class="hits">1974</td><td class="source">    return later.dw.val(d) === (val || 7);</td></tr><tr><td class="line">41</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">42</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">43</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">44</td><td class="hits"></td><td class="source">  * The minimum and maximum valid day of week values. Unlike the standard</td></tr><tr><td class="line">45</td><td class="hits"></td><td class="source">  * Date object, Later day of week goes from 1 to 7.</td></tr><tr><td class="line">46</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">47</td><td class="hits"></td><td class="source">  extent: function() {</td></tr><tr class="hit"><td class="line">48</td><td class="hits">2300</td><td class="source">    return [1, 7];</td></tr><tr><td class="line">49</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">50</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">51</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">52</td><td class="hits"></td><td class="source">  * The start of the day of the specified date.</td></tr><tr><td class="line">53</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">54</td><td class="hits"></td><td class="source">  * @param {Date} d: The specified date</td></tr><tr><td class="line">55</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">56</td><td class="hits"></td><td class="source">  start: function(d) {</td></tr><tr class="hit"><td class="line">57</td><td class="hits">417</td><td class="source">    return later.D.start(d);</td></tr><tr><td class="line">58</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">59</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">60</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">61</td><td class="hits"></td><td class="source">  * The end of the day of the specified date.</td></tr><tr><td class="line">62</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">63</td><td class="hits"></td><td class="source">  * @param {Date} d: The specified date</td></tr><tr><td class="line">64</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">65</td><td class="hits"></td><td class="source">  end: function(d) {</td></tr><tr class="hit"><td class="line">66</td><td class="hits">346</td><td class="source">    return later.D.end(d);</td></tr><tr><td class="line">67</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">68</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">69</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">70</td><td class="hits"></td><td class="source">  * Returns the start of the next instance of the day of week value indicated.</td></tr><tr><td class="line">71</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">72</td><td class="hits"></td><td class="source">  * @param {Date} d: The starting date</td></tr><tr><td class="line">73</td><td class="hits"></td><td class="source">  * @param {int} val: The desired value, must be within extent</td></tr><tr><td class="line">74</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">75</td><td class="hits"></td><td class="source">  next: function(d, val) {</td></tr><tr class="hit"><td class="line">76</td><td class="hits">30253</td><td class="source">    val = val &gt; 7 ? 1 : val || 7;</td></tr><tr><td class="line">77</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">78</td><td class="hits">30253</td><td class="source">    return later.date.next(</td></tr><tr><td class="line">79</td><td class="hits"></td><td class="source">      later.Y.val(d),</td></tr><tr><td class="line">80</td><td class="hits"></td><td class="source">      later.M.val(d),</td></tr><tr><td class="line">81</td><td class="hits"></td><td class="source">      later.D.val(d) + (val - later.dw.val(d)) + (val &lt;= later.dw.val(d) ? 7 : 0));</td></tr><tr><td class="line">82</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">83</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">84</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">85</td><td class="hits"></td><td class="source">  * Returns the end of the previous instance of the day of week value indicated.</td></tr><tr><td class="line">86</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">87</td><td class="hits"></td><td class="source">  * @param {Date} d: The starting date</td></tr><tr><td class="line">88</td><td class="hits"></td><td class="source">  * @param {int} val: The desired value, must be within extent</td></tr><tr><td class="line">89</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">90</td><td class="hits"></td><td class="source">  prev: function(d, val) {</td></tr><tr class="hit"><td class="line">91</td><td class="hits">414</td><td class="source">    val = val &gt; 7 ? 7 : val || 7;</td></tr><tr><td class="line">92</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">93</td><td class="hits">414</td><td class="source">    return later.date.prev(</td></tr><tr><td class="line">94</td><td class="hits"></td><td class="source">      later.Y.val(d),</td></tr><tr><td class="line">95</td><td class="hits"></td><td class="source">      later.M.val(d),</td></tr><tr><td class="line">96</td><td class="hits"></td><td class="source">      later.D.val(d) + (val - later.dw.val(d)) + (val &gt;= later.dw.val(d) ? -7 : 0));</td></tr><tr><td class="line">97</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">98</td><td class="hits"></td><td class="source">};</td></tr></tbody></table></div><div class="file"><h2 id="constraint/dayofweekcount.js">constraint/dayofweekcount.js</h2><div id="stats" class="high"><div class="percentage">100%</div><div class="sloc">17</div><div class="hits">17</div><div class="misses">0</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source">* Day of Week Count Constraint (dc)</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source">* (c) 2013 Bill, BunKat LLC.</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source">* Definition for a day of week count constraint type. This constraint is used</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source">* to specify schedules like '2nd Tuesday of every month'.</td></tr><tr><td class="line">7</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source">* Later is freely distributable under the MIT license.</td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">* For all details and documentation:</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source">*     http://github.com/bunkat/later</td></tr><tr><td class="line">11</td><td class="hits"></td><td class="source">*/</td></tr><tr class="hit"><td class="line">12</td><td class="hits">1</td><td class="source">later.dayOfWeekCount = later.dc = {</td></tr><tr><td class="line">13</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">14</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">15</td><td class="hits"></td><td class="source">  * The name of this constraint.</td></tr><tr><td class="line">16</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">17</td><td class="hits"></td><td class="source">  name: 'day of week count',</td></tr><tr><td class="line">18</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">19</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">20</td><td class="hits"></td><td class="source">  * The rough amount of seconds between start and end for this constraint.</td></tr><tr><td class="line">21</td><td class="hits"></td><td class="source">  * (doesn't need to be exact)</td></tr><tr><td class="line">22</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">23</td><td class="hits"></td><td class="source">  range: 604800,</td></tr><tr><td class="line">24</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">25</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">26</td><td class="hits"></td><td class="source">  * The day of week count value of the specified date.</td></tr><tr><td class="line">27</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">28</td><td class="hits"></td><td class="source">  * @param {Date} d: The date to calculate the value of</td></tr><tr><td class="line">29</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">30</td><td class="hits"></td><td class="source">  val: function(d) {</td></tr><tr class="hit"><td class="line">31</td><td class="hits">2966</td><td class="source">    return d.dc || (d.dc = Math.floor((later.D.val(d)-1)/7)+1);</td></tr><tr><td class="line">32</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">33</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">34</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">35</td><td class="hits"></td><td class="source">  * Returns true if the val is valid for the date specified.</td></tr><tr><td class="line">36</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">37</td><td class="hits"></td><td class="source">  * @param {Date} d: The date to check the value on</td></tr><tr><td class="line">38</td><td class="hits"></td><td class="source">  * @param {Integer} val: The value to validate</td></tr><tr><td class="line">39</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">40</td><td class="hits"></td><td class="source">  isValid: function(d, val) {</td></tr><tr class="hit"><td class="line">41</td><td class="hits">1095</td><td class="source">    return (later.dc.val(d) === val) ||</td></tr><tr><td class="line">42</td><td class="hits"></td><td class="source">           (val === 0 &amp;&amp; later.D.val(d) &gt; later.D.extent(d)[1] - 7);</td></tr><tr><td class="line">43</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">44</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">45</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">46</td><td class="hits"></td><td class="source">  * The minimum and maximum valid day values of the month specified.</td></tr><tr><td class="line">47</td><td class="hits"></td><td class="source">  * Zero to specify the last day of week count of the month.</td></tr><tr><td class="line">48</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">49</td><td class="hits"></td><td class="source">  * @param {Date} d: The date indicating the month to find the extent of</td></tr><tr><td class="line">50</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">51</td><td class="hits"></td><td class="source">  extent: function(d) {</td></tr><tr class="hit"><td class="line">52</td><td class="hits">2316</td><td class="source">    return d.dcExtent || (d.dcExtent = [1, Math.ceil(later.D.extent(d)[1] /7)]);</td></tr><tr><td class="line">53</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">54</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">55</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">56</td><td class="hits"></td><td class="source">  * The first day of the month with the same day of week count as the date</td></tr><tr><td class="line">57</td><td class="hits"></td><td class="source">  * specified.</td></tr><tr><td class="line">58</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">59</td><td class="hits"></td><td class="source">  * @param {Date} d: The specified date</td></tr><tr><td class="line">60</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">61</td><td class="hits"></td><td class="source">  start: function(d) {</td></tr><tr class="hit"><td class="line">62</td><td class="hits">180</td><td class="source">    return d.dcStart || (d.dcStart =</td></tr><tr><td class="line">63</td><td class="hits"></td><td class="source">      later.date.next(</td></tr><tr><td class="line">64</td><td class="hits"></td><td class="source">        later.Y.val(d),</td></tr><tr><td class="line">65</td><td class="hits"></td><td class="source">        later.M.val(d),</td></tr><tr><td class="line">66</td><td class="hits"></td><td class="source">        Math.max(1, ((later.dc.val(d) - 1) * 7) + 1 || 1)));</td></tr><tr><td class="line">67</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">68</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">69</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">70</td><td class="hits"></td><td class="source">  * The last day of the month with the same day of week count as the date</td></tr><tr><td class="line">71</td><td class="hits"></td><td class="source">  * specified.</td></tr><tr><td class="line">72</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">73</td><td class="hits"></td><td class="source">  * @param {Date} d: The specified date</td></tr><tr><td class="line">74</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">75</td><td class="hits"></td><td class="source">  end: function(d) {</td></tr><tr class="hit"><td class="line">76</td><td class="hits">427</td><td class="source">    return d.dcEnd || (d.dcEnd =</td></tr><tr><td class="line">77</td><td class="hits"></td><td class="source">      later.date.prev(</td></tr><tr><td class="line">78</td><td class="hits"></td><td class="source">        later.Y.val(d),</td></tr><tr><td class="line">79</td><td class="hits"></td><td class="source">        later.M.val(d),</td></tr><tr><td class="line">80</td><td class="hits"></td><td class="source">        Math.min(later.dc.val(d) * 7, later.D.extent(d)[1])));</td></tr><tr><td class="line">81</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">82</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">83</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">84</td><td class="hits"></td><td class="source">  * Returns the next earliest date with the day of week count specified.</td></tr><tr><td class="line">85</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">86</td><td class="hits"></td><td class="source">  * @param {Date} d: The starting date</td></tr><tr><td class="line">87</td><td class="hits"></td><td class="source">  * @param {int} val: The desired value, must be within extent</td></tr><tr><td class="line">88</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">89</td><td class="hits"></td><td class="source">  next: function(d, val) {</td></tr><tr class="hit"><td class="line">90</td><td class="hits">256</td><td class="source">    val = val &gt; later.dc.extent(d)[1] ? 1 : val;</td></tr><tr class="hit"><td class="line">91</td><td class="hits">256</td><td class="source">    var month = later.date.nextRollover(d, val, later.dc, later.M),</td></tr><tr><td class="line">92</td><td class="hits"></td><td class="source">        dcMax = later.dc.extent(month)[1];</td></tr><tr><td class="line">93</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">94</td><td class="hits">256</td><td class="source">    val = val &gt; dcMax ? 1 : val;</td></tr><tr><td class="line">95</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">96</td><td class="hits">256</td><td class="source">    var next = later.date.next(</td></tr><tr><td class="line">97</td><td class="hits"></td><td class="source">      later.Y.val(month),</td></tr><tr><td class="line">98</td><td class="hits"></td><td class="source">      later.M.val(month),</td></tr><tr><td class="line">99</td><td class="hits"></td><td class="source">      val === 0 ? later.D.extent(month)[1] - 6 : 1 + (7 * (val - 1))</td></tr><tr><td class="line">100</td><td class="hits"></td><td class="source">    );</td></tr><tr><td class="line">101</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">102</td><td class="hits">256</td><td class="source">    if(next.getTime() &lt;= d.getTime()) {</td></tr><tr class="hit"><td class="line">103</td><td class="hits">2</td><td class="source">      month = later.M.next(d, later.M.val(d)+1);</td></tr><tr><td class="line">104</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">105</td><td class="hits">2</td><td class="source">      return later.date.next(</td></tr><tr><td class="line">106</td><td class="hits"></td><td class="source">        later.Y.val(month),</td></tr><tr><td class="line">107</td><td class="hits"></td><td class="source">        later.M.val(month),</td></tr><tr><td class="line">108</td><td class="hits"></td><td class="source">        val === 0 ? later.D.extent(month)[1] - 6 : 1 + (7 * (val - 1))</td></tr><tr><td class="line">109</td><td class="hits"></td><td class="source">      );</td></tr><tr><td class="line">110</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">111</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">112</td><td class="hits">254</td><td class="source">    return next;</td></tr><tr><td class="line">113</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">114</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">115</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">116</td><td class="hits"></td><td class="source">  * Returns the closest previous date with the day of week count specified.</td></tr><tr><td class="line">117</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">118</td><td class="hits"></td><td class="source">  * @param {Date} d: The starting date</td></tr><tr><td class="line">119</td><td class="hits"></td><td class="source">  * @param {int} val: The desired value, must be within extent</td></tr><tr><td class="line">120</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">121</td><td class="hits"></td><td class="source">  prev: function(d, val) {</td></tr><tr class="hit"><td class="line">122</td><td class="hits">221</td><td class="source">    var month = later.date.prevRollover(d, val, later.dc, later.M),</td></tr><tr><td class="line">123</td><td class="hits"></td><td class="source">        dcMax = later.dc.extent(month)[1];</td></tr><tr><td class="line">124</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">125</td><td class="hits">221</td><td class="source">    val = val &gt; dcMax ? dcMax : val || dcMax;</td></tr><tr><td class="line">126</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">127</td><td class="hits">221</td><td class="source">    return later.dc.end(later.date.prev(</td></tr><tr><td class="line">128</td><td class="hits"></td><td class="source">      later.Y.val(month),</td></tr><tr><td class="line">129</td><td class="hits"></td><td class="source">      later.M.val(month),</td></tr><tr><td class="line">130</td><td class="hits"></td><td class="source">      1 + (7 * (val - 1))</td></tr><tr><td class="line">131</td><td class="hits"></td><td class="source">    ));</td></tr><tr><td class="line">132</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">133</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">134</td><td class="hits"></td><td class="source">};</td></tr></tbody></table></div><div class="file"><h2 id="constraint/dayofyear.js">constraint/dayofyear.js</h2><div id="stats" class="high"><div class="percentage">100%</div><div class="sloc">14</div><div class="hits">14</div><div class="misses">0</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source">* Day of Year Constraint (dy)</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source">* (c) 2013 Bill, BunKat LLC.</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source">* Definition for a day of year constraint type.</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">7</td><td class="hits"></td><td class="source">* Later is freely distributable under the MIT license.</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source">* For all details and documentation:</td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">*     http://github.com/bunkat/later</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source">*/</td></tr><tr class="hit"><td class="line">11</td><td class="hits">1</td><td class="source">later.dayOfYear = later.dy = {</td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">13</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">14</td><td class="hits"></td><td class="source">  * The name of this constraint.</td></tr><tr><td class="line">15</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">16</td><td class="hits"></td><td class="source">  name: 'day of year',</td></tr><tr><td class="line">17</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">18</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">19</td><td class="hits"></td><td class="source">  * The rough amount of seconds between start and end for this constraint.</td></tr><tr><td class="line">20</td><td class="hits"></td><td class="source">  * (doesn't need to be exact)</td></tr><tr><td class="line">21</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">22</td><td class="hits"></td><td class="source">  range: 86400,</td></tr><tr><td class="line">23</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">24</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">25</td><td class="hits"></td><td class="source">  * The day of year value of the specified date.</td></tr><tr><td class="line">26</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">27</td><td class="hits"></td><td class="source">  * @param {Date} d: The date to calculate the value of</td></tr><tr><td class="line">28</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">29</td><td class="hits"></td><td class="source">  val: function(d) {</td></tr><tr class="hit"><td class="line">30</td><td class="hits">19188</td><td class="source">    return d.dy || (d.dy =</td></tr><tr><td class="line">31</td><td class="hits"></td><td class="source">      Math.ceil(1 + (later.D.start(d).getTime() - later.Y.start(d).getTime()) / later.DAY));</td></tr><tr><td class="line">32</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">33</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">34</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">35</td><td class="hits"></td><td class="source">  * Returns true if the val is valid for the date specified.</td></tr><tr><td class="line">36</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">37</td><td class="hits"></td><td class="source">  * @param {Date} d: The date to check the value on</td></tr><tr><td class="line">38</td><td class="hits"></td><td class="source">  * @param {Integer} val: The value to validate</td></tr><tr><td class="line">39</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">40</td><td class="hits"></td><td class="source">  isValid: function(d, val) {</td></tr><tr class="hit"><td class="line">41</td><td class="hits">9568</td><td class="source">    return later.dy.val(d) === (val || later.dy.extent(d)[1]);</td></tr><tr><td class="line">42</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">43</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">44</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">45</td><td class="hits"></td><td class="source">  * The minimum and maximum valid day of year values of the month specified.</td></tr><tr><td class="line">46</td><td class="hits"></td><td class="source">  * Zero indicates the last day of the year.</td></tr><tr><td class="line">47</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">48</td><td class="hits"></td><td class="source">  * @param {Date} d: The date indicating the month to find the extent of</td></tr><tr><td class="line">49</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">50</td><td class="hits"></td><td class="source">  extent: function(d) {</td></tr><tr class="hit"><td class="line">51</td><td class="hits">34831</td><td class="source">    var year = later.Y.val(d);</td></tr><tr><td class="line">52</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">53</td><td class="hits"></td><td class="source">    // shortcut on finding leap years since this function gets called a lot</td></tr><tr><td class="line">54</td><td class="hits"></td><td class="source">    // works between 1901 and 2099</td></tr><tr class="hit"><td class="line">55</td><td class="hits">34831</td><td class="source">    return d.dyExtent || (d.dyExtent = [1, year % 4 ? 365 : 366]);</td></tr><tr><td class="line">56</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">57</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">58</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">59</td><td class="hits"></td><td class="source">  * The start of the day of year of the specified date.</td></tr><tr><td class="line">60</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">61</td><td class="hits"></td><td class="source">  * @param {Date} d: The specified date</td></tr><tr><td class="line">62</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">63</td><td class="hits"></td><td class="source">  start: function(d) {</td></tr><tr class="hit"><td class="line">64</td><td class="hits">4810</td><td class="source">    return later.D.start(d);</td></tr><tr><td class="line">65</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">66</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">67</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">68</td><td class="hits"></td><td class="source">  * The end of the day of year of the specified date.</td></tr><tr><td class="line">69</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">70</td><td class="hits"></td><td class="source">  * @param {Date} d: The specified date</td></tr><tr><td class="line">71</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">72</td><td class="hits"></td><td class="source">  end: function(d) {</td></tr><tr class="hit"><td class="line">73</td><td class="hits">4810</td><td class="source">    return later.D.end(d);</td></tr><tr><td class="line">74</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">75</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">76</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">77</td><td class="hits"></td><td class="source">  * Returns the start of the next instance of the day of year value indicated.</td></tr><tr><td class="line">78</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">79</td><td class="hits"></td><td class="source">  * @param {Date} d: The starting date</td></tr><tr><td class="line">80</td><td class="hits"></td><td class="source">  * @param {int} val: The desired value, must be within extent</td></tr><tr><td class="line">81</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">82</td><td class="hits"></td><td class="source">  next: function(d, val) {</td></tr><tr class="hit"><td class="line">83</td><td class="hits">4784</td><td class="source">    val = val &gt; later.dy.extent(d)[1] ? 1 : val;</td></tr><tr class="hit"><td class="line">84</td><td class="hits">4784</td><td class="source">    var year = later.date.nextRollover(d, val, later.dy, later.Y),</td></tr><tr><td class="line">85</td><td class="hits"></td><td class="source">        dyMax = later.dy.extent(year)[1];</td></tr><tr><td class="line">86</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">87</td><td class="hits">4784</td><td class="source">    val = val &gt; dyMax ? 1 : val || dyMax;</td></tr><tr><td class="line">88</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">89</td><td class="hits">4784</td><td class="source">    return later.date.next(</td></tr><tr><td class="line">90</td><td class="hits"></td><td class="source">      later.Y.val(year),</td></tr><tr><td class="line">91</td><td class="hits"></td><td class="source">      later.M.val(year),</td></tr><tr><td class="line">92</td><td class="hits"></td><td class="source">      val</td></tr><tr><td class="line">93</td><td class="hits"></td><td class="source">    );</td></tr><tr><td class="line">94</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">95</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">96</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">97</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">98</td><td class="hits"></td><td class="source">  * Returns the end of the previous instance of the day of year value indicated.</td></tr><tr><td class="line">99</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">100</td><td class="hits"></td><td class="source">  * @param {Date} d: The starting date</td></tr><tr><td class="line">101</td><td class="hits"></td><td class="source">  * @param {int} val: The desired value, must be within extent</td></tr><tr><td class="line">102</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">103</td><td class="hits"></td><td class="source">  prev: function(d, val) {</td></tr><tr class="hit"><td class="line">104</td><td class="hits">4784</td><td class="source">    var year = later.date.prevRollover(d, val, later.dy, later.Y),</td></tr><tr><td class="line">105</td><td class="hits"></td><td class="source">        dyMax = later.dy.extent(year)[1];</td></tr><tr><td class="line">106</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">107</td><td class="hits">4784</td><td class="source">    val = val &gt; dyMax ? dyMax : val || dyMax;</td></tr><tr><td class="line">108</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">109</td><td class="hits">4784</td><td class="source">    return later.date.prev(</td></tr><tr><td class="line">110</td><td class="hits"></td><td class="source">      later.Y.val(year),</td></tr><tr><td class="line">111</td><td class="hits"></td><td class="source">      later.M.val(year),</td></tr><tr><td class="line">112</td><td class="hits"></td><td class="source">      val</td></tr><tr><td class="line">113</td><td class="hits"></td><td class="source">    );</td></tr><tr><td class="line">114</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">115</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">116</td><td class="hits"></td><td class="source">};</td></tr></tbody></table></div><div class="file"><h2 id="constraint/fulldate.js">constraint/fulldate.js</h2><div id="stats" class="high"><div class="percentage">100%</div><div class="sloc">8</div><div class="hits">8</div><div class="misses">0</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source">* Full date (fd)</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source">* (c) 2013 Bill, BunKat LLC.</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source">* Definition for specifying a full date and time.</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">7</td><td class="hits"></td><td class="source">* Later is freely distributable under the MIT license.</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source">* For all details and documentation:</td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">*     http://github.com/bunkat/later</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source">*/</td></tr><tr class="hit"><td class="line">11</td><td class="hits">1</td><td class="source">later.fullDate = later.fd = {</td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">13</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">14</td><td class="hits"></td><td class="source">  * The name of this constraint.</td></tr><tr><td class="line">15</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">16</td><td class="hits"></td><td class="source">  name: 'full date',</td></tr><tr><td class="line">17</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">18</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">19</td><td class="hits"></td><td class="source">  * The rough amount of seconds between start and end for this constraint.</td></tr><tr><td class="line">20</td><td class="hits"></td><td class="source">  * (doesn't need to be exact)</td></tr><tr><td class="line">21</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">22</td><td class="hits"></td><td class="source">  range: 1,</td></tr><tr><td class="line">23</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">24</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">25</td><td class="hits"></td><td class="source">  * The time value of the specified date.</td></tr><tr><td class="line">26</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">27</td><td class="hits"></td><td class="source">  * @param {Date} d: The date to calculate the value of</td></tr><tr><td class="line">28</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">29</td><td class="hits"></td><td class="source">  val: function(d) {</td></tr><tr class="hit"><td class="line">30</td><td class="hits">62</td><td class="source">    return d.fd || (d.fd = d.getTime());</td></tr><tr><td class="line">31</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">32</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">33</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">34</td><td class="hits"></td><td class="source">  * Returns true if the val is valid for the date specified.</td></tr><tr><td class="line">35</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">36</td><td class="hits"></td><td class="source">  * @param {Date} d: The date to check the value on</td></tr><tr><td class="line">37</td><td class="hits"></td><td class="source">  * @param {Integer} val: The value to validate</td></tr><tr><td class="line">38</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">39</td><td class="hits"></td><td class="source">  isValid: function(d, val) {</td></tr><tr class="hit"><td class="line">40</td><td class="hits">8</td><td class="source">    return later.fd.val(d) === val;</td></tr><tr><td class="line">41</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">42</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">43</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">44</td><td class="hits"></td><td class="source">  * The minimum and maximum valid time values.</td></tr><tr><td class="line">45</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">46</td><td class="hits"></td><td class="source">  extent: function() {</td></tr><tr class="hit"><td class="line">47</td><td class="hits">34</td><td class="source">    return [0, 32503680000000];</td></tr><tr><td class="line">48</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">49</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">50</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">51</td><td class="hits"></td><td class="source">  * Returns the specified date.</td></tr><tr><td class="line">52</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">53</td><td class="hits"></td><td class="source">  * @param {Date} d: The specified date</td></tr><tr><td class="line">54</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">55</td><td class="hits"></td><td class="source">  start: function(d) {</td></tr><tr class="hit"><td class="line">56</td><td class="hits">6</td><td class="source">    return d;</td></tr><tr><td class="line">57</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">58</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">59</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">60</td><td class="hits"></td><td class="source">  * Returns the specified date.</td></tr><tr><td class="line">61</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">62</td><td class="hits"></td><td class="source">  * @param {Date} d: The specified date</td></tr><tr><td class="line">63</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">64</td><td class="hits"></td><td class="source">  end: function(d) {</td></tr><tr class="hit"><td class="line">65</td><td class="hits">2</td><td class="source">    return d;</td></tr><tr><td class="line">66</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">67</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">68</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">69</td><td class="hits"></td><td class="source">  * Returns the start of the next instance of the time value indicated.</td></tr><tr><td class="line">70</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">71</td><td class="hits"></td><td class="source">  * @param {Date} d: The starting date</td></tr><tr><td class="line">72</td><td class="hits"></td><td class="source">  * @param {int} val: The desired value, must be within extent</td></tr><tr><td class="line">73</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">74</td><td class="hits"></td><td class="source">  next: function(d, val) {</td></tr><tr class="hit"><td class="line">75</td><td class="hits">13</td><td class="source">    return later.fd.val(d) &lt; val ? new Date(val) : later.NEVER;</td></tr><tr><td class="line">76</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">77</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">78</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">79</td><td class="hits"></td><td class="source">  * Returns the end of the previous instance of the time value indicated.</td></tr><tr><td class="line">80</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">81</td><td class="hits"></td><td class="source">  * @param {Date} d: The starting date</td></tr><tr><td class="line">82</td><td class="hits"></td><td class="source">  * @param {int} val: The desired value, must be within extent</td></tr><tr><td class="line">83</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">84</td><td class="hits"></td><td class="source">  prev: function(d, val) {</td></tr><tr class="hit"><td class="line">85</td><td class="hits">3</td><td class="source">    return later.fd.val(d) &gt; val ? new Date(val) : later.NEVER;</td></tr><tr><td class="line">86</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">87</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">88</td><td class="hits"></td><td class="source">};</td></tr></tbody></table></div><div class="file"><h2 id="constraint/hour.js">constraint/hour.js</h2><div id="stats" class="high"><div class="percentage">100%</div><div class="sloc">13</div><div class="hits">13</div><div class="misses">0</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source">* Hour Constraint (H)</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source">* (c) 2013 Bill, BunKat LLC.</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source">* Definition for a hour constraint type.</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">7</td><td class="hits"></td><td class="source">* Later is freely distributable under the MIT license.</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source">* For all details and documentation:</td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">*     http://github.com/bunkat/later</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source">*/</td></tr><tr class="hit"><td class="line">11</td><td class="hits">1</td><td class="source">later.hour = later.h = {</td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">13</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">14</td><td class="hits"></td><td class="source">  * The name of this constraint.</td></tr><tr><td class="line">15</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">16</td><td class="hits"></td><td class="source">  name: 'hour',</td></tr><tr><td class="line">17</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">18</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">19</td><td class="hits"></td><td class="source">  * The rough amount of seconds between start and end for this constraint.</td></tr><tr><td class="line">20</td><td class="hits"></td><td class="source">  * (doesn't need to be exact)</td></tr><tr><td class="line">21</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">22</td><td class="hits"></td><td class="source">  range: 3600,</td></tr><tr><td class="line">23</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">24</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">25</td><td class="hits"></td><td class="source">  * The hour value of the specified date.</td></tr><tr><td class="line">26</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">27</td><td class="hits"></td><td class="source">  * @param {Date} d: The date to calculate the value of</td></tr><tr><td class="line">28</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">29</td><td class="hits"></td><td class="source">  val: function(d) {</td></tr><tr class="hit"><td class="line">30</td><td class="hits">33989</td><td class="source">    return d.h || (d.h = later.date.getHour.call(d));</td></tr><tr><td class="line">31</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">32</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">33</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">34</td><td class="hits"></td><td class="source">  * Returns true if the val is valid for the date specified.</td></tr><tr><td class="line">35</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">36</td><td class="hits"></td><td class="source">  * @param {Date} d: The date to check the value on</td></tr><tr><td class="line">37</td><td class="hits"></td><td class="source">  * @param {Integer} val: The value to validate</td></tr><tr><td class="line">38</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">39</td><td class="hits"></td><td class="source">  isValid: function(d, val) {</td></tr><tr class="hit"><td class="line">40</td><td class="hits">3023</td><td class="source">    return later.h.val(d) === val;</td></tr><tr><td class="line">41</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">42</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">43</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">44</td><td class="hits"></td><td class="source">  * The minimum and maximum valid hour values.</td></tr><tr><td class="line">45</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">46</td><td class="hits"></td><td class="source">  extent: function() {</td></tr><tr class="hit"><td class="line">47</td><td class="hits">3962</td><td class="source">    return [0, 23];</td></tr><tr><td class="line">48</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">49</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">50</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">51</td><td class="hits"></td><td class="source">  * The start of the hour of the specified date.</td></tr><tr><td class="line">52</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">53</td><td class="hits"></td><td class="source">  * @param {Date} d: The specified date</td></tr><tr><td class="line">54</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">55</td><td class="hits"></td><td class="source">  start: function(d) {</td></tr><tr class="hit"><td class="line">56</td><td class="hits">734</td><td class="source">    return d.hStart || (d.hStart = later.date.next(</td></tr><tr><td class="line">57</td><td class="hits"></td><td class="source">      later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d)));</td></tr><tr><td class="line">58</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">59</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">60</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">61</td><td class="hits"></td><td class="source">  * The end of the hour of the specified date.</td></tr><tr><td class="line">62</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">63</td><td class="hits"></td><td class="source">  * @param {Date} d: The specified date</td></tr><tr><td class="line">64</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">65</td><td class="hits"></td><td class="source">  end: function(d) {</td></tr><tr class="hit"><td class="line">66</td><td class="hits">707</td><td class="source">    return d.hEnd || (d.hEnd = later.date.prev(</td></tr><tr><td class="line">67</td><td class="hits"></td><td class="source">      later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d)));</td></tr><tr><td class="line">68</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">69</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">70</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">71</td><td class="hits"></td><td class="source">  * Returns the start of the next instance of the hour value indicated.</td></tr><tr><td class="line">72</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">73</td><td class="hits"></td><td class="source">  * @param {Date} d: The starting date</td></tr><tr><td class="line">74</td><td class="hits"></td><td class="source">  * @param {int} val: The desired value, must be within extent</td></tr><tr><td class="line">75</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">76</td><td class="hits"></td><td class="source">  next: function(d, val) {</td></tr><tr class="hit"><td class="line">77</td><td class="hits">955</td><td class="source">    val = val &gt; 23 ? 0 : val;</td></tr><tr><td class="line">78</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">79</td><td class="hits">955</td><td class="source">    var next = later.date.next(</td></tr><tr><td class="line">80</td><td class="hits"></td><td class="source">      later.Y.val(d),</td></tr><tr><td class="line">81</td><td class="hits"></td><td class="source">      later.M.val(d),</td></tr><tr><td class="line">82</td><td class="hits"></td><td class="source">      later.D.val(d) + (val &lt;= later.h.val(d) ? 1 : 0),</td></tr><tr><td class="line">83</td><td class="hits"></td><td class="source">      val);</td></tr><tr><td class="line">84</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">85</td><td class="hits"></td><td class="source">    // correct for passing over a daylight savings boundry</td></tr><tr class="hit"><td class="line">86</td><td class="hits">955</td><td class="source">    if(!later.date.isUTC &amp;&amp; next.getTime() &lt;= d.getTime()) {</td></tr><tr class="hit"><td class="line">87</td><td class="hits">1</td><td class="source">      next = later.date.next(</td></tr><tr><td class="line">88</td><td class="hits"></td><td class="source">        later.Y.val(next),</td></tr><tr><td class="line">89</td><td class="hits"></td><td class="source">        later.M.val(next),</td></tr><tr><td class="line">90</td><td class="hits"></td><td class="source">        later.D.val(next),</td></tr><tr><td class="line">91</td><td class="hits"></td><td class="source">        val + 1);</td></tr><tr><td class="line">92</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">93</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">94</td><td class="hits">955</td><td class="source">    return next;</td></tr><tr><td class="line">95</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">96</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">97</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">98</td><td class="hits"></td><td class="source">  * Returns the end of the previous instance of the hour value indicated.</td></tr><tr><td class="line">99</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">100</td><td class="hits"></td><td class="source">  * @param {Date} d: The starting date</td></tr><tr><td class="line">101</td><td class="hits"></td><td class="source">  * @param {int} val: The desired value, must be within extent</td></tr><tr><td class="line">102</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">103</td><td class="hits"></td><td class="source">  prev: function(d, val) {</td></tr><tr class="hit"><td class="line">104</td><td class="hits">816</td><td class="source">    val = val &gt; 23 ? 23 : val;</td></tr><tr><td class="line">105</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">106</td><td class="hits">816</td><td class="source">    return later.date.prev(</td></tr><tr><td class="line">107</td><td class="hits"></td><td class="source">      later.Y.val(d),</td></tr><tr><td class="line">108</td><td class="hits"></td><td class="source">      later.M.val(d),</td></tr><tr><td class="line">109</td><td class="hits"></td><td class="source">      later.D.val(d) + (val &gt;= later.h.val(d) ? -1 : 0),</td></tr><tr><td class="line">110</td><td class="hits"></td><td class="source">      val);</td></tr><tr><td class="line">111</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">112</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">113</td><td class="hits"></td><td class="source">};</td></tr></tbody></table></div><div class="file"><h2 id="constraint/minute.js">constraint/minute.js</h2><div id="stats" class="high"><div class="percentage">91%</div><div class="sloc">12</div><div class="hits">11</div><div class="misses">1</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source">* Minute Constraint (m)</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source">* (c) 2013 Bill, BunKat LLC.</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source">* Definition for a minute constraint type.</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">7</td><td class="hits"></td><td class="source">* Later is freely distributable under the MIT license.</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source">* For all details and documentation:</td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">*     http://github.com/bunkat/later</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source">*/</td></tr><tr class="hit"><td class="line">11</td><td class="hits">1</td><td class="source">later.minute = later.m = {</td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">13</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">14</td><td class="hits"></td><td class="source">  * The name of this constraint.</td></tr><tr><td class="line">15</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">16</td><td class="hits"></td><td class="source">  name: 'minute',</td></tr><tr><td class="line">17</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">18</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">19</td><td class="hits"></td><td class="source">  * The rough amount of seconds between start and end for this constraint.</td></tr><tr><td class="line">20</td><td class="hits"></td><td class="source">  * (doesn't need to be exact)</td></tr><tr><td class="line">21</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">22</td><td class="hits"></td><td class="source">  range: 60,</td></tr><tr><td class="line">23</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">24</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">25</td><td class="hits"></td><td class="source">  * The minute value of the specified date.</td></tr><tr><td class="line">26</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">27</td><td class="hits"></td><td class="source">  * @param {Date} d: The date to calculate the value of</td></tr><tr><td class="line">28</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">29</td><td class="hits"></td><td class="source">  val: function(d) {</td></tr><tr class="hit"><td class="line">30</td><td class="hits">38147</td><td class="source">    return d.m || (d.m = later.date.getMin.call(d));</td></tr><tr><td class="line">31</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">32</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">33</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">34</td><td class="hits"></td><td class="source">  * Returns true if the val is valid for the date specified.</td></tr><tr><td class="line">35</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">36</td><td class="hits"></td><td class="source">  * @param {Date} d: The date to check the value on</td></tr><tr><td class="line">37</td><td class="hits"></td><td class="source">  * @param {Integer} val: The value to validate</td></tr><tr><td class="line">38</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">39</td><td class="hits"></td><td class="source">  isValid: function(d, val) {</td></tr><tr class="hit"><td class="line">40</td><td class="hits">5226</td><td class="source">    return later.m.val(d) === val;</td></tr><tr><td class="line">41</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">42</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">43</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">44</td><td class="hits"></td><td class="source">  * The minimum and maximum valid minute values.</td></tr><tr><td class="line">45</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">46</td><td class="hits"></td><td class="source">  extent: function(d) {</td></tr><tr class="hit"><td class="line">47</td><td class="hits">8538</td><td class="source">    return [0, 59];</td></tr><tr><td class="line">48</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">49</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">50</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">51</td><td class="hits"></td><td class="source">  * The start of the minute of the specified date.</td></tr><tr><td class="line">52</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">53</td><td class="hits"></td><td class="source">  * @param {Date} d: The specified date</td></tr><tr><td class="line">54</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">55</td><td class="hits"></td><td class="source">  start: function(d) {</td></tr><tr class="hit"><td class="line">56</td><td class="hits">3110</td><td class="source">    return d.mStart || (d.mStart = later.date.next(</td></tr><tr><td class="line">57</td><td class="hits"></td><td class="source">      later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d), later.m.val(d)));</td></tr><tr><td class="line">58</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">59</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">60</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">61</td><td class="hits"></td><td class="source">  * The end of the minute of the specified date.</td></tr><tr><td class="line">62</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">63</td><td class="hits"></td><td class="source">  * @param {Date} d: The specified date</td></tr><tr><td class="line">64</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">65</td><td class="hits"></td><td class="source">  end: function(d) {</td></tr><tr class="hit"><td class="line">66</td><td class="hits">1895</td><td class="source">    return d.mEnd || (d.mEnd = later.date.prev(</td></tr><tr><td class="line">67</td><td class="hits"></td><td class="source">      later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d), later.m.val(d)));</td></tr><tr><td class="line">68</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">69</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">70</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">71</td><td class="hits"></td><td class="source">  * Returns the start of the next instance of the minute value indicated.</td></tr><tr><td class="line">72</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">73</td><td class="hits"></td><td class="source">  * @param {Date} d: The starting date</td></tr><tr><td class="line">74</td><td class="hits"></td><td class="source">  * @param {int} val: The desired value, must be within extent</td></tr><tr><td class="line">75</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">76</td><td class="hits"></td><td class="source">  next: function(d, val) {</td></tr><tr class="hit"><td class="line">77</td><td class="hits">2303</td><td class="source">    var m = later.m.val(d),</td></tr><tr><td class="line">78</td><td class="hits"></td><td class="source">        s = later.s.val(d),</td></tr><tr><td class="line">79</td><td class="hits"></td><td class="source">        inc = val &gt; 59 ? 60-m : (val &lt;= m ? (60-m) + val : val-m),</td></tr><tr><td class="line">80</td><td class="hits"></td><td class="source">        next = new Date(d.getTime() + (inc * later.MIN) - (s * later.SEC));</td></tr><tr><td class="line">81</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">82</td><td class="hits"></td><td class="source">    // correct for passing over a daylight savings boundry</td></tr><tr class="hit"><td class="line">83</td><td class="hits">2303</td><td class="source">    if(!later.date.isUTC &amp;&amp; next.getTime() &lt;= d.getTime()) {</td></tr><tr class="miss"><td class="line">84</td><td class="hits">0</td><td class="source">      next = new Date(d.getTime() + ((inc + 120) * later.MIN) - (s * later.SEC));</td></tr><tr><td class="line">85</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">86</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">87</td><td class="hits">2303</td><td class="source">    return next;</td></tr><tr><td class="line">88</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">89</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">90</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">91</td><td class="hits"></td><td class="source">  * Returns the end of the previous instance of the minute value indicated.</td></tr><tr><td class="line">92</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">93</td><td class="hits"></td><td class="source">  * @param {Date} d: The starting date</td></tr><tr><td class="line">94</td><td class="hits"></td><td class="source">  * @param {int} val: The desired value, must be within extent</td></tr><tr><td class="line">95</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">96</td><td class="hits"></td><td class="source">  prev: function(d, val) {</td></tr><tr class="hit"><td class="line">97</td><td class="hits">1971</td><td class="source">    val = val &gt; 59 ? 59 : val;</td></tr><tr><td class="line">98</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">99</td><td class="hits">1971</td><td class="source">    return later.date.prev(</td></tr><tr><td class="line">100</td><td class="hits"></td><td class="source">      later.Y.val(d),</td></tr><tr><td class="line">101</td><td class="hits"></td><td class="source">      later.M.val(d),</td></tr><tr><td class="line">102</td><td class="hits"></td><td class="source">      later.D.val(d),</td></tr><tr><td class="line">103</td><td class="hits"></td><td class="source">      later.h.val(d) + (val &gt;= later.m.val(d) ? -1 : 0),</td></tr><tr><td class="line">104</td><td class="hits"></td><td class="source">      val);</td></tr><tr><td class="line">105</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">106</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">107</td><td class="hits"></td><td class="source">};</td></tr></tbody></table></div><div class="file"><h2 id="constraint/month.js">constraint/month.js</h2><div id="stats" class="high"><div class="percentage">100%</div><div class="sloc">10</div><div class="hits">10</div><div class="misses">0</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source">* Month Constraint (M)</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source">* (c) 2013 Bill, BunKat LLC.</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source">* Definition for a month constraint type.</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">7</td><td class="hits"></td><td class="source">* Later is freely distributable under the MIT license.</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source">* For all details and documentation:</td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">*     http://github.com/bunkat/later</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source">*/</td></tr><tr class="hit"><td class="line">11</td><td class="hits">1</td><td class="source">later.month = later.M = {</td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">13</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">14</td><td class="hits"></td><td class="source">  * The name of this constraint.</td></tr><tr><td class="line">15</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">16</td><td class="hits"></td><td class="source">  name: 'month',</td></tr><tr><td class="line">17</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">18</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">19</td><td class="hits"></td><td class="source">  * The rough amount of seconds between start and end for this constraint.</td></tr><tr><td class="line">20</td><td class="hits"></td><td class="source">  * (doesn't need to be exact)</td></tr><tr><td class="line">21</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">22</td><td class="hits"></td><td class="source">  range: 2629740,</td></tr><tr><td class="line">23</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">24</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">25</td><td class="hits"></td><td class="source">  * The month value of the specified date.</td></tr><tr><td class="line">26</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">27</td><td class="hits"></td><td class="source">  * @param {Date} d: The date to calculate the value of</td></tr><tr><td class="line">28</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">29</td><td class="hits"></td><td class="source">  val: function(d) {</td></tr><tr class="hit"><td class="line">30</td><td class="hits">151949</td><td class="source">    return d.M || (d.M = later.date.getMonth.call(d)+1);</td></tr><tr><td class="line">31</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">32</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">33</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">34</td><td class="hits"></td><td class="source">  * Returns true if the val is valid for the date specified.</td></tr><tr><td class="line">35</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">36</td><td class="hits"></td><td class="source">  * @param {Date} d: The date to check the value on</td></tr><tr><td class="line">37</td><td class="hits"></td><td class="source">  * @param {Integer} val: The value to validate</td></tr><tr><td class="line">38</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">39</td><td class="hits"></td><td class="source">  isValid: function(d, val) {</td></tr><tr class="hit"><td class="line">40</td><td class="hits">1175</td><td class="source">    return later.M.val(d) === (val || 12);</td></tr><tr><td class="line">41</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">42</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">43</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">44</td><td class="hits"></td><td class="source">  * The minimum and maximum valid month values. Unlike the native date object,</td></tr><tr><td class="line">45</td><td class="hits"></td><td class="source">  * month values in later are 1 based.</td></tr><tr><td class="line">46</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">47</td><td class="hits"></td><td class="source">  extent: function() {</td></tr><tr class="hit"><td class="line">48</td><td class="hits">1591</td><td class="source">    return [1, 12];</td></tr><tr><td class="line">49</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">50</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">51</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">52</td><td class="hits"></td><td class="source">  * The start of the month of the specified date.</td></tr><tr><td class="line">53</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">54</td><td class="hits"></td><td class="source">  * @param {Date} d: The specified date</td></tr><tr><td class="line">55</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">56</td><td class="hits"></td><td class="source">  start: function(d) {</td></tr><tr class="hit"><td class="line">57</td><td class="hits">3898</td><td class="source">    return d.MStart || (d.MStart = later.date.next(later.Y.val(d), later.M.val(d)));</td></tr><tr><td class="line">58</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">59</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">60</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">61</td><td class="hits"></td><td class="source">  * The end of the month of the specified date.</td></tr><tr><td class="line">62</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">63</td><td class="hits"></td><td class="source">  * @param {Date} d: The specified date</td></tr><tr><td class="line">64</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">65</td><td class="hits"></td><td class="source">  end: function(d) {</td></tr><tr class="hit"><td class="line">66</td><td class="hits">2196</td><td class="source">    return d.MEnd || (d.MEnd = later.date.prev(later.Y.val(d), later.M.val(d)));</td></tr><tr><td class="line">67</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">68</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">69</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">70</td><td class="hits"></td><td class="source">  * Returns the start of the next instance of the month value indicated.</td></tr><tr><td class="line">71</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">72</td><td class="hits"></td><td class="source">  * @param {Date} d: The starting date</td></tr><tr><td class="line">73</td><td class="hits"></td><td class="source">  * @param {int} val: The desired value, must be within extent</td></tr><tr><td class="line">74</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">75</td><td class="hits"></td><td class="source">  next: function(d, val) {</td></tr><tr class="hit"><td class="line">76</td><td class="hits">399</td><td class="source">    val = val &gt; 12 ? 1 : val || 12;</td></tr><tr><td class="line">77</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">78</td><td class="hits">399</td><td class="source">    return later.date.next(</td></tr><tr><td class="line">79</td><td class="hits"></td><td class="source">      later.Y.val(d) + (val &gt; later.M.val(d) ? 0 : 1),</td></tr><tr><td class="line">80</td><td class="hits"></td><td class="source">      val);</td></tr><tr><td class="line">81</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">82</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">83</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">84</td><td class="hits"></td><td class="source">  * Returns the end of the previous instance of the month value indicated.</td></tr><tr><td class="line">85</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">86</td><td class="hits"></td><td class="source">  * @param {Date} d: The starting date</td></tr><tr><td class="line">87</td><td class="hits"></td><td class="source">  * @param {int} val: The desired value, must be within extent</td></tr><tr><td class="line">88</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">89</td><td class="hits"></td><td class="source">  prev: function(d, val) {</td></tr><tr class="hit"><td class="line">90</td><td class="hits">1262</td><td class="source">    val = val &gt; 12 ? 12 : val || 12;</td></tr><tr><td class="line">91</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">92</td><td class="hits">1262</td><td class="source">    return later.date.prev(</td></tr><tr><td class="line">93</td><td class="hits"></td><td class="source">      later.Y.val(d) - (val &gt;= later.M.val(d) ? 1 : 0),</td></tr><tr><td class="line">94</td><td class="hits"></td><td class="source">      val);</td></tr><tr><td class="line">95</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">96</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">97</td><td class="hits"></td><td class="source">};</td></tr></tbody></table></div><div class="file"><h2 id="constraint/second.js">constraint/second.js</h2><div id="stats" class="high"><div class="percentage">91%</div><div class="sloc">12</div><div class="hits">11</div><div class="misses">1</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source">* Second Constraint (s)</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source">* (c) 2013 Bill, BunKat LLC.</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source">* Definition for a second constraint type.</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">7</td><td class="hits"></td><td class="source">* Later is freely distributable under the MIT license.</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source">* For all details and documentation:</td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">*     http://github.com/bunkat/later</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source">*/</td></tr><tr class="hit"><td class="line">11</td><td class="hits">1</td><td class="source">later.second = later.s = {</td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">13</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">14</td><td class="hits"></td><td class="source">  * The name of this constraint.</td></tr><tr><td class="line">15</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">16</td><td class="hits"></td><td class="source">  name: 'second',</td></tr><tr><td class="line">17</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">18</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">19</td><td class="hits"></td><td class="source">  * The rough amount of seconds between start and end for this constraint.</td></tr><tr><td class="line">20</td><td class="hits"></td><td class="source">  * (doesn't need to be exact)</td></tr><tr><td class="line">21</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">22</td><td class="hits"></td><td class="source">  range: 1,</td></tr><tr><td class="line">23</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">24</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">25</td><td class="hits"></td><td class="source">  * The second value of the specified date.</td></tr><tr><td class="line">26</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">27</td><td class="hits"></td><td class="source">  * @param {Date} d: The date to calculate the value of</td></tr><tr><td class="line">28</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">29</td><td class="hits"></td><td class="source">  val: function(d) {</td></tr><tr class="hit"><td class="line">30</td><td class="hits">31987</td><td class="source">    return d.s || (d.s = later.date.getSec.call(d));</td></tr><tr><td class="line">31</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">32</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">33</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">34</td><td class="hits"></td><td class="source">  * Returns true if the val is valid for the date specified.</td></tr><tr><td class="line">35</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">36</td><td class="hits"></td><td class="source">  * @param {Date} d: The date to check the value on</td></tr><tr><td class="line">37</td><td class="hits"></td><td class="source">  * @param {Integer} val: The value to validate</td></tr><tr><td class="line">38</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">39</td><td class="hits"></td><td class="source">  isValid: function(d, val) {</td></tr><tr class="hit"><td class="line">40</td><td class="hits">5100</td><td class="source">    return later.s.val(d) === val;</td></tr><tr><td class="line">41</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">42</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">43</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">44</td><td class="hits"></td><td class="source">  * The minimum and maximum valid second values.</td></tr><tr><td class="line">45</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">46</td><td class="hits"></td><td class="source">  extent: function() {</td></tr><tr class="hit"><td class="line">47</td><td class="hits">7768</td><td class="source">    return [0, 59];</td></tr><tr><td class="line">48</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">49</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">50</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">51</td><td class="hits"></td><td class="source">  * The start of the second of the specified date.</td></tr><tr><td class="line">52</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">53</td><td class="hits"></td><td class="source">  * @param {Date} d: The specified date</td></tr><tr><td class="line">54</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">55</td><td class="hits"></td><td class="source">  start: function(d) {</td></tr><tr class="hit"><td class="line">56</td><td class="hits">3249</td><td class="source">    return d;</td></tr><tr><td class="line">57</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">58</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">59</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">60</td><td class="hits"></td><td class="source">  * The end of the second of the specified date.</td></tr><tr><td class="line">61</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">62</td><td class="hits"></td><td class="source">  * @param {Date} d: The specified date</td></tr><tr><td class="line">63</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">64</td><td class="hits"></td><td class="source">  end: function(d) {</td></tr><tr class="hit"><td class="line">65</td><td class="hits">1997</td><td class="source">    return d;</td></tr><tr><td class="line">66</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">67</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">68</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">69</td><td class="hits"></td><td class="source">  * Returns the start of the next instance of the second value indicated.</td></tr><tr><td class="line">70</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">71</td><td class="hits"></td><td class="source">  * @param {Date} d: The starting date</td></tr><tr><td class="line">72</td><td class="hits"></td><td class="source">  * @param {int} val: The desired value, must be within extent</td></tr><tr><td class="line">73</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">74</td><td class="hits"></td><td class="source">  next: function(d, val) {</td></tr><tr class="hit"><td class="line">75</td><td class="hits">2842</td><td class="source">    var s = later.s.val(d),</td></tr><tr><td class="line">76</td><td class="hits"></td><td class="source">        inc = val &gt; 59 ? 60-s : (val &lt;= s ? (60-s) + val : val-s),</td></tr><tr><td class="line">77</td><td class="hits"></td><td class="source">        next = new Date(d.getTime() + (inc * later.SEC));</td></tr><tr><td class="line">78</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">79</td><td class="hits"></td><td class="source">    // correct for passing over a daylight savings boundry</td></tr><tr class="hit"><td class="line">80</td><td class="hits">2842</td><td class="source">    if(!later.date.isUTC &amp;&amp; next.getTime() &lt;= d.getTime()) {</td></tr><tr class="miss"><td class="line">81</td><td class="hits">0</td><td class="source">      next = new Date(d.getTime() + ((inc + 7200) * later.SEC));</td></tr><tr><td class="line">82</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">83</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">84</td><td class="hits">2842</td><td class="source">    return next;</td></tr><tr><td class="line">85</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">86</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">87</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">88</td><td class="hits"></td><td class="source">  * Returns the end of the previous instance of the second value indicated.</td></tr><tr><td class="line">89</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">90</td><td class="hits"></td><td class="source">  * @param {Date} d: The starting date</td></tr><tr><td class="line">91</td><td class="hits"></td><td class="source">  * @param {int} val: The desired value, must be within extent</td></tr><tr><td class="line">92</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">93</td><td class="hits"></td><td class="source">  prev: function(d, val, cache) {</td></tr><tr class="hit"><td class="line">94</td><td class="hits">1723</td><td class="source">    val = val &gt; 59 ? 59 : val;</td></tr><tr><td class="line">95</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">96</td><td class="hits">1723</td><td class="source">    return later.date.prev(</td></tr><tr><td class="line">97</td><td class="hits"></td><td class="source">      later.Y.val(d),</td></tr><tr><td class="line">98</td><td class="hits"></td><td class="source">      later.M.val(d),</td></tr><tr><td class="line">99</td><td class="hits"></td><td class="source">      later.D.val(d),</td></tr><tr><td class="line">100</td><td class="hits"></td><td class="source">      later.h.val(d),</td></tr><tr><td class="line">101</td><td class="hits"></td><td class="source">      later.m.val(d) + (val &gt;= later.s.val(d) ? -1 : 0),</td></tr><tr><td class="line">102</td><td class="hits"></td><td class="source">      val);</td></tr><tr><td class="line">103</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">104</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">105</td><td class="hits"></td><td class="source">};</td></tr></tbody></table></div><div class="file"><h2 id="constraint/time.js">constraint/time.js</h2><div id="stats" class="high"><div class="percentage">92%</div><div class="sloc">13</div><div class="hits">12</div><div class="misses">1</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source">* Time Constraint (dy)</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source">* (c) 2013 Bill, BunKat LLC.</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source">* Definition for a time of day constraint type. Stored as number of seconds</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source">* since midnight to simplify calculations.</td></tr><tr><td class="line">7</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source">* Later is freely distributable under the MIT license.</td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">* For all details and documentation:</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source">*     http://github.com/bunkat/later</td></tr><tr><td class="line">11</td><td class="hits"></td><td class="source">*/</td></tr><tr class="hit"><td class="line">12</td><td class="hits">1</td><td class="source">later.time = later.t = {</td></tr><tr><td class="line">13</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">14</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">15</td><td class="hits"></td><td class="source">  * The name of this constraint.</td></tr><tr><td class="line">16</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">17</td><td class="hits"></td><td class="source">  name: 'time',</td></tr><tr><td class="line">18</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">19</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">20</td><td class="hits"></td><td class="source">  * The rough amount of seconds between start and end for this constraint.</td></tr><tr><td class="line">21</td><td class="hits"></td><td class="source">  * (doesn't need to be exact)</td></tr><tr><td class="line">22</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">23</td><td class="hits"></td><td class="source">  range: 1,</td></tr><tr><td class="line">24</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">25</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">26</td><td class="hits"></td><td class="source">  * The time value of the specified date.</td></tr><tr><td class="line">27</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">28</td><td class="hits"></td><td class="source">  * @param {Date} d: The date to calculate the value of</td></tr><tr><td class="line">29</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">30</td><td class="hits"></td><td class="source">  val: function(d) {</td></tr><tr class="hit"><td class="line">31</td><td class="hits">22379</td><td class="source">    return d.t || (d.t =</td></tr><tr><td class="line">32</td><td class="hits"></td><td class="source">      (later.h.val(d) * 3600) + (later.m.val(d) * 60) + (later.s.val(d)));</td></tr><tr><td class="line">33</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">34</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">35</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">36</td><td class="hits"></td><td class="source">  * Returns true if the val is valid for the date specified.</td></tr><tr><td class="line">37</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">38</td><td class="hits"></td><td class="source">  * @param {Date} d: The date to check the value on</td></tr><tr><td class="line">39</td><td class="hits"></td><td class="source">  * @param {Integer} val: The value to validate</td></tr><tr><td class="line">40</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">41</td><td class="hits"></td><td class="source">  isValid: function(d, val) {</td></tr><tr class="hit"><td class="line">42</td><td class="hits">10378</td><td class="source">    return later.t.val(d) === val;</td></tr><tr><td class="line">43</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">44</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">45</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">46</td><td class="hits"></td><td class="source">  * The minimum and maximum valid time values.</td></tr><tr><td class="line">47</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">48</td><td class="hits"></td><td class="source">  extent: function() {</td></tr><tr class="hit"><td class="line">49</td><td class="hits">15940</td><td class="source">    return [0, 86399];</td></tr><tr><td class="line">50</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">51</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">52</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">53</td><td class="hits"></td><td class="source">  * Returns the specified date.</td></tr><tr><td class="line">54</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">55</td><td class="hits"></td><td class="source">  * @param {Date} d: The specified date</td></tr><tr><td class="line">56</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">57</td><td class="hits"></td><td class="source">  start: function(d) {</td></tr><tr class="hit"><td class="line">58</td><td class="hits">5285</td><td class="source">    return d;</td></tr><tr><td class="line">59</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">60</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">61</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">62</td><td class="hits"></td><td class="source">  * Returns the specified date.</td></tr><tr><td class="line">63</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">64</td><td class="hits"></td><td class="source">  * @param {Date} d: The specified date</td></tr><tr><td class="line">65</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">66</td><td class="hits"></td><td class="source">  end: function(d) {</td></tr><tr class="hit"><td class="line">67</td><td class="hits">5116</td><td class="source">    return d;</td></tr><tr><td class="line">68</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">69</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">70</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">71</td><td class="hits"></td><td class="source">  * Returns the start of the next instance of the time value indicated.</td></tr><tr><td class="line">72</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">73</td><td class="hits"></td><td class="source">  * @param {Date} d: The starting date</td></tr><tr><td class="line">74</td><td class="hits"></td><td class="source">  * @param {int} val: The desired value, must be within extent</td></tr><tr><td class="line">75</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">76</td><td class="hits"></td><td class="source">  next: function(d, val) {</td></tr><tr class="hit"><td class="line">77</td><td class="hits">5152</td><td class="source">    val = val &gt; 86399 ? 0 : val;</td></tr><tr><td class="line">78</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">79</td><td class="hits">5152</td><td class="source">    var next = later.date.next(</td></tr><tr><td class="line">80</td><td class="hits"></td><td class="source">      later.Y.val(d),</td></tr><tr><td class="line">81</td><td class="hits"></td><td class="source">      later.M.val(d),</td></tr><tr><td class="line">82</td><td class="hits"></td><td class="source">      later.D.val(d) + (val &lt;= later.t.val(d) ? 1 : 0),</td></tr><tr><td class="line">83</td><td class="hits"></td><td class="source">      0,</td></tr><tr><td class="line">84</td><td class="hits"></td><td class="source">      0,</td></tr><tr><td class="line">85</td><td class="hits"></td><td class="source">      val);</td></tr><tr><td class="line">86</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">87</td><td class="hits"></td><td class="source">    // correct for passing over a daylight savings boundry</td></tr><tr class="hit"><td class="line">88</td><td class="hits">5152</td><td class="source">    if(!later.date.isUTC &amp;&amp; next.getTime() &lt; d.getTime()) {</td></tr><tr class="miss"><td class="line">89</td><td class="hits">0</td><td class="source">      next = later.date.next(</td></tr><tr><td class="line">90</td><td class="hits"></td><td class="source">        later.Y.val(next),</td></tr><tr><td class="line">91</td><td class="hits"></td><td class="source">        later.M.val(next),</td></tr><tr><td class="line">92</td><td class="hits"></td><td class="source">        later.D.val(next),</td></tr><tr><td class="line">93</td><td class="hits"></td><td class="source">        later.h.val(next),</td></tr><tr><td class="line">94</td><td class="hits"></td><td class="source">        later.m.val(next),</td></tr><tr><td class="line">95</td><td class="hits"></td><td class="source">        val + 7200);</td></tr><tr><td class="line">96</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">97</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">98</td><td class="hits">5152</td><td class="source">    return next;</td></tr><tr><td class="line">99</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">100</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">101</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">102</td><td class="hits"></td><td class="source">  * Returns the end of the previous instance of the time value indicated.</td></tr><tr><td class="line">103</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">104</td><td class="hits"></td><td class="source">  * @param {Date} d: The starting date</td></tr><tr><td class="line">105</td><td class="hits"></td><td class="source">  * @param {int} val: The desired value, must be within extent</td></tr><tr><td class="line">106</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">107</td><td class="hits"></td><td class="source">  prev: function(d, val) {</td></tr><tr class="hit"><td class="line">108</td><td class="hits">5004</td><td class="source">    val = val &gt; 86399 ? 86399 : val;</td></tr><tr><td class="line">109</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">110</td><td class="hits">5004</td><td class="source">    return later.date.next(</td></tr><tr><td class="line">111</td><td class="hits"></td><td class="source">      later.Y.val(d),</td></tr><tr><td class="line">112</td><td class="hits"></td><td class="source">      later.M.val(d),</td></tr><tr><td class="line">113</td><td class="hits"></td><td class="source">      later.D.val(d) + (val &gt;= later.t.val(d) ? -1 : 0),</td></tr><tr><td class="line">114</td><td class="hits"></td><td class="source">      0,</td></tr><tr><td class="line">115</td><td class="hits"></td><td class="source">      0,</td></tr><tr><td class="line">116</td><td class="hits"></td><td class="source">      val);</td></tr><tr><td class="line">117</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">118</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">119</td><td class="hits"></td><td class="source">};</td></tr></tbody></table></div><div class="file"><h2 id="constraint/weekofmonth.js">constraint/weekofmonth.js</h2><div id="stats" class="high"><div class="percentage">100%</div><div class="sloc">13</div><div class="hits">13</div><div class="misses">0</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source">* Week of Month Constraint (wy)</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source">* (c) 2013 Bill, BunKat LLC.</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source">* Definition for an week of month constraint type. Week of month treats the</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source">* first of the month as the start of week 1, with each following week starting</td></tr><tr><td class="line">7</td><td class="hits"></td><td class="source">* on Sunday.</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">* Later is freely distributable under the MIT license.</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source">* For all details and documentation:</td></tr><tr><td class="line">11</td><td class="hits"></td><td class="source">*     http://github.com/bunkat/later</td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source">*/</td></tr><tr class="hit"><td class="line">13</td><td class="hits">1</td><td class="source">later.weekOfMonth = later.wm = {</td></tr><tr><td class="line">14</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">15</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">16</td><td class="hits"></td><td class="source">  * The name of this constraint.</td></tr><tr><td class="line">17</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">18</td><td class="hits"></td><td class="source">  name: 'week of month',</td></tr><tr><td class="line">19</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">20</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">21</td><td class="hits"></td><td class="source">  * The rough amount of seconds between start and end for this constraint.</td></tr><tr><td class="line">22</td><td class="hits"></td><td class="source">  * (doesn't need to be exact)</td></tr><tr><td class="line">23</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">24</td><td class="hits"></td><td class="source">  range: 604800,</td></tr><tr><td class="line">25</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">26</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">27</td><td class="hits"></td><td class="source">  * The week of month value of the specified date.</td></tr><tr><td class="line">28</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">29</td><td class="hits"></td><td class="source">  * @param {Date} d: The date to calculate the value of</td></tr><tr><td class="line">30</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">31</td><td class="hits"></td><td class="source">  val: function(d) {</td></tr><tr class="hit"><td class="line">32</td><td class="hits">788</td><td class="source">    return d.wm || (d.wm =</td></tr><tr><td class="line">33</td><td class="hits"></td><td class="source">      (later.D.val(d) +</td></tr><tr><td class="line">34</td><td class="hits"></td><td class="source">      (later.dw.val(later.M.start(d)) - 1) + (7 - later.dw.val(d))) / 7);</td></tr><tr><td class="line">35</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">36</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">37</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">38</td><td class="hits"></td><td class="source">  * Returns true if the val is valid for the date specified.</td></tr><tr><td class="line">39</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">40</td><td class="hits"></td><td class="source">  * @param {Date} d: The date to check the value on</td></tr><tr><td class="line">41</td><td class="hits"></td><td class="source">  * @param {Integer} val: The value to validate</td></tr><tr><td class="line">42</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">43</td><td class="hits"></td><td class="source">  isValid: function(d, val) {</td></tr><tr class="hit"><td class="line">44</td><td class="hits">368</td><td class="source">    return later.wm.val(d) === (val || later.wm.extent(d)[1]);</td></tr><tr><td class="line">45</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">46</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">47</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">48</td><td class="hits"></td><td class="source">  * The minimum and maximum valid week of month values for the month indicated.</td></tr><tr><td class="line">49</td><td class="hits"></td><td class="source">  * Zero indicates the last week in the month.</td></tr><tr><td class="line">50</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">51</td><td class="hits"></td><td class="source">  * @param {Date} d: The date indicating the month to find values for</td></tr><tr><td class="line">52</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">53</td><td class="hits"></td><td class="source">  extent: function(d) {</td></tr><tr class="hit"><td class="line">54</td><td class="hits">1388</td><td class="source">    return d.wmExtent || (d.wmExtent = [1,</td></tr><tr><td class="line">55</td><td class="hits"></td><td class="source">      (later.D.extent(d)[1] + (later.dw.val(later.M.start(d)) - 1) +</td></tr><tr><td class="line">56</td><td class="hits"></td><td class="source">      (7 - later.dw.val(later.M.end(d)))) / 7]);</td></tr><tr><td class="line">57</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">58</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">59</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">60</td><td class="hits"></td><td class="source">  * The start of the week of the specified date.</td></tr><tr><td class="line">61</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">62</td><td class="hits"></td><td class="source">  * @param {Date} d: The specified date</td></tr><tr><td class="line">63</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">64</td><td class="hits"></td><td class="source">  start: function(d) {</td></tr><tr class="hit"><td class="line">65</td><td class="hits">210</td><td class="source">    return d.wmStart || (d.wmStart = later.date.next(</td></tr><tr><td class="line">66</td><td class="hits"></td><td class="source">      later.Y.val(d),</td></tr><tr><td class="line">67</td><td class="hits"></td><td class="source">      later.M.val(d),</td></tr><tr><td class="line">68</td><td class="hits"></td><td class="source">      Math.max(later.D.val(d) - later.dw.val(d) + 1, 1)));</td></tr><tr><td class="line">69</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">70</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">71</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">72</td><td class="hits"></td><td class="source">  * The end of the week of the specified date.</td></tr><tr><td class="line">73</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">74</td><td class="hits"></td><td class="source">  * @param {Date} d: The specified date</td></tr><tr><td class="line">75</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">76</td><td class="hits"></td><td class="source">  end: function(d) {</td></tr><tr class="hit"><td class="line">77</td><td class="hits">394</td><td class="source">    return d.wmEnd || (d.wmEnd = later.date.prev(</td></tr><tr><td class="line">78</td><td class="hits"></td><td class="source">      later.Y.val(d),</td></tr><tr><td class="line">79</td><td class="hits"></td><td class="source">      later.M.val(d),</td></tr><tr><td class="line">80</td><td class="hits"></td><td class="source">      Math.min(later.D.val(d) + (7 - later.dw.val(d)), later.D.extent(d)[1])));</td></tr><tr><td class="line">81</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">82</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">83</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">84</td><td class="hits"></td><td class="source">  * Returns the start of the next instance of the week value indicated. Returns</td></tr><tr><td class="line">85</td><td class="hits"></td><td class="source">  * the first day of the next month if val is greater than the number of</td></tr><tr><td class="line">86</td><td class="hits"></td><td class="source">  * days in the following month.</td></tr><tr><td class="line">87</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">88</td><td class="hits"></td><td class="source">  * @param {Date} d: The starting date</td></tr><tr><td class="line">89</td><td class="hits"></td><td class="source">  * @param {int} val: The desired value, must be within extent</td></tr><tr><td class="line">90</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">91</td><td class="hits"></td><td class="source">  next: function(d, val) {</td></tr><tr class="hit"><td class="line">92</td><td class="hits">184</td><td class="source">    val = val &gt; later.wm.extent(d)[1] ? 1 : val;</td></tr><tr><td class="line">93</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">94</td><td class="hits">184</td><td class="source">    var month = later.date.nextRollover(d, val, later.wm, later.M),</td></tr><tr><td class="line">95</td><td class="hits"></td><td class="source">        wmMax = later.wm.extent(month)[1];</td></tr><tr><td class="line">96</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">97</td><td class="hits">184</td><td class="source">    val = val &gt; wmMax ? 1 : val || wmMax;</td></tr><tr><td class="line">98</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">99</td><td class="hits"></td><td class="source">    // jump to the Sunday of the desired week, set to 1st of month for week 1</td></tr><tr class="hit"><td class="line">100</td><td class="hits">184</td><td class="source">    return later.date.next(</td></tr><tr><td class="line">101</td><td class="hits"></td><td class="source">        later.Y.val(month),</td></tr><tr><td class="line">102</td><td class="hits"></td><td class="source">        later.M.val(month),</td></tr><tr><td class="line">103</td><td class="hits"></td><td class="source">        Math.max(1, (val-1) * 7 - (later.dw.val(month)-2)));</td></tr><tr><td class="line">104</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">105</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">106</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">107</td><td class="hits"></td><td class="source">  * Returns the end of the previous instance of the week value indicated. Returns</td></tr><tr><td class="line">108</td><td class="hits"></td><td class="source">  * the last day of the previous month if val is greater than the number of</td></tr><tr><td class="line">109</td><td class="hits"></td><td class="source">  * days in the previous month.</td></tr><tr><td class="line">110</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">111</td><td class="hits"></td><td class="source">  * @param {Date} d: The starting date</td></tr><tr><td class="line">112</td><td class="hits"></td><td class="source">  * @param {int} val: The desired value, must be within extent</td></tr><tr><td class="line">113</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">114</td><td class="hits"></td><td class="source">  prev: function(d, val) {</td></tr><tr class="hit"><td class="line">115</td><td class="hits">184</td><td class="source">    var month = later.date.prevRollover(d, val, later.wm, later.M),</td></tr><tr><td class="line">116</td><td class="hits"></td><td class="source">        wmMax = later.wm.extent(month)[1];</td></tr><tr><td class="line">117</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">118</td><td class="hits">184</td><td class="source">    val = val &gt; wmMax ? wmMax : val || wmMax;</td></tr><tr><td class="line">119</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">120</td><td class="hits"></td><td class="source">    // jump to the end of Saturday of the desired week</td></tr><tr class="hit"><td class="line">121</td><td class="hits">184</td><td class="source">    return later.wm.end(later.date.next(</td></tr><tr><td class="line">122</td><td class="hits"></td><td class="source">        later.Y.val(month),</td></tr><tr><td class="line">123</td><td class="hits"></td><td class="source">        later.M.val(month),</td></tr><tr><td class="line">124</td><td class="hits"></td><td class="source">        Math.max(1, (val-1) * 7 - (later.dw.val(month)-2))));</td></tr><tr><td class="line">125</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">126</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">127</td><td class="hits"></td><td class="source">};</td></tr></tbody></table></div><div class="file"><h2 id="constraint/weekofyear.js">constraint/weekofyear.js</h2><div id="stats" class="high"><div class="percentage">100%</div><div class="sloc">23</div><div class="hits">23</div><div class="misses">0</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source">* Week of Year Constraint (wy)</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source">* (c) 2013 Bill, BunKat LLC.</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source">* Definition for an ISO 8601 week constraint type. For more information about</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source">* ISO 8601 see http://en.wikipedia.org/wiki/ISO_week_date.</td></tr><tr><td class="line">7</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source">* Later is freely distributable under the MIT license.</td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">* For all details and documentation:</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source">*     http://github.com/bunkat/later</td></tr><tr><td class="line">11</td><td class="hits"></td><td class="source">*/</td></tr><tr class="hit"><td class="line">12</td><td class="hits">1</td><td class="source">later.weekOfYear = later.wy = {</td></tr><tr><td class="line">13</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">14</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">15</td><td class="hits"></td><td class="source">  * The name of this constraint.</td></tr><tr><td class="line">16</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">17</td><td class="hits"></td><td class="source">  name: 'week of year (ISO)',</td></tr><tr><td class="line">18</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">19</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">20</td><td class="hits"></td><td class="source">  * The rough amount of seconds between start and end for this constraint.</td></tr><tr><td class="line">21</td><td class="hits"></td><td class="source">  * (doesn't need to be exact)</td></tr><tr><td class="line">22</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">23</td><td class="hits"></td><td class="source">  range: 604800,</td></tr><tr><td class="line">24</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">25</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">26</td><td class="hits"></td><td class="source">  * The ISO week year value of the specified date.</td></tr><tr><td class="line">27</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">28</td><td class="hits"></td><td class="source">  * @param {Date} d: The date to calculate the value of</td></tr><tr><td class="line">29</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">30</td><td class="hits"></td><td class="source">  val: function(d) {</td></tr><tr class="hit"><td class="line">31</td><td class="hits">8999</td><td class="source">    if (d.wy) return d.wy;</td></tr><tr><td class="line">32</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">33</td><td class="hits"></td><td class="source">    // move to the Thursday in the target week and find Thurs of target year</td></tr><tr class="hit"><td class="line">34</td><td class="hits">8669</td><td class="source">    var wThur = later.dw.next(later.wy.start(d), 5),</td></tr><tr><td class="line">35</td><td class="hits"></td><td class="source">        YThur = later.dw.next(later.Y.prev(wThur, later.Y.val(wThur)-1), 5);</td></tr><tr><td class="line">36</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">37</td><td class="hits"></td><td class="source">    // caculate the difference between the two dates in weeks</td></tr><tr class="hit"><td class="line">38</td><td class="hits">8669</td><td class="source">    return (d.wy = 1 + Math.ceil((wThur.getTime() - YThur.getTime()) / later.WEEK));</td></tr><tr><td class="line">39</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">40</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">41</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">42</td><td class="hits"></td><td class="source">  * Returns true if the val is valid for the date specified.</td></tr><tr><td class="line">43</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">44</td><td class="hits"></td><td class="source">  * @param {Date} d: The date to check the value on</td></tr><tr><td class="line">45</td><td class="hits"></td><td class="source">  * @param {Integer} val: The value to validate</td></tr><tr><td class="line">46</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">47</td><td class="hits"></td><td class="source">  isValid: function(d, val) {</td></tr><tr class="hit"><td class="line">48</td><td class="hits">2955</td><td class="source">    return later.wy.val(d) === (val || later.wy.extent(d)[1]);</td></tr><tr><td class="line">49</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">50</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">51</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">52</td><td class="hits"></td><td class="source">  * The minimum and maximum valid ISO week values for the year indicated.</td></tr><tr><td class="line">53</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">54</td><td class="hits"></td><td class="source">  * @param {Date} d: The date indicating the year to find ISO values for</td></tr><tr><td class="line">55</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">56</td><td class="hits"></td><td class="source">  extent: function(d) {</td></tr><tr class="hit"><td class="line">57</td><td class="hits">12401</td><td class="source">    if (d.wyExtent) return d.wyExtent;</td></tr><tr><td class="line">58</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">59</td><td class="hits"></td><td class="source">    // go to start of ISO week to get to the right year</td></tr><tr class="hit"><td class="line">60</td><td class="hits">7953</td><td class="source">    var year = later.dw.next(later.wy.start(d), 5),</td></tr><tr><td class="line">61</td><td class="hits"></td><td class="source">        dwFirst = later.dw.val(later.Y.start(year)),</td></tr><tr><td class="line">62</td><td class="hits"></td><td class="source">        dwLast = later.dw.val(later.Y.end(year));</td></tr><tr><td class="line">63</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">64</td><td class="hits">7953</td><td class="source">    return (d.wyExtent = [1, dwFirst === 5 || dwLast === 5 ? 53 : 52]);</td></tr><tr><td class="line">65</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">66</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">67</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">68</td><td class="hits"></td><td class="source">  * The start of the ISO week of the specified date.</td></tr><tr><td class="line">69</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">70</td><td class="hits"></td><td class="source">  * @param {Date} d: The specified date</td></tr><tr><td class="line">71</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">72</td><td class="hits"></td><td class="source">  start: function(d) {</td></tr><tr class="hit"><td class="line">73</td><td class="hits">22324</td><td class="source">    return d.wyStart || (d.wyStart = later.date.next(</td></tr><tr><td class="line">74</td><td class="hits"></td><td class="source">      later.Y.val(d),</td></tr><tr><td class="line">75</td><td class="hits"></td><td class="source">      later.M.val(d),</td></tr><tr><td class="line">76</td><td class="hits"></td><td class="source">      // jump to the Monday of the current week</td></tr><tr><td class="line">77</td><td class="hits"></td><td class="source">      later.D.val(d) - (later.dw.val(d) &gt; 1 ? later.dw.val(d) - 2 : 6)</td></tr><tr><td class="line">78</td><td class="hits"></td><td class="source">    ));</td></tr><tr><td class="line">79</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">80</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">81</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">82</td><td class="hits"></td><td class="source">  * The end of the ISO week of the specified date.</td></tr><tr><td class="line">83</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">84</td><td class="hits"></td><td class="source">  * @param {Date} d: The specified date</td></tr><tr><td class="line">85</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">86</td><td class="hits"></td><td class="source">  end: function(d) {</td></tr><tr class="hit"><td class="line">87</td><td class="hits">4274</td><td class="source">    return d.wyEnd || (d.wyEnd = later.date.prev(</td></tr><tr><td class="line">88</td><td class="hits"></td><td class="source">      later.Y.val(d),</td></tr><tr><td class="line">89</td><td class="hits"></td><td class="source">      later.M.val(d),</td></tr><tr><td class="line">90</td><td class="hits"></td><td class="source">      // jump to the Saturday of the current week</td></tr><tr><td class="line">91</td><td class="hits"></td><td class="source">      later.D.val(d) + (later.dw.val(d) &gt; 1 ? 8 - later.dw.val(d) : 0)</td></tr><tr><td class="line">92</td><td class="hits"></td><td class="source">    ));</td></tr><tr><td class="line">93</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">94</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">95</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">96</td><td class="hits"></td><td class="source">  * Returns the start of the next instance of the ISO week value indicated.</td></tr><tr><td class="line">97</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">98</td><td class="hits"></td><td class="source">  * @param {Date} d: The starting date</td></tr><tr><td class="line">99</td><td class="hits"></td><td class="source">  * @param {int} val: The desired value, must be within extent</td></tr><tr><td class="line">100</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">101</td><td class="hits"></td><td class="source">  next: function(d, val) {</td></tr><tr class="hit"><td class="line">102</td><td class="hits">1424</td><td class="source">    val = val &gt; later.wy.extent(d)[1] ? 1 : val;</td></tr><tr><td class="line">103</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">104</td><td class="hits">1424</td><td class="source">    var wyThur = later.dw.next(later.wy.start(d), 5),</td></tr><tr><td class="line">105</td><td class="hits"></td><td class="source">        year = later.date.nextRollover(wyThur, val, later.wy, later.Y);</td></tr><tr><td class="line">106</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">107</td><td class="hits"></td><td class="source">    // handle case where 1st of year is last week of previous month</td></tr><tr class="hit"><td class="line">108</td><td class="hits">1424</td><td class="source">    if(later.wy.val(year) !== 1) {</td></tr><tr class="hit"><td class="line">109</td><td class="hits">726</td><td class="source">      year = later.dw.next(year, 2);</td></tr><tr><td class="line">110</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">111</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">112</td><td class="hits">1424</td><td class="source">    var wyMax = later.wy.extent(year)[1],</td></tr><tr><td class="line">113</td><td class="hits"></td><td class="source">        wyStart = later.wy.start(year);</td></tr><tr><td class="line">114</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">115</td><td class="hits">1424</td><td class="source">    val = val &gt; wyMax ? 1 : val || wyMax;</td></tr><tr><td class="line">116</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">117</td><td class="hits">1424</td><td class="source">    return later.date.next(</td></tr><tr><td class="line">118</td><td class="hits"></td><td class="source">        later.Y.val(wyStart),</td></tr><tr><td class="line">119</td><td class="hits"></td><td class="source">        later.M.val(wyStart),</td></tr><tr><td class="line">120</td><td class="hits"></td><td class="source">        later.D.val(wyStart) + 7 * (val-1)</td></tr><tr><td class="line">121</td><td class="hits"></td><td class="source">      );</td></tr><tr><td class="line">122</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">123</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">124</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">125</td><td class="hits"></td><td class="source">  * Returns the end of the previous instance of the ISO week value indicated.</td></tr><tr><td class="line">126</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">127</td><td class="hits"></td><td class="source">  * @param {Date} d: The starting date</td></tr><tr><td class="line">128</td><td class="hits"></td><td class="source">  * @param {int} val: The desired value, must be within extent</td></tr><tr><td class="line">129</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">130</td><td class="hits"></td><td class="source">  prev: function(d, val) {</td></tr><tr class="hit"><td class="line">131</td><td class="hits">1420</td><td class="source">    var wyThur = later.dw.next(later.wy.start(d), 5),</td></tr><tr><td class="line">132</td><td class="hits"></td><td class="source">        year = later.date.prevRollover(wyThur, val, later.wy, later.Y);</td></tr><tr><td class="line">133</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">134</td><td class="hits"></td><td class="source">    // handle case where 1st of year is last week of previous month</td></tr><tr class="hit"><td class="line">135</td><td class="hits">1420</td><td class="source">    if(later.wy.val(year) !== 1) {</td></tr><tr class="hit"><td class="line">136</td><td class="hits">787</td><td class="source">      year = later.dw.next(year, 2);</td></tr><tr><td class="line">137</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">138</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">139</td><td class="hits">1420</td><td class="source">    var wyMax = later.wy.extent(year)[1],</td></tr><tr><td class="line">140</td><td class="hits"></td><td class="source">        wyEnd = later.wy.end(year);</td></tr><tr><td class="line">141</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">142</td><td class="hits">1420</td><td class="source">    val = val &gt; wyMax ? wyMax : val || wyMax;</td></tr><tr><td class="line">143</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">144</td><td class="hits">1420</td><td class="source">    return later.wy.end(later.date.next(</td></tr><tr><td class="line">145</td><td class="hits"></td><td class="source">        later.Y.val(wyEnd),</td></tr><tr><td class="line">146</td><td class="hits"></td><td class="source">        later.M.val(wyEnd),</td></tr><tr><td class="line">147</td><td class="hits"></td><td class="source">        later.D.val(wyEnd) + 7 * (val-1)</td></tr><tr><td class="line">148</td><td class="hits"></td><td class="source">      ));</td></tr><tr><td class="line">149</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">150</td><td class="hits"></td><td class="source">};</td></tr></tbody></table></div><div class="file"><h2 id="constraint/year.js">constraint/year.js</h2><div id="stats" class="high"><div class="percentage">100%</div><div class="sloc">8</div><div class="hits">8</div><div class="misses">0</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source">* Year Constraint (Y)</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source">* (c) 2013 Bill, BunKat LLC.</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source">* Definition for a year constraint type.</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">7</td><td class="hits"></td><td class="source">* Later is freely distributable under the MIT license.</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source">* For all details and documentation:</td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">*     http://github.com/bunkat/later</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source">*/</td></tr><tr class="hit"><td class="line">11</td><td class="hits">1</td><td class="source">later.year = later.Y = {</td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">13</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">14</td><td class="hits"></td><td class="source">  * The name of this constraint.</td></tr><tr><td class="line">15</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">16</td><td class="hits"></td><td class="source">  name: 'year',</td></tr><tr><td class="line">17</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">18</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">19</td><td class="hits"></td><td class="source">  * The rough amount of seconds between start and end for this constraint.</td></tr><tr><td class="line">20</td><td class="hits"></td><td class="source">  * (doesn't need to be exact)</td></tr><tr><td class="line">21</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">22</td><td class="hits"></td><td class="source">  range: 31556900,</td></tr><tr><td class="line">23</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">24</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">25</td><td class="hits"></td><td class="source">  * The year value of the specified date.</td></tr><tr><td class="line">26</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">27</td><td class="hits"></td><td class="source">  * @param {Date} d: The date to calculate the value of</td></tr><tr><td class="line">28</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">29</td><td class="hits"></td><td class="source">  val: function(d) {</td></tr><tr class="hit"><td class="line">30</td><td class="hits">230114</td><td class="source">    return d.Y || (d.Y = later.date.getYear.call(d));</td></tr><tr><td class="line">31</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">32</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">33</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">34</td><td class="hits"></td><td class="source">  * Returns true if the val is valid for the date specified.</td></tr><tr><td class="line">35</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">36</td><td class="hits"></td><td class="source">  * @param {Date} d: The date to check the value on</td></tr><tr><td class="line">37</td><td class="hits"></td><td class="source">  * @param {Integer} val: The value to validate</td></tr><tr><td class="line">38</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">39</td><td class="hits"></td><td class="source">  isValid: function(d, val) {</td></tr><tr class="hit"><td class="line">40</td><td class="hits">3551</td><td class="source">    return later.Y.val(d) === val;</td></tr><tr><td class="line">41</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">42</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">43</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">44</td><td class="hits"></td><td class="source">  * The minimum and maximum valid values for the year constraint.</td></tr><tr><td class="line">45</td><td class="hits"></td><td class="source">  * If max is past 2099, later.D.extent must be fixed to calculate leap years</td></tr><tr><td class="line">46</td><td class="hits"></td><td class="source">  * correctly.</td></tr><tr><td class="line">47</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">48</td><td class="hits"></td><td class="source">  extent: function() {</td></tr><tr class="hit"><td class="line">49</td><td class="hits">29309</td><td class="source">    return [1970, 2099];</td></tr><tr><td class="line">50</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">51</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">52</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">53</td><td class="hits"></td><td class="source">  * The start of the year of the specified date.</td></tr><tr><td class="line">54</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">55</td><td class="hits"></td><td class="source">  * @param {Date} d: The specified date</td></tr><tr><td class="line">56</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">57</td><td class="hits"></td><td class="source">  start: function(d) {</td></tr><tr class="hit"><td class="line">58</td><td class="hits">34142</td><td class="source">    return d.YStart || (d.YStart = later.date.next(later.Y.val(d)));</td></tr><tr><td class="line">59</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">60</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">61</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">62</td><td class="hits"></td><td class="source">  * The end of the year of the specified date.</td></tr><tr><td class="line">63</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">64</td><td class="hits"></td><td class="source">  * @param {Date} d: The specified date</td></tr><tr><td class="line">65</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">66</td><td class="hits"></td><td class="source">  end: function(d) {</td></tr><tr class="hit"><td class="line">67</td><td class="hits">12002</td><td class="source">    return d.YEnd || (d.YEnd = later.date.prev(later.Y.val(d)));</td></tr><tr><td class="line">68</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">69</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">70</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">71</td><td class="hits"></td><td class="source">  * Returns the start of the next instance of the year value indicated.</td></tr><tr><td class="line">72</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">73</td><td class="hits"></td><td class="source">  * @param {Date} d: The starting date</td></tr><tr><td class="line">74</td><td class="hits"></td><td class="source">  * @param {int} val: The desired value, must be within extent</td></tr><tr><td class="line">75</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">76</td><td class="hits"></td><td class="source">  next: function(d, val) {</td></tr><tr class="hit"><td class="line">77</td><td class="hits">3430</td><td class="source">    return val &gt; later.Y.val(d) &amp;&amp; val &lt;= later.Y.extent()[1] ?</td></tr><tr><td class="line">78</td><td class="hits"></td><td class="source">      later.date.next(val) : later.NEVER;</td></tr><tr><td class="line">79</td><td class="hits"></td><td class="source">  },</td></tr><tr><td class="line">80</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">81</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">82</td><td class="hits"></td><td class="source">  * Returns the end of the previous instance of the year value indicated.</td></tr><tr><td class="line">83</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">84</td><td class="hits"></td><td class="source">  * @param {Date} d: The starting date</td></tr><tr><td class="line">85</td><td class="hits"></td><td class="source">  * @param {int} val: The desired value, must be within extent</td></tr><tr><td class="line">86</td><td class="hits"></td><td class="source">  */</td></tr><tr><td class="line">87</td><td class="hits"></td><td class="source">  prev: function(d, val) {</td></tr><tr class="hit"><td class="line">88</td><td class="hits">15471</td><td class="source">    return val &lt; later.Y.val(d) &amp;&amp; val &gt;= later.Y.extent()[0] ?</td></tr><tr><td class="line">89</td><td class="hits"></td><td class="source">      later.date.prev(val) : later.NEVER;</td></tr><tr><td class="line">90</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">91</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">92</td><td class="hits"></td><td class="source">};</td></tr></tbody></table></div><div class="file"><h2 id="core/compile.js">core/compile.js</h2><div id="stats" class="high"><div class="percentage">100%</div><div class="sloc">36</div><div class="hits">36</div><div class="misses">0</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source">* Compile</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source">* (c) 2013 Bill, BunKat LLC.</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source">* Compiles a single schedule definition into a form from which instances can be</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source">* efficiently calculated from.</td></tr><tr><td class="line">7</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source">* Later is freely distributable under the MIT license.</td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">* For all details and documentation:</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source">*     http://github.com/bunkat/later</td></tr><tr><td class="line">11</td><td class="hits"></td><td class="source">*/</td></tr><tr class="hit"><td class="line">12</td><td class="hits">1</td><td class="source">later.compile = function(schedDef) {</td></tr><tr><td class="line">13</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">14</td><td class="hits">696</td><td class="source">  var constraints = [],</td></tr><tr><td class="line">15</td><td class="hits"></td><td class="source">      constraintsLen = 0,</td></tr><tr><td class="line">16</td><td class="hits"></td><td class="source">      tickConstraint;</td></tr><tr><td class="line">17</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">18</td><td class="hits">696</td><td class="source">  for(var key in schedDef) {</td></tr><tr class="hit"><td class="line">19</td><td class="hits">1498</td><td class="source">    var nameParts = key.split('_'),</td></tr><tr><td class="line">20</td><td class="hits"></td><td class="source">        name = nameParts[0],</td></tr><tr><td class="line">21</td><td class="hits"></td><td class="source">        mod = nameParts[1],</td></tr><tr><td class="line">22</td><td class="hits"></td><td class="source">        vals = schedDef[key],</td></tr><tr><td class="line">23</td><td class="hits"></td><td class="source">        constraint = mod ? later.modifier[mod](later[name], vals) : later[name];</td></tr><tr><td class="line">24</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">25</td><td class="hits">1498</td><td class="source">    constraints.push({constraint: constraint, vals: vals});</td></tr><tr class="hit"><td class="line">26</td><td class="hits">1498</td><td class="source">    constraintsLen++;</td></tr><tr><td class="line">27</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">28</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">29</td><td class="hits"></td><td class="source">  // sort constraints based on their range for best performance (we want to</td></tr><tr><td class="line">30</td><td class="hits"></td><td class="source">  // always skip the largest block of time possible to find the next valid</td></tr><tr><td class="line">31</td><td class="hits"></td><td class="source">  // value)</td></tr><tr class="hit"><td class="line">32</td><td class="hits">696</td><td class="source">  constraints.sort(function(a,b) {</td></tr><tr class="hit"><td class="line">33</td><td class="hits">1232</td><td class="source">    return a.constraint.range &lt; b.constraint.range;</td></tr><tr><td class="line">34</td><td class="hits"></td><td class="source">  });</td></tr><tr><td class="line">35</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">36</td><td class="hits"></td><td class="source">  // this is the smallest constraint, we use this one to tick the schedule when</td></tr><tr><td class="line">37</td><td class="hits"></td><td class="source">  // finding multiple instances</td></tr><tr class="hit"><td class="line">38</td><td class="hits">696</td><td class="source">  tickConstraint = constraints[constraintsLen-1].constraint;</td></tr><tr><td class="line">39</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">40</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">41</td><td class="hits"></td><td class="source">  * Returns a function to use when comparing two dates. Encapsulates the</td></tr><tr><td class="line">42</td><td class="hits"></td><td class="source">  * difference between searching for instances forward and backwards so that</td></tr><tr><td class="line">43</td><td class="hits"></td><td class="source">  * the same code can be completely reused for both directions.</td></tr><tr><td class="line">44</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">45</td><td class="hits"></td><td class="source">  * @param {String} dir: The direction to use, either 'next' or 'prev'</td></tr><tr><td class="line">46</td><td class="hits"></td><td class="source">  */</td></tr><tr class="hit"><td class="line">47</td><td class="hits">696</td><td class="source">  function compareFn(dir) {</td></tr><tr class="hit"><td class="line">48</td><td class="hits">1338</td><td class="source">    return dir === 'next' ?</td></tr><tr class="hit"><td class="line">49</td><td class="hits">43</td><td class="source">      function(a,b) { return a.getTime() &gt; b.getTime(); } :</td></tr><tr class="hit"><td class="line">50</td><td class="hits">41</td><td class="source">      function(a,b) { return b.getTime() &gt; a.getTime(); };</td></tr><tr><td class="line">51</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">52</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">53</td><td class="hits">696</td><td class="source">  return {</td></tr><tr><td class="line">54</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">55</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">56</td><td class="hits"></td><td class="source">    * Calculates the start of the next valid occurrence of a particular schedule</td></tr><tr><td class="line">57</td><td class="hits"></td><td class="source">    * that occurs on or after the specified start time.</td></tr><tr><td class="line">58</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">59</td><td class="hits"></td><td class="source">    * @param {String} dir: Direction to search in ('next' or 'prev')</td></tr><tr><td class="line">60</td><td class="hits"></td><td class="source">    * @param {Date} startDate: The first possible valid occurrence</td></tr><tr><td class="line">61</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">62</td><td class="hits"></td><td class="source">    start: function(dir, startDate) {</td></tr><tr class="hit"><td class="line">63</td><td class="hits">3887</td><td class="source">      var next = startDate,</td></tr><tr><td class="line">64</td><td class="hits"></td><td class="source">          nextVal = later.array[dir],</td></tr><tr><td class="line">65</td><td class="hits"></td><td class="source">          maxAttempts = 1000,</td></tr><tr><td class="line">66</td><td class="hits"></td><td class="source">          done;</td></tr><tr><td class="line">67</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">68</td><td class="hits">3887</td><td class="source">      while(maxAttempts-- &amp;&amp; !done &amp;&amp; next) {</td></tr><tr class="hit"><td class="line">69</td><td class="hits">7310</td><td class="source">        done = true;</td></tr><tr><td class="line">70</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">71</td><td class="hits"></td><td class="source">        // verify all of the constraints in order since we want to make the</td></tr><tr><td class="line">72</td><td class="hits"></td><td class="source">        // largest jumps possible to find the first valid value</td></tr><tr class="hit"><td class="line">73</td><td class="hits">7310</td><td class="source">        for(var i = 0; i &lt; constraintsLen; i++) {</td></tr><tr><td class="line">74</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">75</td><td class="hits">13372</td><td class="source">          var constraint = constraints[i].constraint,</td></tr><tr><td class="line">76</td><td class="hits"></td><td class="source">              curVal = constraint.val(next),</td></tr><tr><td class="line">77</td><td class="hits"></td><td class="source">              extent = constraint.extent(next),</td></tr><tr><td class="line">78</td><td class="hits"></td><td class="source">              newVal = nextVal(curVal, constraints[i].vals, extent);</td></tr><tr><td class="line">79</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">80</td><td class="hits">13372</td><td class="source">          if(!constraint.isValid(next, newVal)) {</td></tr><tr class="hit"><td class="line">81</td><td class="hits">3446</td><td class="source">            next = constraint[dir](next, newVal);</td></tr><tr class="hit"><td class="line">82</td><td class="hits">3446</td><td class="source">            done = false;</td></tr><tr class="hit"><td class="line">83</td><td class="hits">3446</td><td class="source">            break; // need to retest all constraints with new date</td></tr><tr><td class="line">84</td><td class="hits"></td><td class="source">          }</td></tr><tr><td class="line">85</td><td class="hits"></td><td class="source">        }</td></tr><tr><td class="line">86</td><td class="hits"></td><td class="source">      }</td></tr><tr><td class="line">87</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">88</td><td class="hits">3887</td><td class="source">      if(next !== later.NEVER) {</td></tr><tr class="hit"><td class="line">89</td><td class="hits">3864</td><td class="source">        next = dir === 'next' ? tickConstraint.start(next) :</td></tr><tr><td class="line">90</td><td class="hits"></td><td class="source">          tickConstraint.end(next);</td></tr><tr><td class="line">91</td><td class="hits"></td><td class="source">      }</td></tr><tr><td class="line">92</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">93</td><td class="hits"></td><td class="source">      // if next, move to start of time period. needed when moving backwards</td></tr><tr class="hit"><td class="line">94</td><td class="hits">3887</td><td class="source">      return next;</td></tr><tr><td class="line">95</td><td class="hits"></td><td class="source">    },</td></tr><tr><td class="line">96</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">97</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">98</td><td class="hits"></td><td class="source">    * Given a valid start time, finds the next schedule that is invalid.</td></tr><tr><td class="line">99</td><td class="hits"></td><td class="source">    * Useful for finding the end of a valid time range.</td></tr><tr><td class="line">100</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">101</td><td class="hits"></td><td class="source">    * @param {Date} startDate: The first possible valid occurrence</td></tr><tr><td class="line">102</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">103</td><td class="hits"></td><td class="source">    end: function(dir, startDate) {</td></tr><tr><td class="line">104</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">105</td><td class="hits">1338</td><td class="source">      var result,</td></tr><tr><td class="line">106</td><td class="hits"></td><td class="source">          nextVal = later.array[dir + 'Invalid'],</td></tr><tr><td class="line">107</td><td class="hits"></td><td class="source">          compare = compareFn(dir);</td></tr><tr><td class="line">108</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">109</td><td class="hits">1338</td><td class="source">      for(var i = constraintsLen-1; i &gt;= 0; i--) {</td></tr><tr class="hit"><td class="line">110</td><td class="hits">1431</td><td class="source">        var constraint = constraints[i].constraint,</td></tr><tr><td class="line">111</td><td class="hits"></td><td class="source">            curVal = constraint.val(startDate),</td></tr><tr><td class="line">112</td><td class="hits"></td><td class="source">            extent = constraint.extent(startDate),</td></tr><tr><td class="line">113</td><td class="hits"></td><td class="source">            newVal = nextVal(curVal, constraints[i].vals, extent),</td></tr><tr><td class="line">114</td><td class="hits"></td><td class="source">            next;</td></tr><tr><td class="line">115</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">116</td><td class="hits">1431</td><td class="source">        if(newVal !== undefined) { // constraint has invalid value, use that</td></tr><tr class="hit"><td class="line">117</td><td class="hits">1425</td><td class="source">          next = constraint[dir](startDate, newVal);</td></tr><tr class="hit"><td class="line">118</td><td class="hits">1425</td><td class="source">          if(next &amp;&amp; (!result || compare(result, next))) {</td></tr><tr class="hit"><td class="line">119</td><td class="hits">1365</td><td class="source">            result = next;</td></tr><tr><td class="line">120</td><td class="hits"></td><td class="source">          }</td></tr><tr><td class="line">121</td><td class="hits"></td><td class="source">        }</td></tr><tr><td class="line">122</td><td class="hits"></td><td class="source">      }</td></tr><tr><td class="line">123</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">124</td><td class="hits">1338</td><td class="source">      return result;</td></tr><tr><td class="line">125</td><td class="hits"></td><td class="source">    },</td></tr><tr><td class="line">126</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">127</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">128</td><td class="hits"></td><td class="source">    * Ticks the date by the minimum constraint in this schedule</td></tr><tr><td class="line">129</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">130</td><td class="hits"></td><td class="source">    * @param {String} dir: Direction to tick in ('next' or 'prev')</td></tr><tr><td class="line">131</td><td class="hits"></td><td class="source">    * @param {Date} date: The start date to tick from</td></tr><tr><td class="line">132</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">133</td><td class="hits"></td><td class="source">    tick: function(dir, date) {</td></tr><tr class="hit"><td class="line">134</td><td class="hits">900</td><td class="source">      return new Date(dir === 'next' ?</td></tr><tr><td class="line">135</td><td class="hits"></td><td class="source">        tickConstraint.end(date).getTime() + later.SEC :</td></tr><tr><td class="line">136</td><td class="hits"></td><td class="source">        tickConstraint.start(date).getTime() - later.SEC);</td></tr><tr><td class="line">137</td><td class="hits"></td><td class="source">    },</td></tr><tr><td class="line">138</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">139</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">140</td><td class="hits"></td><td class="source">    * Ticks the date to the start of the minimum constraint</td></tr><tr><td class="line">141</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">142</td><td class="hits"></td><td class="source">    * @param {Date} date: The start date to tick from</td></tr><tr><td class="line">143</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">144</td><td class="hits"></td><td class="source">    tickStart: function(date) {</td></tr><tr class="hit"><td class="line">145</td><td class="hits">281</td><td class="source">      return tickConstraint.start(date);</td></tr><tr><td class="line">146</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">147</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">148</td><td class="hits"></td><td class="source">  };</td></tr><tr><td class="line">149</td><td class="hits"></td><td class="source">};</td></tr></tbody></table></div><div class="file"><h2 id="core/schedule.js">core/schedule.js</h2><div id="stats" class="high"><div class="percentage">100%</div><div class="sloc">109</div><div class="hits">109</div><div class="misses">0</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source">* Schedule</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source">* (c) 2013 Bill, BunKat LLC.</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source">* Returns an object to calculate future or previous occurrences of the</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source">* specified schedule.</td></tr><tr><td class="line">7</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source">* Later is freely distributable under the MIT license.</td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">* For all details and documentation:</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source">*     http://github.com/bunkat/later</td></tr><tr><td class="line">11</td><td class="hits"></td><td class="source">*/</td></tr><tr class="hit"><td class="line">12</td><td class="hits">1</td><td class="source">later.schedule = function(sched) {</td></tr><tr class="hit"><td class="line">13</td><td class="hits">490</td><td class="source">  if(!sched) throw new Error('Missing schedule definition.');</td></tr><tr class="hit"><td class="line">14</td><td class="hits">490</td><td class="source">  if(!sched.schedules) throw new Error('Definition must include at least one schedule.');</td></tr><tr><td class="line">15</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">16</td><td class="hits"></td><td class="source">  // compile the schedule components</td></tr><tr class="hit"><td class="line">17</td><td class="hits">490</td><td class="source">  var schedules = [],</td></tr><tr><td class="line">18</td><td class="hits"></td><td class="source">      schedulesLen = sched.schedules.length,</td></tr><tr><td class="line">19</td><td class="hits"></td><td class="source">      exceptions = [],</td></tr><tr><td class="line">20</td><td class="hits"></td><td class="source">      exceptionsLen = sched.exceptions ? sched.exceptions.length : 0;</td></tr><tr><td class="line">21</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">22</td><td class="hits">490</td><td class="source">  for(var i = 0; i &lt; schedulesLen; i++) {</td></tr><tr class="hit"><td class="line">23</td><td class="hits">581</td><td class="source">    schedules.push(later.compile(sched.schedules[i]));</td></tr><tr><td class="line">24</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">25</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">26</td><td class="hits">490</td><td class="source">  for(var j = 0; j &lt; exceptionsLen; j++) {</td></tr><tr class="hit"><td class="line">27</td><td class="hits">101</td><td class="source">    exceptions.push(later.compile(sched.exceptions[j]));</td></tr><tr><td class="line">28</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">29</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">30</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">31</td><td class="hits"></td><td class="source">  * Calculates count number of instances or ranges for the current schedule,</td></tr><tr><td class="line">32</td><td class="hits"></td><td class="source">  * optionally between the specified startDate and endDate.</td></tr><tr><td class="line">33</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">34</td><td class="hits"></td><td class="source">  * @param {String} dir: The direction to use, either 'next' or 'prev'</td></tr><tr><td class="line">35</td><td class="hits"></td><td class="source">  * @param {Integer} count: The number of instances or ranges to return</td></tr><tr><td class="line">36</td><td class="hits"></td><td class="source">  * @param {Date} startDate: The earliest date a valid instance can occur on</td></tr><tr><td class="line">37</td><td class="hits"></td><td class="source">  * @param {Date} endDate: The latest date a valid instance can occur on</td></tr><tr><td class="line">38</td><td class="hits"></td><td class="source">  * @param {Bool} isRange: True to return ranges, false to return instances</td></tr><tr><td class="line">39</td><td class="hits"></td><td class="source">  */</td></tr><tr class="hit"><td class="line">40</td><td class="hits">490</td><td class="source">  function getInstances(dir, count, startDate, endDate, isRange) {</td></tr><tr class="hit"><td class="line">41</td><td class="hits">490</td><td class="source">    var compare = compareFn(dir), // encapsulates difference between directions</td></tr><tr><td class="line">42</td><td class="hits"></td><td class="source">        loopCount = count,</td></tr><tr><td class="line">43</td><td class="hits"></td><td class="source">        maxAttempts = 1000,</td></tr><tr><td class="line">44</td><td class="hits"></td><td class="source">        schedStarts = [], exceptStarts = [],</td></tr><tr><td class="line">45</td><td class="hits"></td><td class="source">        next, end, results = [];</td></tr><tr><td class="line">46</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">47</td><td class="hits">490</td><td class="source">    startDate = startDate ? new Date(startDate) : new Date();</td></tr><tr class="hit"><td class="line">48</td><td class="hits">490</td><td class="source">    if(!startDate || !startDate.getTime()) throw new Error('Invalid start date.');</td></tr><tr><td class="line">49</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">50</td><td class="hits"></td><td class="source">    // Step 1: calculate the earliest start dates for each schedule and exception</td></tr><tr class="hit"><td class="line">51</td><td class="hits">490</td><td class="source">    setNextStarts(dir, schedules, schedStarts, startDate);</td></tr><tr class="hit"><td class="line">52</td><td class="hits">490</td><td class="source">    setRangeStarts(dir, exceptions, exceptStarts, startDate);</td></tr><tr><td class="line">53</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">54</td><td class="hits"></td><td class="source">    // Step 2: select the earliest of the start dates calculated</td></tr><tr class="hit"><td class="line">55</td><td class="hits">490</td><td class="source">    while(maxAttempts-- &amp;&amp; loopCount &amp;&amp; (next = findNext(schedStarts, compare))) {</td></tr><tr><td class="line">56</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">57</td><td class="hits"></td><td class="source">      // Step 3: make sure the start date we found is in range</td></tr><tr class="hit"><td class="line">58</td><td class="hits">2077</td><td class="source">      if(endDate &amp;&amp; compare(next, endDate)) {</td></tr><tr class="hit"><td class="line">59</td><td class="hits">36</td><td class="source">        break;</td></tr><tr><td class="line">60</td><td class="hits"></td><td class="source">      }</td></tr><tr><td class="line">61</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">62</td><td class="hits"></td><td class="source">      // Step 4: make sure we aren't in the middle of an exception range</td></tr><tr class="hit"><td class="line">63</td><td class="hits">2041</td><td class="source">      if(exceptionsLen) {</td></tr><tr class="hit"><td class="line">64</td><td class="hits">1157</td><td class="source">        updateRangeStarts(dir, exceptions, exceptStarts, next);</td></tr><tr class="hit"><td class="line">65</td><td class="hits">1157</td><td class="source">        if((end = calcRangeOverlap(dir, exceptStarts, next))) {</td></tr><tr class="hit"><td class="line">66</td><td class="hits">1062</td><td class="source">          updateNextStarts(dir, schedules, schedStarts, end);</td></tr><tr class="hit"><td class="line">67</td><td class="hits">1062</td><td class="source">          continue;</td></tr><tr><td class="line">68</td><td class="hits"></td><td class="source">        }</td></tr><tr><td class="line">69</td><td class="hits"></td><td class="source">      }</td></tr><tr><td class="line">70</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">71</td><td class="hits"></td><td class="source">      // Step 5: Date is good, if range, find the end of the range and update start dates</td></tr><tr class="hit"><td class="line">72</td><td class="hits">979</td><td class="source">      if(isRange) {</td></tr><tr class="hit"><td class="line">73</td><td class="hits">87</td><td class="source">        var maxEndDate = calcMaxEndDate(exceptStarts, compare);</td></tr><tr class="hit"><td class="line">74</td><td class="hits">87</td><td class="source">        end = calcEnd(dir, schedules, schedStarts, next, maxEndDate);</td></tr><tr class="hit"><td class="line">75</td><td class="hits">87</td><td class="source">        results.push( dir === 'next' ?</td></tr><tr><td class="line">76</td><td class="hits"></td><td class="source">          [</td></tr><tr><td class="line">77</td><td class="hits"></td><td class="source">            new Date(Math.max(startDate, next)),</td></tr><tr><td class="line">78</td><td class="hits"></td><td class="source">            new Date(endDate ? Math.min(end, endDate) : end)</td></tr><tr><td class="line">79</td><td class="hits"></td><td class="source">          ] :</td></tr><tr><td class="line">80</td><td class="hits"></td><td class="source">          [</td></tr><tr><td class="line">81</td><td class="hits"></td><td class="source">            new Date(endDate ? Math.max(endDate, end.getTime()+later.SEC) : end.getTime()+later.SEC),</td></tr><tr><td class="line">82</td><td class="hits"></td><td class="source">            new Date(Math.min(startDate, next.getTime()+later.SEC))</td></tr><tr><td class="line">83</td><td class="hits"></td><td class="source">          ]</td></tr><tr><td class="line">84</td><td class="hits"></td><td class="source">        );</td></tr><tr><td class="line">85</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">86</td><td class="hits">87</td><td class="source">        updateNextStarts(dir, schedules, schedStarts, end);</td></tr><tr><td class="line">87</td><td class="hits"></td><td class="source">      }</td></tr><tr><td class="line">88</td><td class="hits"></td><td class="source">      // otherwise store the start date and tick the start dates</td></tr><tr><td class="line">89</td><td class="hits"></td><td class="source">      else {</td></tr><tr class="hit"><td class="line">90</td><td class="hits">892</td><td class="source">        results.push( dir === 'next' ?</td></tr><tr><td class="line">91</td><td class="hits"></td><td class="source">          new Date(Math.max(startDate, next)) :</td></tr><tr><td class="line">92</td><td class="hits"></td><td class="source">          getStart(schedules, schedStarts, next, endDate)</td></tr><tr><td class="line">93</td><td class="hits"></td><td class="source">        );</td></tr><tr><td class="line">94</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">95</td><td class="hits">892</td><td class="source">        tickStarts(dir, schedules, schedStarts, next);</td></tr><tr><td class="line">96</td><td class="hits"></td><td class="source">      }</td></tr><tr><td class="line">97</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">98</td><td class="hits">979</td><td class="source">      loopCount--;</td></tr><tr><td class="line">99</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">100</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">101</td><td class="hits">490</td><td class="source">    return results.length === 0 ? later.NEVER : count === 1 ? results[0] : results;</td></tr><tr><td class="line">102</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">103</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">104</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">105</td><td class="hits"></td><td class="source">  * Initially sets the first valid next start times</td></tr><tr><td class="line">106</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">107</td><td class="hits"></td><td class="source">  * @param {String} dir: The direction to use, either 'next' or 'prev'</td></tr><tr><td class="line">108</td><td class="hits"></td><td class="source">  * @param {Array} schedArr: The set of compiled schedules to use</td></tr><tr><td class="line">109</td><td class="hits"></td><td class="source">  * @param {Array} startsArr: The set of cached start dates for the schedules</td></tr><tr><td class="line">110</td><td class="hits"></td><td class="source">  * @param {Date} startDate: Starts earlier than this date will be calculated</td></tr><tr><td class="line">111</td><td class="hits"></td><td class="source">  */</td></tr><tr class="hit"><td class="line">112</td><td class="hits">490</td><td class="source">  function setNextStarts(dir, schedArr, startsArr, startDate) {</td></tr><tr class="hit"><td class="line">113</td><td class="hits">490</td><td class="source">    for(var i = 0, len = schedArr.length; i &lt; len; i++) {</td></tr><tr class="hit"><td class="line">114</td><td class="hits">581</td><td class="source">      startsArr[i] = schedArr[i].start(dir, startDate);</td></tr><tr><td class="line">115</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">116</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">117</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">118</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">119</td><td class="hits"></td><td class="source">  * Updates the set of cached start dates to the next valid start dates. Only</td></tr><tr><td class="line">120</td><td class="hits"></td><td class="source">  * schedules where the current start date is less than or equal to the</td></tr><tr><td class="line">121</td><td class="hits"></td><td class="source">  * specified startDate need to be updated.</td></tr><tr><td class="line">122</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">123</td><td class="hits"></td><td class="source">  * @param {String} dir: The direction to use, either 'next' or 'prev'</td></tr><tr><td class="line">124</td><td class="hits"></td><td class="source">  * @param {Array} schedArr: The set of compiled schedules to use</td></tr><tr><td class="line">125</td><td class="hits"></td><td class="source">  * @param {Array} startsArr: The set of cached start dates for the schedules</td></tr><tr><td class="line">126</td><td class="hits"></td><td class="source">  * @param {Date} startDate: Starts earlier than this date will be calculated</td></tr><tr><td class="line">127</td><td class="hits"></td><td class="source">  */</td></tr><tr class="hit"><td class="line">128</td><td class="hits">490</td><td class="source">  function updateNextStarts(dir, schedArr, startsArr, startDate) {</td></tr><tr class="hit"><td class="line">129</td><td class="hits">1149</td><td class="source">    var compare = compareFn(dir);</td></tr><tr><td class="line">130</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">131</td><td class="hits">1149</td><td class="source">    for(var i = 0, len = schedArr.length; i &lt; len; i++) {</td></tr><tr class="hit"><td class="line">132</td><td class="hits">1293</td><td class="source">      if(startsArr[i] &amp;&amp; !compare(startsArr[i], startDate)) {</td></tr><tr class="hit"><td class="line">133</td><td class="hits">1149</td><td class="source">        startsArr[i] = schedArr[i].start(dir, startDate);</td></tr><tr><td class="line">134</td><td class="hits"></td><td class="source">      }</td></tr><tr><td class="line">135</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">136</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">137</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">138</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">139</td><td class="hits"></td><td class="source">  * Updates the set of cached ranges to the next valid ranges. Only</td></tr><tr><td class="line">140</td><td class="hits"></td><td class="source">  * schedules where the current start date is less than or equal to the</td></tr><tr><td class="line">141</td><td class="hits"></td><td class="source">  * specified startDate need to be updated.</td></tr><tr><td class="line">142</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">143</td><td class="hits"></td><td class="source">  * @param {String} dir: The direction to use, either 'next' or 'prev'</td></tr><tr><td class="line">144</td><td class="hits"></td><td class="source">  * @param {Array} schedArr: The set of compiled schedules to use</td></tr><tr><td class="line">145</td><td class="hits"></td><td class="source">  * @param {Array} startsArr: The set of cached start dates for the schedules</td></tr><tr><td class="line">146</td><td class="hits"></td><td class="source">  * @param {Date} startDate: Starts earlier than this date will be calculated</td></tr><tr><td class="line">147</td><td class="hits"></td><td class="source">  */</td></tr><tr class="hit"><td class="line">148</td><td class="hits">490</td><td class="source">  function setRangeStarts(dir, schedArr, rangesArr, startDate) {</td></tr><tr class="hit"><td class="line">149</td><td class="hits">490</td><td class="source">    var compare = compareFn(dir);</td></tr><tr><td class="line">150</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">151</td><td class="hits">490</td><td class="source">    for(var i = 0, len = schedArr.length; i &lt; len; i++) {</td></tr><tr class="hit"><td class="line">152</td><td class="hits">101</td><td class="source">      var nextStart = schedArr[i].start(dir, startDate);</td></tr><tr><td class="line">153</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">154</td><td class="hits">101</td><td class="source">      if(!nextStart) {</td></tr><tr class="hit"><td class="line">155</td><td class="hits">1</td><td class="source">        rangesArr[i] = later.NEVER;</td></tr><tr><td class="line">156</td><td class="hits"></td><td class="source">      }</td></tr><tr><td class="line">157</td><td class="hits"></td><td class="source">      else {</td></tr><tr class="hit"><td class="line">158</td><td class="hits">100</td><td class="source">        rangesArr[i] = [nextStart, schedArr[i].end(dir, nextStart)];</td></tr><tr><td class="line">159</td><td class="hits"></td><td class="source">      }</td></tr><tr><td class="line">160</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">161</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">162</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">163</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">164</td><td class="hits"></td><td class="source">  * Updates the set of cached ranges to the next valid ranges. Only</td></tr><tr><td class="line">165</td><td class="hits"></td><td class="source">  * schedules where the current start date is less than or equal to the</td></tr><tr><td class="line">166</td><td class="hits"></td><td class="source">  * specified startDate need to be updated.</td></tr><tr><td class="line">167</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">168</td><td class="hits"></td><td class="source">  * @param {String} dir: The direction to use, either 'next' or 'prev'</td></tr><tr><td class="line">169</td><td class="hits"></td><td class="source">  * @param {Array} schedArr: The set of compiled schedules to use</td></tr><tr><td class="line">170</td><td class="hits"></td><td class="source">  * @param {Array} startsArr: The set of cached start dates for the schedules</td></tr><tr><td class="line">171</td><td class="hits"></td><td class="source">  * @param {Date} startDate: Starts earlier than this date will be calculated</td></tr><tr><td class="line">172</td><td class="hits"></td><td class="source">  */</td></tr><tr class="hit"><td class="line">173</td><td class="hits">490</td><td class="source">  function updateRangeStarts(dir, schedArr, rangesArr, startDate) {</td></tr><tr class="hit"><td class="line">174</td><td class="hits">1157</td><td class="source">    var compare = compareFn(dir);</td></tr><tr><td class="line">175</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">176</td><td class="hits">1157</td><td class="source">    for(var i = 0, len = schedArr.length; i &lt; len; i++) {</td></tr><tr class="hit"><td class="line">177</td><td class="hits">1277</td><td class="source">      if(rangesArr[i] &amp;&amp; !compare(rangesArr[i][0], startDate)) {</td></tr><tr class="hit"><td class="line">178</td><td class="hits">1150</td><td class="source">        var nextStart = schedArr[i].start(dir, startDate);</td></tr><tr><td class="line">179</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">180</td><td class="hits">1150</td><td class="source">        if(!nextStart) {</td></tr><tr class="hit"><td class="line">181</td><td class="hits">3</td><td class="source">          rangesArr[i] = later.NEVER;</td></tr><tr><td class="line">182</td><td class="hits"></td><td class="source">        }</td></tr><tr><td class="line">183</td><td class="hits"></td><td class="source">        else {</td></tr><tr class="hit"><td class="line">184</td><td class="hits">1147</td><td class="source">          rangesArr[i] = [nextStart, schedArr[i].end(dir, nextStart)];</td></tr><tr><td class="line">185</td><td class="hits"></td><td class="source">        }</td></tr><tr><td class="line">186</td><td class="hits"></td><td class="source">      }</td></tr><tr><td class="line">187</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">188</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">189</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">190</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">191</td><td class="hits"></td><td class="source">  * Increments all schedules with next start equal to startDate by one tick.</td></tr><tr><td class="line">192</td><td class="hits"></td><td class="source">  * Tick size is determined by the smallest constraint within a schedule.</td></tr><tr><td class="line">193</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">194</td><td class="hits"></td><td class="source">  * @param {String} dir: The direction to use, either 'next' or 'prev'</td></tr><tr><td class="line">195</td><td class="hits"></td><td class="source">  * @param {Array} schedArr: The set of compiled schedules to use</td></tr><tr><td class="line">196</td><td class="hits"></td><td class="source">  * @param {Array} startsArr: The set of cached start dates for the schedules</td></tr><tr><td class="line">197</td><td class="hits"></td><td class="source">  * @param {Date} startDate: The date that should cause a schedule to tick</td></tr><tr><td class="line">198</td><td class="hits"></td><td class="source">  */</td></tr><tr class="hit"><td class="line">199</td><td class="hits">490</td><td class="source">  function tickStarts(dir, schedArr, startsArr, startDate) {</td></tr><tr class="hit"><td class="line">200</td><td class="hits">892</td><td class="source">    for(var i = 0, len = schedArr.length; i &lt; len; i++) {</td></tr><tr class="hit"><td class="line">201</td><td class="hits">989</td><td class="source">      if(startsArr[i] &amp;&amp; startsArr[i].getTime() === startDate.getTime()) {</td></tr><tr class="hit"><td class="line">202</td><td class="hits">892</td><td class="source">        startsArr[i] = schedArr[i].start(dir, schedArr[i].tick(dir, startDate));</td></tr><tr><td class="line">203</td><td class="hits"></td><td class="source">      }</td></tr><tr><td class="line">204</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">205</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">206</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">207</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">208</td><td class="hits"></td><td class="source">  * Determines the start date of the schedule that produced startDate</td></tr><tr><td class="line">209</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">210</td><td class="hits"></td><td class="source">  * @param {Array} schedArr: The set of compiled schedules to use</td></tr><tr><td class="line">211</td><td class="hits"></td><td class="source">  * @param {Array} startsArr: The set of cached start dates for the schedules</td></tr><tr><td class="line">212</td><td class="hits"></td><td class="source">  * @param {Date} startDate: The date that should cause a schedule to tick</td></tr><tr><td class="line">213</td><td class="hits"></td><td class="source">  * @param {Date} minEndDate: The minimum end date to return</td></tr><tr><td class="line">214</td><td class="hits"></td><td class="source">  */</td></tr><tr class="hit"><td class="line">215</td><td class="hits">490</td><td class="source">  function getStart(schedArr, startsArr, startDate, minEndDate) {</td></tr><tr class="hit"><td class="line">216</td><td class="hits">281</td><td class="source">    var result;</td></tr><tr><td class="line">217</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">218</td><td class="hits">281</td><td class="source">    for(var i = 0, len = startsArr.length; i &lt; len; i++) {</td></tr><tr class="hit"><td class="line">219</td><td class="hits">300</td><td class="source">      if(startsArr[i] &amp;&amp; startsArr[i].getTime() === startDate.getTime()) {</td></tr><tr class="hit"><td class="line">220</td><td class="hits">281</td><td class="source">        var start = schedArr[i].tickStart(startDate);</td></tr><tr><td class="line">221</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">222</td><td class="hits">281</td><td class="source">        if(minEndDate &amp;&amp; (start &lt; minEndDate)) {</td></tr><tr class="hit"><td class="line">223</td><td class="hits">3</td><td class="source">          return minEndDate;</td></tr><tr><td class="line">224</td><td class="hits"></td><td class="source">        }</td></tr><tr><td class="line">225</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">226</td><td class="hits">278</td><td class="source">        if(!result || (start &gt; result)) {</td></tr><tr class="hit"><td class="line">227</td><td class="hits">278</td><td class="source">          result = start;</td></tr><tr><td class="line">228</td><td class="hits"></td><td class="source">        }</td></tr><tr><td class="line">229</td><td class="hits"></td><td class="source">      }</td></tr><tr><td class="line">230</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">231</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">232</td><td class="hits">278</td><td class="source">    return result;</td></tr><tr><td class="line">233</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">234</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">235</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">236</td><td class="hits"></td><td class="source">  * Calculates the end of the overlap between any exception schedule and the</td></tr><tr><td class="line">237</td><td class="hits"></td><td class="source">  * specified start date. Returns undefined if there is no overlap.</td></tr><tr><td class="line">238</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">239</td><td class="hits"></td><td class="source">  * @param {String} dir: The direction to use, either 'next' or 'prev'</td></tr><tr><td class="line">240</td><td class="hits"></td><td class="source">  * @param {Array} schedArr: The set of compiled schedules to use</td></tr><tr><td class="line">241</td><td class="hits"></td><td class="source">  * @param {Array} rangesArr: The set of cached start dates for the schedules</td></tr><tr><td class="line">242</td><td class="hits"></td><td class="source">  * @param {Date} startDate: The valid date for which the overlap will be found</td></tr><tr><td class="line">243</td><td class="hits"></td><td class="source">  */</td></tr><tr class="hit"><td class="line">244</td><td class="hits">490</td><td class="source">  function calcRangeOverlap(dir, rangesArr, startDate) {</td></tr><tr class="hit"><td class="line">245</td><td class="hits">1157</td><td class="source">    var compare = compareFn(dir), result;</td></tr><tr><td class="line">246</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">247</td><td class="hits">1157</td><td class="source">    for(var i = 0, len = rangesArr.length; i &lt; len; i++) {</td></tr><tr class="hit"><td class="line">248</td><td class="hits">1277</td><td class="source">      var range = rangesArr[i];</td></tr><tr><td class="line">249</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">250</td><td class="hits">1277</td><td class="source">      if(range &amp;&amp; !compare(range[0], startDate) &amp;&amp;</td></tr><tr><td class="line">251</td><td class="hits"></td><td class="source">        (!range[1] || compare(range[1], startDate))) {</td></tr><tr><td class="line">252</td><td class="hits"></td><td class="source">        // startDate is in the middle of an exception range</td></tr><tr class="hit"><td class="line">253</td><td class="hits">1070</td><td class="source">        if(!result || compare(range[1], result)) {</td></tr><tr class="hit"><td class="line">254</td><td class="hits">1062</td><td class="source">          result = range[1];</td></tr><tr><td class="line">255</td><td class="hits"></td><td class="source">        }</td></tr><tr><td class="line">256</td><td class="hits"></td><td class="source">      }</td></tr><tr><td class="line">257</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">258</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">259</td><td class="hits">1157</td><td class="source">    return result;</td></tr><tr><td class="line">260</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">261</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">262</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">263</td><td class="hits"></td><td class="source">  * Calculates the earliest start of an exception schedule, this is the maximum</td></tr><tr><td class="line">264</td><td class="hits"></td><td class="source">  * end date of the schedule.</td></tr><tr><td class="line">265</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">266</td><td class="hits"></td><td class="source">  * @param {Array} exceptsArr: The set of cached exception ranges</td></tr><tr><td class="line">267</td><td class="hits"></td><td class="source">  * @param {Array} compare: The compare function to use to determine earliest</td></tr><tr><td class="line">268</td><td class="hits"></td><td class="source">  */</td></tr><tr class="hit"><td class="line">269</td><td class="hits">490</td><td class="source">  function calcMaxEndDate(exceptsArr, compare) {</td></tr><tr class="hit"><td class="line">270</td><td class="hits">87</td><td class="source">    var result;</td></tr><tr><td class="line">271</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">272</td><td class="hits">87</td><td class="source">    for(var i = 0, len = exceptsArr.length; i &lt; len; i++) {</td></tr><tr class="hit"><td class="line">273</td><td class="hits">81</td><td class="source">      if(exceptsArr[i] &amp;&amp; (!result || compare(result, exceptsArr[i][0]))) {</td></tr><tr class="hit"><td class="line">274</td><td class="hits">55</td><td class="source">        result = exceptsArr[i][0];</td></tr><tr><td class="line">275</td><td class="hits"></td><td class="source">      }</td></tr><tr><td class="line">276</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">277</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">278</td><td class="hits">87</td><td class="source">    return result;</td></tr><tr><td class="line">279</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">280</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">281</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">282</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">283</td><td class="hits"></td><td class="source">  * Calculates the next invalid date for a particular schedules starting from</td></tr><tr><td class="line">284</td><td class="hits"></td><td class="source">  * the specified valid start date.</td></tr><tr><td class="line">285</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">286</td><td class="hits"></td><td class="source">  * @param {String} dir: The direction to use, either 'next' or 'prev'</td></tr><tr><td class="line">287</td><td class="hits"></td><td class="source">  * @param {Array} schedArr: The set of compiled schedules to use</td></tr><tr><td class="line">288</td><td class="hits"></td><td class="source">  * @param {Array} startsArr: The set of cached start dates for the schedules</td></tr><tr><td class="line">289</td><td class="hits"></td><td class="source">  * @param {Date} startDate: The valid date for which the end date will be found</td></tr><tr><td class="line">290</td><td class="hits"></td><td class="source">  * @param {Date} maxEndDate: The latested possible end date or null for none</td></tr><tr><td class="line">291</td><td class="hits"></td><td class="source">  */</td></tr><tr class="hit"><td class="line">292</td><td class="hits">490</td><td class="source">  function calcEnd(dir, schedArr, startsArr, startDate, maxEndDate) {</td></tr><tr class="hit"><td class="line">293</td><td class="hits">87</td><td class="source">    var compare = compareFn(dir), result;</td></tr><tr><td class="line">294</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">295</td><td class="hits">87</td><td class="source">    for(var i = 0, len = schedArr.length; i &lt; len; i++) {</td></tr><tr class="hit"><td class="line">296</td><td class="hits">111</td><td class="source">      var start = startsArr[i];</td></tr><tr><td class="line">297</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">298</td><td class="hits">111</td><td class="source">      if(start &amp;&amp; start.getTime() === startDate.getTime()) {</td></tr><tr class="hit"><td class="line">299</td><td class="hits">87</td><td class="source">        var end = schedArr[i].end(dir, start);</td></tr><tr><td class="line">300</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">301</td><td class="hits"></td><td class="source">        // if the end date is past the maxEndDate, just return the maxEndDate</td></tr><tr class="hit"><td class="line">302</td><td class="hits">87</td><td class="source">        if(maxEndDate &amp;&amp; compare(end, maxEndDate)) {</td></tr><tr class="hit"><td class="line">303</td><td class="hits">30</td><td class="source">          return maxEndDate;</td></tr><tr><td class="line">304</td><td class="hits"></td><td class="source">        }</td></tr><tr><td class="line">305</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">306</td><td class="hits"></td><td class="source">        // otherwise, return the maximum end date that was calculated</td></tr><tr class="hit"><td class="line">307</td><td class="hits">57</td><td class="source">        if(!result || compare(end, result)) {</td></tr><tr class="hit"><td class="line">308</td><td class="hits">57</td><td class="source">          result = end;</td></tr><tr><td class="line">309</td><td class="hits"></td><td class="source">        }</td></tr><tr><td class="line">310</td><td class="hits"></td><td class="source">      }</td></tr><tr><td class="line">311</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">312</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">313</td><td class="hits">57</td><td class="source">    return result;</td></tr><tr><td class="line">314</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">315</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">316</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">317</td><td class="hits"></td><td class="source">  * Returns a function to use when comparing two dates. Encapsulates the</td></tr><tr><td class="line">318</td><td class="hits"></td><td class="source">  * difference between searching for instances forward and backwards so that</td></tr><tr><td class="line">319</td><td class="hits"></td><td class="source">  * the same code can be completely reused for both directions.</td></tr><tr><td class="line">320</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">321</td><td class="hits"></td><td class="source">  * @param {String} dir: The direction to use, either 'next' or 'prev'</td></tr><tr><td class="line">322</td><td class="hits"></td><td class="source">  */</td></tr><tr class="hit"><td class="line">323</td><td class="hits">490</td><td class="source">  function compareFn(dir) {</td></tr><tr class="hit"><td class="line">324</td><td class="hits">4530</td><td class="source">    return dir === 'next' ?</td></tr><tr class="hit"><td class="line">325</td><td class="hits">6409</td><td class="source">      function(a,b) { return a.getTime() &gt; b.getTime(); } :</td></tr><tr class="hit"><td class="line">326</td><td class="hits">892</td><td class="source">      function(a,b) { return b.getTime() &gt; a.getTime(); };</td></tr><tr><td class="line">327</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">328</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">329</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">330</td><td class="hits"></td><td class="source">  * Returns the next value in an array using the function passed in as compare</td></tr><tr><td class="line">331</td><td class="hits"></td><td class="source">  * to do the comparison. Skips over null or undefined values.</td></tr><tr><td class="line">332</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">333</td><td class="hits"></td><td class="source">  * @param {Array} arr: The array of values</td></tr><tr><td class="line">334</td><td class="hits"></td><td class="source">  * @param {Function} compare: The comparison function to use</td></tr><tr><td class="line">335</td><td class="hits"></td><td class="source">  */</td></tr><tr class="hit"><td class="line">336</td><td class="hits">490</td><td class="source">  function findNext(arr, compare) {</td></tr><tr class="hit"><td class="line">337</td><td class="hits">2083</td><td class="source">    var next = arr[0];</td></tr><tr><td class="line">338</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">339</td><td class="hits">2083</td><td class="source">    for(var i = 1, len = arr.length; i &lt; len; i++) {</td></tr><tr class="hit"><td class="line">340</td><td class="hits">261</td><td class="source">      if(arr[i] &amp;&amp; compare(next, arr[i])) {</td></tr><tr class="hit"><td class="line">341</td><td class="hits">38</td><td class="source">        next = arr[i];</td></tr><tr><td class="line">342</td><td class="hits"></td><td class="source">      }</td></tr><tr><td class="line">343</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">344</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">345</td><td class="hits">2083</td><td class="source">    return next;</td></tr><tr><td class="line">346</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">347</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">348</td><td class="hits">490</td><td class="source">  return {</td></tr><tr><td class="line">349</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">350</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">351</td><td class="hits"></td><td class="source">    * Returns true if d is a valid occurrence of the current schedule.</td></tr><tr><td class="line">352</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">353</td><td class="hits"></td><td class="source">    * @param {Date} d: The date to check</td></tr><tr><td class="line">354</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">355</td><td class="hits"></td><td class="source">    isValid: function(d) {</td></tr><tr class="hit"><td class="line">356</td><td class="hits">356</td><td class="source">      return getInstances('next', 1, d, d) !== later.NEVER;</td></tr><tr><td class="line">357</td><td class="hits"></td><td class="source">    },</td></tr><tr><td class="line">358</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">359</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">360</td><td class="hits"></td><td class="source">    * Finds the next valid instance or instances of the current schedule,</td></tr><tr><td class="line">361</td><td class="hits"></td><td class="source">    * optionally between a specified start and end date. Start date is</td></tr><tr><td class="line">362</td><td class="hits"></td><td class="source">    * Date.now() by default, end date is unspecified. Start date must be</td></tr><tr><td class="line">363</td><td class="hits"></td><td class="source">    * smaller than end date.</td></tr><tr><td class="line">364</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">365</td><td class="hits"></td><td class="source">    * @param {Integer} count: The number of instances to return</td></tr><tr><td class="line">366</td><td class="hits"></td><td class="source">    * @param {Date} startDate: The earliest a valid instance can occur</td></tr><tr><td class="line">367</td><td class="hits"></td><td class="source">    * @param {Date} endDate: The latest a valid instance can occur</td></tr><tr><td class="line">368</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">369</td><td class="hits"></td><td class="source">    next: function(count, startDate, endDate) {</td></tr><tr class="hit"><td class="line">370</td><td class="hits">63</td><td class="source">      return getInstances('next', count || 1, startDate, endDate);</td></tr><tr><td class="line">371</td><td class="hits"></td><td class="source">    },</td></tr><tr><td class="line">372</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">373</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">374</td><td class="hits"></td><td class="source">    * Finds the previous valid instance or instances of the current schedule,</td></tr><tr><td class="line">375</td><td class="hits"></td><td class="source">    * optionally between a specified start and end date. Start date is</td></tr><tr><td class="line">376</td><td class="hits"></td><td class="source">    * Date.now() by default, end date is unspecified. Start date must be</td></tr><tr><td class="line">377</td><td class="hits"></td><td class="source">    * greater than end date.</td></tr><tr><td class="line">378</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">379</td><td class="hits"></td><td class="source">    * @param {Integer} count: The number of instances to return</td></tr><tr><td class="line">380</td><td class="hits"></td><td class="source">    * @param {Date} startDate: The earliest a valid instance can occur</td></tr><tr><td class="line">381</td><td class="hits"></td><td class="source">    * @param {Date} endDate: The latest a valid instance can occur</td></tr><tr><td class="line">382</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">383</td><td class="hits"></td><td class="source">    prev: function(count, startDate, endDate) {</td></tr><tr class="hit"><td class="line">384</td><td class="hits">55</td><td class="source">      return getInstances('prev', count || 1, startDate, endDate);</td></tr><tr><td class="line">385</td><td class="hits"></td><td class="source">    },</td></tr><tr><td class="line">386</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">387</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">388</td><td class="hits"></td><td class="source">    * Finds the next valid range or ranges of the current schedule,</td></tr><tr><td class="line">389</td><td class="hits"></td><td class="source">    * optionally between a specified start and end date. Start date is</td></tr><tr><td class="line">390</td><td class="hits"></td><td class="source">    * Date.now() by default, end date is unspecified. Start date must be</td></tr><tr><td class="line">391</td><td class="hits"></td><td class="source">    * greater than end date.</td></tr><tr><td class="line">392</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">393</td><td class="hits"></td><td class="source">    * @param {Integer} count: The number of ranges to return</td></tr><tr><td class="line">394</td><td class="hits"></td><td class="source">    * @param {Date} startDate: The earliest a valid range can occur</td></tr><tr><td class="line">395</td><td class="hits"></td><td class="source">    * @param {Date} endDate: The latest a valid range can occur</td></tr><tr><td class="line">396</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">397</td><td class="hits"></td><td class="source">    nextRange: function(count, startDate, endDate) {</td></tr><tr class="hit"><td class="line">398</td><td class="hits">9</td><td class="source">      return getInstances('next', count || 1, startDate, endDate, true);</td></tr><tr><td class="line">399</td><td class="hits"></td><td class="source">    },</td></tr><tr><td class="line">400</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">401</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">402</td><td class="hits"></td><td class="source">    * Finds the previous valid range or ranges of the current schedule,</td></tr><tr><td class="line">403</td><td class="hits"></td><td class="source">    * optionally between a specified start and end date. Start date is</td></tr><tr><td class="line">404</td><td class="hits"></td><td class="source">    * Date.now() by default, end date is unspecified. Start date must be</td></tr><tr><td class="line">405</td><td class="hits"></td><td class="source">    * greater than end date.</td></tr><tr><td class="line">406</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">407</td><td class="hits"></td><td class="source">    * @param {Integer} count: The number of ranges to return</td></tr><tr><td class="line">408</td><td class="hits"></td><td class="source">    * @param {Date} startDate: The earliest a valid range can occur</td></tr><tr><td class="line">409</td><td class="hits"></td><td class="source">    * @param {Date} endDate: The latest a valid range can occur</td></tr><tr><td class="line">410</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">411</td><td class="hits"></td><td class="source">    prevRange: function(count, startDate, endDate) {</td></tr><tr class="hit"><td class="line">412</td><td class="hits">7</td><td class="source">      return getInstances('prev', count || 1, startDate, endDate, true);</td></tr><tr><td class="line">413</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">414</td><td class="hits"></td><td class="source">  };</td></tr><tr><td class="line">415</td><td class="hits"></td><td class="source">};</td></tr></tbody></table></div><div class="file"><h2 id="core/setinterval.js">core/setinterval.js</h2><div id="stats" class="high"><div class="percentage">100%</div><div class="sloc">9</div><div class="hits">9</div><div class="misses">0</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source">* Set Interval</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source">* (c) 2013 Bill, BunKat LLC.</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source">* Works similar to setInterval() but allows you to specify a Later schedule</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source">* instead of milliseconds.</td></tr><tr><td class="line">7</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source">* Later is freely distributable under the MIT license.</td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">* For all details and documentation:</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source">*     http://github.com/bunkat/later</td></tr><tr><td class="line">11</td><td class="hits"></td><td class="source">*/</td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">13</td><td class="hits">1</td><td class="source">later.setInterval = function(fn, sched) {</td></tr><tr><td class="line">14</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">15</td><td class="hits">2</td><td class="source">  var t = later.setTimeout(scheduleTimeout, sched),</td></tr><tr><td class="line">16</td><td class="hits"></td><td class="source">      done = false;</td></tr><tr><td class="line">17</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">18</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">19</td><td class="hits"></td><td class="source">  * Executes the specified function and then sets the timeout for the next</td></tr><tr><td class="line">20</td><td class="hits"></td><td class="source">  * interval.</td></tr><tr><td class="line">21</td><td class="hits"></td><td class="source">  */</td></tr><tr class="hit"><td class="line">22</td><td class="hits">2</td><td class="source">  function scheduleTimeout() {</td></tr><tr class="hit"><td class="line">23</td><td class="hits">4</td><td class="source">    if(!done) {</td></tr><tr class="hit"><td class="line">24</td><td class="hits">3</td><td class="source">      fn();</td></tr><tr class="hit"><td class="line">25</td><td class="hits">3</td><td class="source">      t = later.setTimeout(scheduleTimeout, sched);</td></tr><tr><td class="line">26</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">27</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">28</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">29</td><td class="hits">2</td><td class="source">  return {</td></tr><tr><td class="line">30</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">31</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">32</td><td class="hits"></td><td class="source">    * Clears the timeout.</td></tr><tr><td class="line">33</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">34</td><td class="hits"></td><td class="source">    clear: function() {</td></tr><tr class="hit"><td class="line">35</td><td class="hits">2</td><td class="source">      done = true;</td></tr><tr class="hit"><td class="line">36</td><td class="hits">2</td><td class="source">      t.clear();</td></tr><tr><td class="line">37</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">38</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">39</td><td class="hits"></td><td class="source">  };</td></tr><tr><td class="line">40</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">41</td><td class="hits"></td><td class="source">};</td></tr></tbody></table></div><div class="file"><h2 id="core/settimeout.js">core/settimeout.js</h2><div id="stats" class="high"><div class="percentage">100%</div><div class="sloc">12</div><div class="hits">12</div><div class="misses">0</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source">* Set Timeout</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source">* (c) 2013 Bill, BunKat LLC.</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source">* Works similar to setTimeout() but allows you to specify a Later schedule</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source">* instead of milliseconds.</td></tr><tr><td class="line">7</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source">* Later is freely distributable under the MIT license.</td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">* For all details and documentation:</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source">*     http://github.com/bunkat/later</td></tr><tr><td class="line">11</td><td class="hits"></td><td class="source">*/</td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">13</td><td class="hits">1</td><td class="source">later.setTimeout = function(fn, sched) {</td></tr><tr><td class="line">14</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">15</td><td class="hits">8</td><td class="source">  var s = later.schedule(sched), t;</td></tr><tr class="hit"><td class="line">16</td><td class="hits">8</td><td class="source">  scheduleTimeout();</td></tr><tr><td class="line">17</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">18</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">19</td><td class="hits"></td><td class="source">  * Schedules the timeout to occur. If the next occurrence is greater than the</td></tr><tr><td class="line">20</td><td class="hits"></td><td class="source">  * max supported delay (2147483647 ms) than we delay for that amount before</td></tr><tr><td class="line">21</td><td class="hits"></td><td class="source">  * attempting to schedule the timeout again.</td></tr><tr><td class="line">22</td><td class="hits"></td><td class="source">  */</td></tr><tr class="hit"><td class="line">23</td><td class="hits">8</td><td class="source">  function scheduleTimeout() {</td></tr><tr class="hit"><td class="line">24</td><td class="hits">8</td><td class="source">    var now = Date.now(),</td></tr><tr><td class="line">25</td><td class="hits"></td><td class="source">        next = s.next(2, now),</td></tr><tr><td class="line">26</td><td class="hits"></td><td class="source">        diff = next[0].getTime() - now;</td></tr><tr><td class="line">27</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">28</td><td class="hits"></td><td class="source">    // minimum time to fire is one second, use next occurrence instead</td></tr><tr class="hit"><td class="line">29</td><td class="hits">8</td><td class="source">    if(diff &lt; 1000) {</td></tr><tr class="hit"><td class="line">30</td><td class="hits">6</td><td class="source">      diff = next[1].getTime() - now;</td></tr><tr><td class="line">31</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">32</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">33</td><td class="hits">8</td><td class="source">    if(diff &lt; 2147483647) {</td></tr><tr class="hit"><td class="line">34</td><td class="hits">7</td><td class="source">      t = setTimeout(fn, diff);</td></tr><tr><td class="line">35</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">36</td><td class="hits"></td><td class="source">    else {</td></tr><tr class="hit"><td class="line">37</td><td class="hits">1</td><td class="source">      t = setTimeout(scheduleTimeout, 2147483647);</td></tr><tr><td class="line">38</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">39</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">40</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">41</td><td class="hits">8</td><td class="source">  return {</td></tr><tr><td class="line">42</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">43</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">44</td><td class="hits"></td><td class="source">    * Clears the timeout.</td></tr><tr><td class="line">45</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">46</td><td class="hits"></td><td class="source">    clear: function() {</td></tr><tr class="hit"><td class="line">47</td><td class="hits">4</td><td class="source">      clearTimeout(t);</td></tr><tr><td class="line">48</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">49</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">50</td><td class="hits"></td><td class="source">  };</td></tr><tr><td class="line">51</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">52</td><td class="hits"></td><td class="source">};</td></tr></tbody></table></div><div class="file"><h2 id="date/constant.js">date/constant.js</h2><div id="stats" class="high"><div class="percentage">100%</div><div class="sloc">7</div><div class="hits">7</div><div class="misses">0</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source">* Date Constants</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source">* (c) 2013 Bill, BunKat LLC.</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source">* Useful constants for dealing with time conversions.</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">7</td><td class="hits"></td><td class="source">* Later is freely distributable under the MIT license.</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source">* For all details and documentation:</td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">*     http://github.com/bunkat/later</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source">*/</td></tr><tr><td class="line">11</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source">// Time to milliseconds conversion</td></tr><tr class="hit"><td class="line">13</td><td class="hits">1</td><td class="source">later.SEC = 1000;</td></tr><tr class="hit"><td class="line">14</td><td class="hits">1</td><td class="source">later.MIN = later.SEC * 60;</td></tr><tr class="hit"><td class="line">15</td><td class="hits">1</td><td class="source">later.HOUR = later.MIN * 60;</td></tr><tr class="hit"><td class="line">16</td><td class="hits">1</td><td class="source">later.DAY = later.HOUR * 24;</td></tr><tr class="hit"><td class="line">17</td><td class="hits">1</td><td class="source">later.WEEK = later.DAY * 7;</td></tr><tr><td class="line">18</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">19</td><td class="hits"></td><td class="source">// Array of days in each month, must be corrected for leap years</td></tr><tr class="hit"><td class="line">20</td><td class="hits">1</td><td class="source">later.DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];</td></tr><tr><td class="line">21</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">22</td><td class="hits"></td><td class="source">// constant for specifying that a schedule can never occur</td></tr><tr class="hit"><td class="line">23</td><td class="hits">1</td><td class="source">later.NEVER = 0;</td></tr></tbody></table></div><div class="file"><h2 id="date/date.js">date/date.js</h2><div id="stats" class="high"><div class="percentage">100%</div><div class="sloc">1</div><div class="hits">1</div><div class="misses">0</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr class="hit"><td class="line">1</td><td class="hits">1</td><td class="source">later.date = {};</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">7</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source"> </td></tr></tbody></table></div><div class="file"><h2 id="date/next.js">date/next.js</h2><div id="stats" class="high"><div class="percentage">100%</div><div class="sloc">2</div><div class="hits">2</div><div class="misses">0</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source">* Next</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source">* (c) 2013 Bill, BunKat LLC.</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source">* Creates a new Date object defaulted to the first second after the specified</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source">* values.</td></tr><tr><td class="line">7</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source">* Later is freely distributable under the MIT license.</td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">* For all details and documentation:</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source">*     http://github.com/bunkat/later</td></tr><tr><td class="line">11</td><td class="hits"></td><td class="source">*/</td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">13</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">14</td><td class="hits"></td><td class="source">* Builds and returns a new Date using the specified values.  Date</td></tr><tr><td class="line">15</td><td class="hits"></td><td class="source">* returned is either using Local time or UTC based on isLocal.</td></tr><tr><td class="line">16</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">17</td><td class="hits"></td><td class="source">* @param {Int} Y: Four digit year</td></tr><tr><td class="line">18</td><td class="hits"></td><td class="source">* @param {Int} M: Month between 1 and 12, defaults to 1</td></tr><tr><td class="line">19</td><td class="hits"></td><td class="source">* @param {Int} D: Date between 1 and 31, defaults to 1</td></tr><tr><td class="line">20</td><td class="hits"></td><td class="source">* @param {Int} h: Hour between 0 and 23, defaults to 0</td></tr><tr><td class="line">21</td><td class="hits"></td><td class="source">* @param {Int} m: Minute between 0 and 59, defaults to 0</td></tr><tr><td class="line">22</td><td class="hits"></td><td class="source">* @param {Int} s: Second between 0 and 59, defaults to 0</td></tr><tr><td class="line">23</td><td class="hits"></td><td class="source">*/</td></tr><tr class="hit"><td class="line">24</td><td class="hits">1</td><td class="source">later.date.next = function(Y, M, D, h, m, s) {</td></tr><tr><td class="line">25</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">26</td><td class="hits">144440</td><td class="source">  return later.date.build(</td></tr><tr><td class="line">27</td><td class="hits"></td><td class="source">    Y,</td></tr><tr><td class="line">28</td><td class="hits"></td><td class="source">    M !== undefined ? M-1 : 0,</td></tr><tr><td class="line">29</td><td class="hits"></td><td class="source">    D !== undefined ? D : 1,</td></tr><tr><td class="line">30</td><td class="hits"></td><td class="source">    h || 0,</td></tr><tr><td class="line">31</td><td class="hits"></td><td class="source">    m || 0,</td></tr><tr><td class="line">32</td><td class="hits"></td><td class="source">    s || 0);</td></tr><tr><td class="line">33</td><td class="hits"></td><td class="source">};</td></tr></tbody></table></div><div class="file"><h2 id="date/nextrollover.js">date/nextrollover.js</h2><div id="stats" class="high"><div class="percentage">100%</div><div class="sloc">3</div><div class="hits">3</div><div class="misses">0</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source">* Next Rollover</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source">* (c) 2013 Bill, BunKat LLC.</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source">* Determines if a value will cause a particualr constraint to rollover to the</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source">* next largest time period. Used primarily when a constraint has a</td></tr><tr><td class="line">7</td><td class="hits"></td><td class="source">* variable extent.</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">* Later is freely distributable under the MIT license.</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source">* For all details and documentation:</td></tr><tr><td class="line">11</td><td class="hits"></td><td class="source">*     http://github.com/bunkat/later</td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source">*/</td></tr><tr><td class="line">13</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">14</td><td class="hits">1</td><td class="source">later.date.nextRollover = function(d, val, constraint, period) {</td></tr><tr class="hit"><td class="line">15</td><td class="hits">7893</td><td class="source">  var cur = constraint.val(d),</td></tr><tr><td class="line">16</td><td class="hits"></td><td class="source">      max = constraint.extent(d)[1];</td></tr><tr><td class="line">17</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">18</td><td class="hits">7893</td><td class="source">  return (((val || max) &lt;= cur) || val &gt; max) ?</td></tr><tr><td class="line">19</td><td class="hits"></td><td class="source">            new Date(period.end(d).getTime() + later.SEC) :</td></tr><tr><td class="line">20</td><td class="hits"></td><td class="source">            period.start(d);</td></tr><tr><td class="line">21</td><td class="hits"></td><td class="source">};</td></tr></tbody></table></div><div class="file"><h2 id="date/prev.js">date/prev.js</h2><div id="stats" class="high"><div class="percentage">100%</div><div class="sloc">8</div><div class="hits">8</div><div class="misses">0</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source">* Prev</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source">* (c) 2013 Bill, BunKat LLC.</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source">* Creates a new Date object defaulted to the last second after the specified</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source">* values.</td></tr><tr><td class="line">7</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source">* Later is freely distributable under the MIT license.</td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">* For all details and documentation:</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source">*     http://github.com/bunkat/later</td></tr><tr><td class="line">11</td><td class="hits"></td><td class="source">*/</td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">13</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">14</td><td class="hits"></td><td class="source">* Builds and returns a new Date using the specified values.  Date</td></tr><tr><td class="line">15</td><td class="hits"></td><td class="source">* returned is either using Local time or UTC based on isLocal.</td></tr><tr><td class="line">16</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">17</td><td class="hits"></td><td class="source">* @param {Int} Y: Four digit year</td></tr><tr><td class="line">18</td><td class="hits"></td><td class="source">* @param {Int} M: Month between 0 and 11, defaults to 11</td></tr><tr><td class="line">19</td><td class="hits"></td><td class="source">* @param {Int} D: Date between 1 and 31, defaults to last day of month</td></tr><tr><td class="line">20</td><td class="hits"></td><td class="source">* @param {Int} h: Hour between 0 and 23, defaults to 23</td></tr><tr><td class="line">21</td><td class="hits"></td><td class="source">* @param {Int} m: Minute between 0 and 59, defaults to 59</td></tr><tr><td class="line">22</td><td class="hits"></td><td class="source">* @param {Int} s: Second between 0 and 59, defaults to 59</td></tr><tr><td class="line">23</td><td class="hits"></td><td class="source">*/</td></tr><tr class="hit"><td class="line">24</td><td class="hits">1</td><td class="source">later.date.prev = function(Y, M, D, h, m, s) {</td></tr><tr><td class="line">25</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">26</td><td class="hits">51857</td><td class="source">  var len = arguments.length;</td></tr><tr class="hit"><td class="line">27</td><td class="hits">51857</td><td class="source">  M = len &lt; 2 ? 11 : M-1;</td></tr><tr class="hit"><td class="line">28</td><td class="hits">51857</td><td class="source">  D = len &lt; 3 ? later.D.extent(later.date.next(Y, M+1))[1] : D;</td></tr><tr class="hit"><td class="line">29</td><td class="hits">51857</td><td class="source">  h = len &lt; 4 ? 23 : h;</td></tr><tr class="hit"><td class="line">30</td><td class="hits">51857</td><td class="source">  m = len &lt; 5 ? 59 : m;</td></tr><tr class="hit"><td class="line">31</td><td class="hits">51857</td><td class="source">  s = len &lt; 6 ? 59 : s;</td></tr><tr><td class="line">32</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">33</td><td class="hits">51857</td><td class="source">  return later.date.build(Y, M, D, h, m, s);</td></tr><tr><td class="line">34</td><td class="hits"></td><td class="source">};</td></tr></tbody></table></div><div class="file"><h2 id="date/prevrollover.js">date/prevrollover.js</h2><div id="stats" class="high"><div class="percentage">100%</div><div class="sloc">3</div><div class="hits">3</div><div class="misses">0</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source">* Prev Rollover</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source">* (c) 2013 Bill, BunKat LLC.</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source">* Determines if a value will cause a particualr constraint to rollover to the</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source">* previous largest time period. Used primarily when a constraint has a</td></tr><tr><td class="line">7</td><td class="hits"></td><td class="source">* variable extent.</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">* Later is freely distributable under the MIT license.</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source">* For all details and documentation:</td></tr><tr><td class="line">11</td><td class="hits"></td><td class="source">*     http://github.com/bunkat/later</td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source">*/</td></tr><tr><td class="line">13</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">14</td><td class="hits">1</td><td class="source">later.date.prevRollover = function(d, val, constraint, period) {</td></tr><tr class="hit"><td class="line">15</td><td class="hits">7638</td><td class="source">  var cur = constraint.val(d);</td></tr><tr><td class="line">16</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">17</td><td class="hits">7638</td><td class="source">  return (val &gt;= cur || !val) ?</td></tr><tr><td class="line">18</td><td class="hits"></td><td class="source">            period.start(period.prev(d, period.val(d)-1)) :</td></tr><tr><td class="line">19</td><td class="hits"></td><td class="source">            period.start(d);</td></tr><tr><td class="line">20</td><td class="hits"></td><td class="source">};</td></tr></tbody></table></div><div class="file"><h2 id="date/timezone.js">date/timezone.js</h2><div id="stats" class="high"><div class="percentage">100%</div><div class="sloc">16</div><div class="hits">16</div><div class="misses">0</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source">* Timezone</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source">* (c) 2013 Bill, BunKat LLC.</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source">* Configures helper functions to switch between useing local time and UTC. Later</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source">* uses UTC time by default.</td></tr><tr><td class="line">7</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source">* Later is freely distributable under the MIT license.</td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">* For all details and documentation:</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source">*     http://github.com/bunkat/later</td></tr><tr><td class="line">11</td><td class="hits"></td><td class="source">*/</td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">13</td><td class="hits">1</td><td class="source">later.date.timezone = function(useLocalTime) {</td></tr><tr><td class="line">14</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">15</td><td class="hits"></td><td class="source">  // configure the date builder used to create new dates in the right timezone</td></tr><tr class="hit"><td class="line">16</td><td class="hits">41460</td><td class="source">  later.date.build = useLocalTime ?</td></tr><tr class="hit"><td class="line">17</td><td class="hits">85178</td><td class="source">    function(Y, M, D, h, m, s) { return new Date(Y, M, D, h, m, s); } :</td></tr><tr class="hit"><td class="line">18</td><td class="hits">111119</td><td class="source">    function(Y, M, D, h, m, s) { return new Date(Date.UTC(Y, M, D, h, m, s)); };</td></tr><tr><td class="line">19</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">20</td><td class="hits"></td><td class="source">  // configure the accessor methods</td></tr><tr class="hit"><td class="line">21</td><td class="hits">41460</td><td class="source">  var get = useLocalTime ? 'get' : 'getUTC',</td></tr><tr><td class="line">22</td><td class="hits"></td><td class="source">      d = Date.prototype;</td></tr><tr><td class="line">23</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">24</td><td class="hits">41460</td><td class="source">  later.date.getYear = d[get + 'FullYear'];</td></tr><tr class="hit"><td class="line">25</td><td class="hits">41460</td><td class="source">  later.date.getMonth = d[get + 'Month'];</td></tr><tr class="hit"><td class="line">26</td><td class="hits">41460</td><td class="source">  later.date.getDate = d[get + 'Date'];</td></tr><tr class="hit"><td class="line">27</td><td class="hits">41460</td><td class="source">  later.date.getDay = d[get + 'Day'];</td></tr><tr class="hit"><td class="line">28</td><td class="hits">41460</td><td class="source">  later.date.getHour = d[get + 'Hours'];</td></tr><tr class="hit"><td class="line">29</td><td class="hits">41460</td><td class="source">  later.date.getMin = d[get + 'Minutes'];</td></tr><tr class="hit"><td class="line">30</td><td class="hits">41460</td><td class="source">  later.date.getSec = d[get + 'Seconds'];</td></tr><tr><td class="line">31</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">32</td><td class="hits"></td><td class="source">  // set the isUTC flag</td></tr><tr class="hit"><td class="line">33</td><td class="hits">41460</td><td class="source">  later.date.isUTC = !useLocalTime;</td></tr><tr><td class="line">34</td><td class="hits"></td><td class="source">};</td></tr><tr><td class="line">35</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">36</td><td class="hits"></td><td class="source">// friendly names for available timezones</td></tr><tr class="hit"><td class="line">37</td><td class="hits">20801</td><td class="source">later.date.UTC = function() { later.date.timezone(false); };</td></tr><tr class="hit"><td class="line">38</td><td class="hits">20661</td><td class="source">later.date.localTime = function() { later.date.timezone(true); };</td></tr><tr><td class="line">39</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">40</td><td class="hits"></td><td class="source">// use UTC by default</td></tr><tr class="hit"><td class="line">41</td><td class="hits">1</td><td class="source">later.date.UTC();</td></tr></tbody></table></div><div class="file"><h2 id="modifier/after.js">modifier/after.js</h2><div id="stats" class="high"><div class="percentage">100%</div><div class="sloc">8</div><div class="hits">8</div><div class="misses">0</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source">* After Modifier</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source">* (c) 2013 Bill, BunKat LLC.</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source">* Modifies a constraint such that all values that are greater than the</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source">* specified value are considered valid.</td></tr><tr><td class="line">7</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source">* Later is freely distributable under the MIT license.</td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">* For all details and documentation:</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source">*     http://github.com/bunkat/later</td></tr><tr><td class="line">11</td><td class="hits"></td><td class="source">*/</td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">13</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">14</td><td class="hits"></td><td class="source">* Creates a new modified constraint.</td></tr><tr><td class="line">15</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">16</td><td class="hits"></td><td class="source">* @param {Constraint} constraint: The constraint to be modified</td></tr><tr><td class="line">17</td><td class="hits"></td><td class="source">* @param {Integer} value: The starting value of the after constraint</td></tr><tr><td class="line">18</td><td class="hits"></td><td class="source">*/</td></tr><tr class="hit"><td class="line">19</td><td class="hits">1</td><td class="source">later.modifier.after = later.modifier.a = function(constraint, values) {</td></tr><tr><td class="line">20</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">21</td><td class="hits">153</td><td class="source">  var value = values[0];</td></tr><tr><td class="line">22</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">23</td><td class="hits">153</td><td class="source">  return {</td></tr><tr><td class="line">24</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">25</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">26</td><td class="hits"></td><td class="source">    * Returns the name of the constraint with the 'after' modifier.</td></tr><tr><td class="line">27</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">28</td><td class="hits"></td><td class="source">    name: 'after ' + constraint.name,</td></tr><tr><td class="line">29</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">30</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">31</td><td class="hits"></td><td class="source">    * Pass through to the constraint.</td></tr><tr><td class="line">32</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">33</td><td class="hits"></td><td class="source">    range: (constraint.extent(new Date())[1] - value) * constraint.range,</td></tr><tr><td class="line">34</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">35</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">36</td><td class="hits"></td><td class="source">    * The value of the specified date. Returns value for any constraint val</td></tr><tr><td class="line">37</td><td class="hits"></td><td class="source">    * that is greater than or equal to value.</td></tr><tr><td class="line">38</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">39</td><td class="hits"></td><td class="source">    * @param {Date} d: The date to calculate the value of</td></tr><tr><td class="line">40</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">41</td><td class="hits"></td><td class="source">    val: constraint.val,</td></tr><tr><td class="line">42</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">43</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">44</td><td class="hits"></td><td class="source">    * Returns true if the val is valid for the date specified.</td></tr><tr><td class="line">45</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">46</td><td class="hits"></td><td class="source">    * @param {Date} d: The date to check the value on</td></tr><tr><td class="line">47</td><td class="hits"></td><td class="source">    * @param {Integer} val: The value to validate</td></tr><tr><td class="line">48</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">49</td><td class="hits"></td><td class="source">    isValid: function(d, val) {</td></tr><tr class="hit"><td class="line">50</td><td class="hits">1494</td><td class="source">      return this.val(d) &gt;= value;</td></tr><tr><td class="line">51</td><td class="hits"></td><td class="source">    },</td></tr><tr><td class="line">52</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">53</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">54</td><td class="hits"></td><td class="source">    * Pass through to the constraint.</td></tr><tr><td class="line">55</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">56</td><td class="hits"></td><td class="source">    extent: constraint.extent,</td></tr><tr><td class="line">57</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">58</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">59</td><td class="hits"></td><td class="source">    * Pass through to the constraint.</td></tr><tr><td class="line">60</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">61</td><td class="hits"></td><td class="source">    start: constraint.start,</td></tr><tr><td class="line">62</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">63</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">64</td><td class="hits"></td><td class="source">    * Pass through to the constraint.</td></tr><tr><td class="line">65</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">66</td><td class="hits"></td><td class="source">    end: constraint.end,</td></tr><tr><td class="line">67</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">68</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">69</td><td class="hits"></td><td class="source">    * Pass through to the constraint.</td></tr><tr><td class="line">70</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">71</td><td class="hits"></td><td class="source">    next: function(startDate, val) {</td></tr><tr class="hit"><td class="line">72</td><td class="hits">143</td><td class="source">        if(val != value) val = constraint.extent(startDate)[0];</td></tr><tr class="hit"><td class="line">73</td><td class="hits">105</td><td class="source">        return constraint.next(startDate, val);</td></tr><tr><td class="line">74</td><td class="hits"></td><td class="source">    },</td></tr><tr><td class="line">75</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">76</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">77</td><td class="hits"></td><td class="source">    * Pass through to the constraint.</td></tr><tr><td class="line">78</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">79</td><td class="hits"></td><td class="source">    prev: function(startDate, val) {</td></tr><tr class="hit"><td class="line">80</td><td class="hits">59</td><td class="source">        val = val === value ? constraint.extent(startDate)[1] : value - 1;</td></tr><tr class="hit"><td class="line">81</td><td class="hits">59</td><td class="source">        return constraint.prev(startDate, val);</td></tr><tr><td class="line">82</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">83</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">84</td><td class="hits"></td><td class="source">  };</td></tr><tr><td class="line">85</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">86</td><td class="hits"></td><td class="source">};</td></tr></tbody></table></div><div class="file"><h2 id="modifier/before.js">modifier/before.js</h2><div id="stats" class="high"><div class="percentage">100%</div><div class="sloc">8</div><div class="hits">8</div><div class="misses">0</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source">* Before Modifier</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source">* (c) 2013 Bill, BunKat LLC.</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source">* Modifies a constraint such that all values that are less than the</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source">* specified value are considered valid.</td></tr><tr><td class="line">7</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source">* Later is freely distributable under the MIT license.</td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">* For all details and documentation:</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source">*     http://github.com/bunkat/later</td></tr><tr><td class="line">11</td><td class="hits"></td><td class="source">*/</td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">13</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">14</td><td class="hits"></td><td class="source">* Creates a new modified constraint.</td></tr><tr><td class="line">15</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">16</td><td class="hits"></td><td class="source">* @param {Constraint} constraint: The constraint to be modified</td></tr><tr><td class="line">17</td><td class="hits"></td><td class="source">* @param {Integer} value: The starting value of the before constraint</td></tr><tr><td class="line">18</td><td class="hits"></td><td class="source">*/</td></tr><tr class="hit"><td class="line">19</td><td class="hits">1</td><td class="source">later.modifier.before = later.modifier.b = function(constraint, values) {</td></tr><tr><td class="line">20</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">21</td><td class="hits">141</td><td class="source">  var value = values[values.length-1];</td></tr><tr><td class="line">22</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">23</td><td class="hits">141</td><td class="source">  return {</td></tr><tr><td class="line">24</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">25</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">26</td><td class="hits"></td><td class="source">    * Returns the name of the constraint with the 'before' modifier.</td></tr><tr><td class="line">27</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">28</td><td class="hits"></td><td class="source">    name: 'before ' + constraint.name,</td></tr><tr><td class="line">29</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">30</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">31</td><td class="hits"></td><td class="source">    * Pass through to the constraint.</td></tr><tr><td class="line">32</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">33</td><td class="hits"></td><td class="source">    range: constraint.range * (value-1),</td></tr><tr><td class="line">34</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">35</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">36</td><td class="hits"></td><td class="source">    * The value of the specified date. Returns value for any constraint val</td></tr><tr><td class="line">37</td><td class="hits"></td><td class="source">    * that is less than or equal to value.</td></tr><tr><td class="line">38</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">39</td><td class="hits"></td><td class="source">    * @param {Date} d: The date to calculate the value of</td></tr><tr><td class="line">40</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">41</td><td class="hits"></td><td class="source">    val: constraint.val,</td></tr><tr><td class="line">42</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">43</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">44</td><td class="hits"></td><td class="source">    * Returns true if the val is valid for the date specified.</td></tr><tr><td class="line">45</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">46</td><td class="hits"></td><td class="source">    * @param {Date} d: The date to check the value on</td></tr><tr><td class="line">47</td><td class="hits"></td><td class="source">    * @param {Integer} val: The value to validate</td></tr><tr><td class="line">48</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">49</td><td class="hits"></td><td class="source">    isValid: function(d, val) {</td></tr><tr class="hit"><td class="line">50</td><td class="hits">491</td><td class="source">      return this.val(d) &lt; value;</td></tr><tr><td class="line">51</td><td class="hits"></td><td class="source">    },</td></tr><tr><td class="line">52</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">53</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">54</td><td class="hits"></td><td class="source">    * Pass through to the constraint.</td></tr><tr><td class="line">55</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">56</td><td class="hits"></td><td class="source">    extent: constraint.extent,</td></tr><tr><td class="line">57</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">58</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">59</td><td class="hits"></td><td class="source">    * Pass through to the constraint.</td></tr><tr><td class="line">60</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">61</td><td class="hits"></td><td class="source">    start: constraint.start,</td></tr><tr><td class="line">62</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">63</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">64</td><td class="hits"></td><td class="source">    * Jump to the end of the range.</td></tr><tr><td class="line">65</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">66</td><td class="hits"></td><td class="source">    end: constraint.end,</td></tr><tr><td class="line">67</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">68</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">69</td><td class="hits"></td><td class="source">    * Pass through to the constraint.</td></tr><tr><td class="line">70</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">71</td><td class="hits"></td><td class="source">    next: function(startDate, val) {</td></tr><tr class="hit"><td class="line">72</td><td class="hits">81</td><td class="source">      val = val === value ? constraint.extent(startDate)[0] : value;</td></tr><tr class="hit"><td class="line">73</td><td class="hits">81</td><td class="source">      return constraint.next(startDate, val);</td></tr><tr><td class="line">74</td><td class="hits"></td><td class="source">    },</td></tr><tr><td class="line">75</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">76</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">77</td><td class="hits"></td><td class="source">    * Pass through to the constraint.</td></tr><tr><td class="line">78</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">79</td><td class="hits"></td><td class="source">    prev: function(startDate, val) {</td></tr><tr class="hit"><td class="line">80</td><td class="hits">55</td><td class="source">      val = val === value ? value - 1 : constraint.extent(startDate)[1];</td></tr><tr class="hit"><td class="line">81</td><td class="hits">55</td><td class="source">      return constraint.prev(startDate, val);</td></tr><tr><td class="line">82</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">83</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">84</td><td class="hits"></td><td class="source">  };</td></tr><tr><td class="line">85</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">86</td><td class="hits"></td><td class="source">};</td></tr></tbody></table></div><div class="file"><h2 id="modifier/modifier.js">modifier/modifier.js</h2><div id="stats" class="high"><div class="percentage">100%</div><div class="sloc">1</div><div class="hits">1</div><div class="misses">0</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">2</td><td class="hits">1</td><td class="source">later.modifier = {};</td></tr></tbody></table></div><div class="file"><h2 id="parse/cron.js">parse/cron.js</h2><div id="stats" class="high"><div class="percentage">100%</div><div class="sloc">80</div><div class="hits">80</div><div class="misses">0</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source">* Cron</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source">* (c) 2013 Bill, BunKat LLC.</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source">* Creates a valid Later schedule from a valid cron expression.</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">7</td><td class="hits"></td><td class="source">* Later is freely distributable under the MIT license.</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source">* For all details and documentation:</td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">*     http://github.com/bunkat/later</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source">*/</td></tr><tr><td class="line">11</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">13</td><td class="hits"></td><td class="source">* Parses a valid cron expression and produces a valid schedule that</td></tr><tr><td class="line">14</td><td class="hits"></td><td class="source">* can then be used with Later.</td></tr><tr><td class="line">15</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">16</td><td class="hits"></td><td class="source">* CronParser().parse('* 5 * * * * *', true);</td></tr><tr><td class="line">17</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">18</td><td class="hits"></td><td class="source">* @param {String} expr: The cron expression to parse</td></tr><tr><td class="line">19</td><td class="hits"></td><td class="source">* @param {Bool} hasSeconds: True if the expression uses a seconds field</td></tr><tr><td class="line">20</td><td class="hits"></td><td class="source">* @api public</td></tr><tr><td class="line">21</td><td class="hits"></td><td class="source">*/</td></tr><tr class="hit"><td class="line">22</td><td class="hits">1</td><td class="source">later.parse.cron = function (expr, hasSeconds) {</td></tr><tr><td class="line">23</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">24</td><td class="hits"></td><td class="source">  // Constant array to convert valid names to values</td></tr><tr class="hit"><td class="line">25</td><td class="hits">87</td><td class="source">  var NAMES = {</td></tr><tr><td class="line">26</td><td class="hits"></td><td class="source">    JAN: 1, FEB: 2, MAR: 3, APR: 4, MAY: 5, JUN: 6, JUL: 7, AUG: 8,</td></tr><tr><td class="line">27</td><td class="hits"></td><td class="source">    SEP: 9, OCT: 10, NOV: 11, DEC: 12,</td></tr><tr><td class="line">28</td><td class="hits"></td><td class="source">    SUN: 1, MON: 2, TUE: 3, WED: 4, THU: 5, FRI: 6, SAT: 7</td></tr><tr><td class="line">29</td><td class="hits"></td><td class="source">  };</td></tr><tr><td class="line">30</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">31</td><td class="hits"></td><td class="source">  // Contains the index, min, and max for each of the constraints</td></tr><tr class="hit"><td class="line">32</td><td class="hits">87</td><td class="source">  var FIELDS = {</td></tr><tr><td class="line">33</td><td class="hits"></td><td class="source">    s: [0, 0, 59],      // seconds</td></tr><tr><td class="line">34</td><td class="hits"></td><td class="source">    m: [1, 0, 59],      // minutes</td></tr><tr><td class="line">35</td><td class="hits"></td><td class="source">    h: [2, 0, 23],      // hours</td></tr><tr><td class="line">36</td><td class="hits"></td><td class="source">    D: [3, 1, 31],      // day of month</td></tr><tr><td class="line">37</td><td class="hits"></td><td class="source">    M: [4, 1, 12],      // month</td></tr><tr><td class="line">38</td><td class="hits"></td><td class="source">    Y: [6, 1970, 2099], // year</td></tr><tr><td class="line">39</td><td class="hits"></td><td class="source">    d: [5, 1, 7, 1]     // day of week</td></tr><tr><td class="line">40</td><td class="hits"></td><td class="source">  };</td></tr><tr><td class="line">41</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">42</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">43</td><td class="hits"></td><td class="source">  * Returns the value + offset if value is a number, otherwise it</td></tr><tr><td class="line">44</td><td class="hits"></td><td class="source">  * attempts to look up the value in the NAMES table and returns</td></tr><tr><td class="line">45</td><td class="hits"></td><td class="source">  * that result instead.</td></tr><tr><td class="line">46</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">47</td><td class="hits"></td><td class="source">  * @param {Int,String} value: The value that should be parsed</td></tr><tr><td class="line">48</td><td class="hits"></td><td class="source">  * @param {Int} offset: Any offset that must be added to the value</td></tr><tr><td class="line">49</td><td class="hits"></td><td class="source">  */</td></tr><tr class="hit"><td class="line">50</td><td class="hits">87</td><td class="source">  function getValue(value, offset) {</td></tr><tr class="hit"><td class="line">51</td><td class="hits">321</td><td class="source">    return isNaN(value) ? NAMES[value] || null : +value + (offset || 0);</td></tr><tr><td class="line">52</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">53</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">54</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">55</td><td class="hits"></td><td class="source">  * Returns a deep clone of a schedule skipping any day of week</td></tr><tr><td class="line">56</td><td class="hits"></td><td class="source">  * constraints.</td></tr><tr><td class="line">57</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">58</td><td class="hits"></td><td class="source">  * @param {Sched} sched: The schedule that will be cloned</td></tr><tr><td class="line">59</td><td class="hits"></td><td class="source">  */</td></tr><tr class="hit"><td class="line">60</td><td class="hits">87</td><td class="source">  function cloneSchedule(sched) {</td></tr><tr class="hit"><td class="line">61</td><td class="hits">6</td><td class="source">    var clone = {}, field;</td></tr><tr><td class="line">62</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">63</td><td class="hits">6</td><td class="source">    for(field in sched) {</td></tr><tr class="hit"><td class="line">64</td><td class="hits">11</td><td class="source">      if (field !== 'dc' &amp;&amp; field !== 'd') {</td></tr><tr class="hit"><td class="line">65</td><td class="hits">2</td><td class="source">        clone[field] = sched[field].slice(0);</td></tr><tr><td class="line">66</td><td class="hits"></td><td class="source">      }</td></tr><tr><td class="line">67</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">68</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">69</td><td class="hits">6</td><td class="source">    return clone;</td></tr><tr><td class="line">70</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">71</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">72</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">73</td><td class="hits"></td><td class="source">  * Adds values to the specified constraint in the current schedule.</td></tr><tr><td class="line">74</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">75</td><td class="hits"></td><td class="source">  * @param {Sched} sched: The schedule to add the constraint to</td></tr><tr><td class="line">76</td><td class="hits"></td><td class="source">  * @param {String} name: Name of constraint to add</td></tr><tr><td class="line">77</td><td class="hits"></td><td class="source">  * @param {Int} min: Minimum value for this constraint</td></tr><tr><td class="line">78</td><td class="hits"></td><td class="source">  * @param {Int} max: Maximum value for this constraint</td></tr><tr><td class="line">79</td><td class="hits"></td><td class="source">  * @param {Int} inc: The increment to use between min and max</td></tr><tr><td class="line">80</td><td class="hits"></td><td class="source">  */</td></tr><tr class="hit"><td class="line">81</td><td class="hits">87</td><td class="source">  function add(sched, name, min, max, inc) {</td></tr><tr class="hit"><td class="line">82</td><td class="hits">187</td><td class="source">    var i = min;</td></tr><tr><td class="line">83</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">84</td><td class="hits">187</td><td class="source">    if (!sched[name]) {</td></tr><tr class="hit"><td class="line">85</td><td class="hits">163</td><td class="source">      sched[name] = [];</td></tr><tr><td class="line">86</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">87</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">88</td><td class="hits">187</td><td class="source">    while (i &lt;= max) {</td></tr><tr class="hit"><td class="line">89</td><td class="hits">359</td><td class="source">      if (sched[name].indexOf(i) &lt; 0) {</td></tr><tr class="hit"><td class="line">90</td><td class="hits">353</td><td class="source">        sched[name].push(i);</td></tr><tr><td class="line">91</td><td class="hits"></td><td class="source">      }</td></tr><tr class="hit"><td class="line">92</td><td class="hits">359</td><td class="source">      i += inc || 1;</td></tr><tr><td class="line">93</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">94</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">95</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">96</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">97</td><td class="hits"></td><td class="source">  * Adds a hash item (of the form x#y or xL) to the schedule.</td></tr><tr><td class="line">98</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">99</td><td class="hits"></td><td class="source">  * @param {Schedule} schedules: The current schedule array to add to</td></tr><tr><td class="line">100</td><td class="hits"></td><td class="source">  * @param {Schedule} curSched: The current schedule to add to</td></tr><tr><td class="line">101</td><td class="hits"></td><td class="source">  * @param {Int} value: The value to add (x of x#y or xL)</td></tr><tr><td class="line">102</td><td class="hits"></td><td class="source">  * @param {Int} hash: The hash value to add (y of x#y)</td></tr><tr><td class="line">103</td><td class="hits"></td><td class="source">  */</td></tr><tr class="hit"><td class="line">104</td><td class="hits">87</td><td class="source">  function addHash(schedules, curSched, value, hash) {</td></tr><tr><td class="line">105</td><td class="hits"></td><td class="source">    // if there are any existing day of week constraints that</td></tr><tr><td class="line">106</td><td class="hits"></td><td class="source">    // aren't equal to the one we're adding, create a new</td></tr><tr><td class="line">107</td><td class="hits"></td><td class="source">    // composite schedule</td></tr><tr class="hit"><td class="line">108</td><td class="hits">14</td><td class="source">    if ((curSched.d &amp;&amp; !curSched.dc) ||</td></tr><tr><td class="line">109</td><td class="hits"></td><td class="source">        (curSched.dc &amp;&amp; curSched.dc.indexOf(hash) &lt; 0)) {</td></tr><tr class="hit"><td class="line">110</td><td class="hits">6</td><td class="source">      schedules.push(cloneSchedule(curSched));</td></tr><tr class="hit"><td class="line">111</td><td class="hits">6</td><td class="source">      curSched = schedules[schedules.length-1];</td></tr><tr><td class="line">112</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">113</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">114</td><td class="hits">14</td><td class="source">    add(curSched, 'd', value, value);</td></tr><tr class="hit"><td class="line">115</td><td class="hits">14</td><td class="source">    add(curSched, 'dc', hash, hash);</td></tr><tr><td class="line">116</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">117</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">118</td><td class="hits">87</td><td class="source">  function addWeekday(s, curSched, value) {</td></tr><tr class="hit"><td class="line">119</td><td class="hits">4</td><td class="source">     var except1 = {}, except2 = {};</td></tr><tr class="hit"><td class="line">120</td><td class="hits">4</td><td class="source">     if (value=== 1) {</td></tr><tr><td class="line">121</td><td class="hits"></td><td class="source">      // cron doesn't pass month boundaries, so if 1st is a</td></tr><tr><td class="line">122</td><td class="hits"></td><td class="source">      // weekend then we need to use 2nd or 3rd instead</td></tr><tr class="hit"><td class="line">123</td><td class="hits">1</td><td class="source">      add(curSched, 'D', 1, 3);</td></tr><tr class="hit"><td class="line">124</td><td class="hits">1</td><td class="source">      add(curSched, 'd', NAMES.MON, NAMES.FRI);</td></tr><tr class="hit"><td class="line">125</td><td class="hits">1</td><td class="source">      add(except1, 'D', 2, 2);</td></tr><tr class="hit"><td class="line">126</td><td class="hits">1</td><td class="source">      add(except1, 'd', NAMES.TUE, NAMES.FRI);</td></tr><tr class="hit"><td class="line">127</td><td class="hits">1</td><td class="source">      add(except2, 'D', 3, 3);</td></tr><tr class="hit"><td class="line">128</td><td class="hits">1</td><td class="source">      add(except2, 'd', NAMES.TUE, NAMES.FRI);</td></tr><tr><td class="line">129</td><td class="hits"></td><td class="source">    } else {</td></tr><tr><td class="line">130</td><td class="hits"></td><td class="source">      // normally you want the closest day, so if v is a</td></tr><tr><td class="line">131</td><td class="hits"></td><td class="source">      // Saturday, use the previous Friday.  If it's a</td></tr><tr><td class="line">132</td><td class="hits"></td><td class="source">      // sunday, use the following Monday.</td></tr><tr class="hit"><td class="line">133</td><td class="hits">3</td><td class="source">      add(curSched, 'D', value-1, value+1);</td></tr><tr class="hit"><td class="line">134</td><td class="hits">3</td><td class="source">      add(curSched, 'd', NAMES.MON, NAMES.FRI);</td></tr><tr class="hit"><td class="line">135</td><td class="hits">3</td><td class="source">      add(except1, 'D', value-1, value-1);</td></tr><tr class="hit"><td class="line">136</td><td class="hits">3</td><td class="source">      add(except1, 'd', NAMES.MON, NAMES.THU);</td></tr><tr class="hit"><td class="line">137</td><td class="hits">3</td><td class="source">      add(except2, 'D', value+1, value+1);</td></tr><tr class="hit"><td class="line">138</td><td class="hits">3</td><td class="source">      add(except2, 'd', NAMES.TUE, NAMES.FRI);</td></tr><tr><td class="line">139</td><td class="hits"></td><td class="source">    }</td></tr><tr class="hit"><td class="line">140</td><td class="hits">4</td><td class="source">    s.exceptions.push(except1);</td></tr><tr class="hit"><td class="line">141</td><td class="hits">4</td><td class="source">    s.exceptions.push(except2);</td></tr><tr><td class="line">142</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">143</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">144</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">145</td><td class="hits"></td><td class="source">  * Adds a range item (of the form x-y/z) to the schedule.</td></tr><tr><td class="line">146</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">147</td><td class="hits"></td><td class="source">  * @param {String} item: The cron expression item to add</td></tr><tr><td class="line">148</td><td class="hits"></td><td class="source">  * @param {Schedule} curSched: The current schedule to add to</td></tr><tr><td class="line">149</td><td class="hits"></td><td class="source">  * @param {String} name: The name to use for this constraint</td></tr><tr><td class="line">150</td><td class="hits"></td><td class="source">  * @param {Int} min: The min value for the constraint</td></tr><tr><td class="line">151</td><td class="hits"></td><td class="source">  * @param {Int} max: The max value for the constraint</td></tr><tr><td class="line">152</td><td class="hits"></td><td class="source">  * @param {Int} offset: The offset to apply to the cron value</td></tr><tr><td class="line">153</td><td class="hits"></td><td class="source">  */</td></tr><tr class="hit"><td class="line">154</td><td class="hits">87</td><td class="source">  function addRange(item, curSched, name, min, max, offset) {</td></tr><tr><td class="line">155</td><td class="hits"></td><td class="source">    // parse range/x</td></tr><tr class="hit"><td class="line">156</td><td class="hits">36</td><td class="source">    var incSplit = item.split('/'),</td></tr><tr><td class="line">157</td><td class="hits"></td><td class="source">        inc = +incSplit[1],</td></tr><tr><td class="line">158</td><td class="hits"></td><td class="source">        range = incSplit[0];</td></tr><tr><td class="line">159</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">160</td><td class="hits"></td><td class="source">    // parse x-y or * or 0</td></tr><tr class="hit"><td class="line">161</td><td class="hits">36</td><td class="source">    if (range !== '*' &amp;&amp; range !== '0') {</td></tr><tr class="hit"><td class="line">162</td><td class="hits">24</td><td class="source">      var rangeSplit = range.split('-');</td></tr><tr class="hit"><td class="line">163</td><td class="hits">24</td><td class="source">      min = getValue(rangeSplit[0], offset);</td></tr><tr><td class="line">164</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">165</td><td class="hits"></td><td class="source">      // fix for issue #13, range may be single digit</td></tr><tr class="hit"><td class="line">166</td><td class="hits">24</td><td class="source">      max = getValue(rangeSplit[1], offset) || max;</td></tr><tr><td class="line">167</td><td class="hits"></td><td class="source">    }</td></tr><tr class="hit"><td class="line">168</td><td class="hits">36</td><td class="source">    add(curSched, name, min, max, inc);</td></tr><tr><td class="line">169</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">170</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">171</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">172</td><td class="hits"></td><td class="source">  * Parses a particular item within a cron expression.</td></tr><tr><td class="line">173</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">174</td><td class="hits"></td><td class="source">  * @param {String} item: The cron expression item to parse</td></tr><tr><td class="line">175</td><td class="hits"></td><td class="source">  * @param {Schedule} s: The existing set of schedules</td></tr><tr><td class="line">176</td><td class="hits"></td><td class="source">  * @param {String} name: The name to use for this constraint</td></tr><tr><td class="line">177</td><td class="hits"></td><td class="source">  * @param {Int} min: The min value for the constraint</td></tr><tr><td class="line">178</td><td class="hits"></td><td class="source">  * @param {Int} max: The max value for the constraint</td></tr><tr><td class="line">179</td><td class="hits"></td><td class="source">  * @param {Int} offset: The offset to apply to the cron value</td></tr><tr><td class="line">180</td><td class="hits"></td><td class="source">  */</td></tr><tr class="hit"><td class="line">181</td><td class="hits">87</td><td class="source">  function parse(item, s, name, min, max, offset) {</td></tr><tr class="hit"><td class="line">182</td><td class="hits">153</td><td class="source">    var value,</td></tr><tr><td class="line">183</td><td class="hits"></td><td class="source">        split,</td></tr><tr><td class="line">184</td><td class="hits"></td><td class="source">        schedules = s.schedules,</td></tr><tr><td class="line">185</td><td class="hits"></td><td class="source">        curSched = schedules[schedules.length-1];</td></tr><tr><td class="line">186</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">187</td><td class="hits"></td><td class="source">    // L just means min - 1 (this also makes it work for any field)</td></tr><tr class="hit"><td class="line">188</td><td class="hits">153</td><td class="source">    if (item === 'L') {</td></tr><tr class="hit"><td class="line">189</td><td class="hits">2</td><td class="source">      item = min - 1;</td></tr><tr><td class="line">190</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">191</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">192</td><td class="hits"></td><td class="source">    // parse x</td></tr><tr class="hit"><td class="line">193</td><td class="hits">153</td><td class="source">    if ((value = getValue(item, offset)) !== null) {</td></tr><tr class="hit"><td class="line">194</td><td class="hits">99</td><td class="source">      add(curSched, name, value, value);</td></tr><tr><td class="line">195</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">196</td><td class="hits"></td><td class="source">    // parse xW</td></tr><tr class="hit"><td class="line">197</td><td class="hits">54</td><td class="source">    else if ((value = getValue(item.replace('W', ''), offset)) !== null) {</td></tr><tr class="hit"><td class="line">198</td><td class="hits">4</td><td class="source">      addWeekday(s, curSched, value);</td></tr><tr><td class="line">199</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">200</td><td class="hits"></td><td class="source">    // parse xL</td></tr><tr class="hit"><td class="line">201</td><td class="hits">50</td><td class="source">    else if ((value = getValue(item.replace('L', ''), offset)) !== null) {</td></tr><tr class="hit"><td class="line">202</td><td class="hits">6</td><td class="source">      addHash(schedules, curSched, value, min-1);</td></tr><tr><td class="line">203</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">204</td><td class="hits"></td><td class="source">    // parse x#y</td></tr><tr class="hit"><td class="line">205</td><td class="hits">44</td><td class="source">    else if ((split = item.split('#')).length === 2) {</td></tr><tr class="hit"><td class="line">206</td><td class="hits">8</td><td class="source">      value = getValue(split[0], offset);</td></tr><tr class="hit"><td class="line">207</td><td class="hits">8</td><td class="source">      addHash(schedules, curSched, value, getValue(split[1]));</td></tr><tr><td class="line">208</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">209</td><td class="hits"></td><td class="source">    // parse x-y or x-y/z or */z or 0/z</td></tr><tr><td class="line">210</td><td class="hits"></td><td class="source">    else {</td></tr><tr class="hit"><td class="line">211</td><td class="hits">36</td><td class="source">      addRange(item, curSched, name, min, max, offset);</td></tr><tr><td class="line">212</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">213</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">214</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">215</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">216</td><td class="hits"></td><td class="source">  * Returns true if the item is either of the form x#y or xL.</td></tr><tr><td class="line">217</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">218</td><td class="hits"></td><td class="source">  * @param {String} item: The expression item to check</td></tr><tr><td class="line">219</td><td class="hits"></td><td class="source">  */</td></tr><tr class="hit"><td class="line">220</td><td class="hits">87</td><td class="source">  function isHash(item) {</td></tr><tr class="hit"><td class="line">221</td><td class="hits">33</td><td class="source">    return item.indexOf('#') &gt; -1 || item.indexOf('L') &gt; 0;</td></tr><tr><td class="line">222</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">223</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">224</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">225</td><td class="hits">87</td><td class="source">  function itemSorter(a,b) {</td></tr><tr class="hit"><td class="line">226</td><td class="hits">28</td><td class="source">    return isHash(a) &amp;&amp; !isHash(b) ? 1 : 0;</td></tr><tr><td class="line">227</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">228</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">229</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">230</td><td class="hits"></td><td class="source">  * Parses each of the fields in a cron expression.  The expression must</td></tr><tr><td class="line">231</td><td class="hits"></td><td class="source">  * include the seconds field, the year field is optional.</td></tr><tr><td class="line">232</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">233</td><td class="hits"></td><td class="source">  * @param {String} expr: The cron expression to parse</td></tr><tr><td class="line">234</td><td class="hits"></td><td class="source">  */</td></tr><tr class="hit"><td class="line">235</td><td class="hits">87</td><td class="source">  function parseExpr(expr) {</td></tr><tr class="hit"><td class="line">236</td><td class="hits">87</td><td class="source">    var schedule = {schedules: [{}], exceptions: []},</td></tr><tr><td class="line">237</td><td class="hits"></td><td class="source">        components = expr.split(' '),</td></tr><tr><td class="line">238</td><td class="hits"></td><td class="source">        field, f, component, items;</td></tr><tr><td class="line">239</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">240</td><td class="hits">87</td><td class="source">    for(field in FIELDS) {</td></tr><tr class="hit"><td class="line">241</td><td class="hits">609</td><td class="source">      f = FIELDS[field];</td></tr><tr class="hit"><td class="line">242</td><td class="hits">609</td><td class="source">      component = components[f[0]];</td></tr><tr class="hit"><td class="line">243</td><td class="hits">609</td><td class="source">      if (component &amp;&amp; component !== '*' &amp;&amp; component !== '?') {</td></tr><tr><td class="line">244</td><td class="hits"></td><td class="source">        // need to sort so that any #'s come last, otherwise</td></tr><tr><td class="line">245</td><td class="hits"></td><td class="source">        // schedule clones to handle # won't contain all of the</td></tr><tr><td class="line">246</td><td class="hits"></td><td class="source">        // other constraints</td></tr><tr class="hit"><td class="line">247</td><td class="hits">125</td><td class="source">        items = component.split(',').sort(itemSorter);</td></tr><tr class="hit"><td class="line">248</td><td class="hits">125</td><td class="source">        var i, length = items.length;</td></tr><tr class="hit"><td class="line">249</td><td class="hits">125</td><td class="source">        for (i = 0; i &lt; length; i++) {</td></tr><tr class="hit"><td class="line">250</td><td class="hits">153</td><td class="source">          parse(items[i], schedule, field, f[1], f[2], f[3]);</td></tr><tr><td class="line">251</td><td class="hits"></td><td class="source">        }</td></tr><tr><td class="line">252</td><td class="hits"></td><td class="source">      }</td></tr><tr><td class="line">253</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">254</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">255</td><td class="hits">87</td><td class="source">    return schedule;</td></tr><tr><td class="line">256</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">257</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">258</td><td class="hits">87</td><td class="source">  var e = expr.toUpperCase();</td></tr><tr class="hit"><td class="line">259</td><td class="hits">87</td><td class="source">  return parseExpr(hasSeconds ? e : '0 ' + e);</td></tr><tr><td class="line">260</td><td class="hits"></td><td class="source">};</td></tr></tbody></table></div><div class="file"><h2 id="parse/parse.js">parse/parse.js</h2><div id="stats" class="high"><div class="percentage">100%</div><div class="sloc">1</div><div class="hits">1</div><div class="misses">0</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr class="hit"><td class="line">1</td><td class="hits">1</td><td class="source">later.parse = {};</td></tr></tbody></table></div><div class="file"><h2 id="parse/recur.js">parse/recur.js</h2><div id="stats" class="high"><div class="percentage">90%</div><div class="sloc">92</div><div class="hits">83</div><div class="misses">9</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source">* Simple API for generating valid schedules for Later.js.  All commands</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source">* are chainable.</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source">* Example:</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">7</td><td class="hits"></td><td class="source">* Every 5 minutes between minutes 15 and 45 of each hour and also</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source">* at 9:00 am every day, except in the months of January and February</td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source">* recur().every(5).minute().between(15, 45).and().at('09:00:00')</td></tr><tr><td class="line">11</td><td class="hits"></td><td class="source">*    .except().on(0, 1).month();</td></tr><tr><td class="line">12</td><td class="hits"></td><td class="source">*/</td></tr><tr class="hit"><td class="line">13</td><td class="hits">1</td><td class="source">later.parse.recur = function () {</td></tr><tr><td class="line">14</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">15</td><td class="hits">154</td><td class="source">  var schedules = [],</td></tr><tr><td class="line">16</td><td class="hits"></td><td class="source">      exceptions = [],</td></tr><tr><td class="line">17</td><td class="hits"></td><td class="source">      cur,</td></tr><tr><td class="line">18</td><td class="hits"></td><td class="source">      curArr = schedules,</td></tr><tr><td class="line">19</td><td class="hits"></td><td class="source">      curName,</td></tr><tr><td class="line">20</td><td class="hits"></td><td class="source">      values, every, modifier, applyMin, applyMax, i, last;</td></tr><tr><td class="line">21</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">22</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">23</td><td class="hits"></td><td class="source">  * Adds values to the specified constraint in the current schedule.</td></tr><tr><td class="line">24</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">25</td><td class="hits"></td><td class="source">  * @param {String} name: Name of constraint to add</td></tr><tr><td class="line">26</td><td class="hits"></td><td class="source">  * @param {Int} min: Minimum value for this constraint</td></tr><tr><td class="line">27</td><td class="hits"></td><td class="source">  * @param {Int} max: Maximum value for this constraint</td></tr><tr><td class="line">28</td><td class="hits"></td><td class="source">  */</td></tr><tr class="hit"><td class="line">29</td><td class="hits">154</td><td class="source">  function add(name, min, max) {</td></tr><tr class="hit"><td class="line">30</td><td class="hits">240</td><td class="source">    name = modifier ? name + '_' + modifier : name;</td></tr><tr><td class="line">31</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">32</td><td class="hits">240</td><td class="source">    if (!cur) {</td></tr><tr class="hit"><td class="line">33</td><td class="hits">162</td><td class="source">      curArr.push({});</td></tr><tr class="hit"><td class="line">34</td><td class="hits">162</td><td class="source">      cur = curArr[0];</td></tr><tr><td class="line">35</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">36</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">37</td><td class="hits">240</td><td class="source">    if (!cur[name]) {</td></tr><tr class="hit"><td class="line">38</td><td class="hits">229</td><td class="source">      cur[name] = [];</td></tr><tr><td class="line">39</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">40</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">41</td><td class="hits">240</td><td class="source">    curName = cur[name];</td></tr><tr><td class="line">42</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">43</td><td class="hits">240</td><td class="source">    if (every) {</td></tr><tr class="hit"><td class="line">44</td><td class="hits">50</td><td class="source">      values = [];</td></tr><tr class="hit"><td class="line">45</td><td class="hits">50</td><td class="source">      for (i = min; i &lt;= max; i += every) {</td></tr><tr class="hit"><td class="line">46</td><td class="hits">782</td><td class="source">        values.push(i);</td></tr><tr><td class="line">47</td><td class="hits"></td><td class="source">      }</td></tr><tr><td class="line">48</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">49</td><td class="hits"></td><td class="source">      // save off values in case of startingOn or between</td></tr><tr class="hit"><td class="line">50</td><td class="hits">50</td><td class="source">      last = {n: name, x: every, c: curName.length, m: max};</td></tr><tr><td class="line">51</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">52</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">53</td><td class="hits">240</td><td class="source">    values = applyMin ? [min] : applyMax ? [max] : values;</td></tr><tr class="hit"><td class="line">54</td><td class="hits">240</td><td class="source">    var length = values.length;</td></tr><tr class="hit"><td class="line">55</td><td class="hits">240</td><td class="source">    for (i = 0; i &lt; length; i += 1) {</td></tr><tr class="hit"><td class="line">56</td><td class="hits">1024</td><td class="source">      var val = values[i];</td></tr><tr class="hit"><td class="line">57</td><td class="hits">1024</td><td class="source">      if (curName.indexOf(val) &lt; 0) {</td></tr><tr class="hit"><td class="line">58</td><td class="hits">1024</td><td class="source">        curName.push(val);</td></tr><tr><td class="line">59</td><td class="hits"></td><td class="source">      }</td></tr><tr><td class="line">60</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">61</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">62</td><td class="hits"></td><td class="source">    // reset the built up state</td></tr><tr class="hit"><td class="line">63</td><td class="hits">240</td><td class="source">    values = every = modifier = applyMin = applyMax = 0;</td></tr><tr><td class="line">64</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">65</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">66</td><td class="hits">154</td><td class="source">  return {</td></tr><tr><td class="line">67</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">68</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">69</td><td class="hits"></td><td class="source">    * Set of constraints that must be met for an occurrence to be valid.</td></tr><tr><td class="line">70</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">71</td><td class="hits"></td><td class="source">    * @api public</td></tr><tr><td class="line">72</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">73</td><td class="hits"></td><td class="source">    schedules: schedules,</td></tr><tr><td class="line">74</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">75</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">76</td><td class="hits"></td><td class="source">    * Set of exceptions that must not be met for an occurrence to be</td></tr><tr><td class="line">77</td><td class="hits"></td><td class="source">    * valid.</td></tr><tr><td class="line">78</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">79</td><td class="hits"></td><td class="source">    * @api public</td></tr><tr><td class="line">80</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">81</td><td class="hits"></td><td class="source">    exceptions: exceptions,</td></tr><tr><td class="line">82</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">83</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">84</td><td class="hits"></td><td class="source">    * Specifies the specific instances of a time period that are valid.</td></tr><tr><td class="line">85</td><td class="hits"></td><td class="source">    * Must be followed by the desired time period (minute(), hour(),</td></tr><tr><td class="line">86</td><td class="hits"></td><td class="source">    * etc). For example, to specify a schedule for the 5th and 25th</td></tr><tr><td class="line">87</td><td class="hits"></td><td class="source">    * minute of every hour:</td></tr><tr><td class="line">88</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">89</td><td class="hits"></td><td class="source">    * recur().on(5, 25).minute();</td></tr><tr><td class="line">90</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">91</td><td class="hits"></td><td class="source">    * @param {Int} args: One or more valid instances</td></tr><tr><td class="line">92</td><td class="hits"></td><td class="source">    * @api public</td></tr><tr><td class="line">93</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">94</td><td class="hits"></td><td class="source">    on: function () {</td></tr><tr class="hit"><td class="line">95</td><td class="hits">108</td><td class="source">      values = arguments[0] instanceof Array ? arguments[0] : arguments;</td></tr><tr class="hit"><td class="line">96</td><td class="hits">108</td><td class="source">      return this;</td></tr><tr><td class="line">97</td><td class="hits"></td><td class="source">    },</td></tr><tr><td class="line">98</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">99</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">100</td><td class="hits"></td><td class="source">    * Specifies the recurring interval of a time period that are valid.</td></tr><tr><td class="line">101</td><td class="hits"></td><td class="source">    * Must be followed by the desired time period (minute(), hour(),</td></tr><tr><td class="line">102</td><td class="hits"></td><td class="source">    * etc). For example, to specify a schedule for every 4 hours in the</td></tr><tr><td class="line">103</td><td class="hits"></td><td class="source">    * day:</td></tr><tr><td class="line">104</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">105</td><td class="hits"></td><td class="source">    * recur().every(4).hour();</td></tr><tr><td class="line">106</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">107</td><td class="hits"></td><td class="source">    * @param {Int} x: Recurring interval</td></tr><tr><td class="line">108</td><td class="hits"></td><td class="source">    * @api public</td></tr><tr><td class="line">109</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">110</td><td class="hits"></td><td class="source">    every: function (x) {</td></tr><tr class="hit"><td class="line">111</td><td class="hits">42</td><td class="source">      every = x || 1;</td></tr><tr class="hit"><td class="line">112</td><td class="hits">42</td><td class="source">      return this;</td></tr><tr><td class="line">113</td><td class="hits"></td><td class="source">    },</td></tr><tr><td class="line">114</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">115</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">116</td><td class="hits"></td><td class="source">    * Specifies the minimum valid value.  For example, to specify a schedule</td></tr><tr><td class="line">117</td><td class="hits"></td><td class="source">    * that is valid for all hours after four:</td></tr><tr><td class="line">118</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">119</td><td class="hits"></td><td class="source">    * recur().after(4).hour();</td></tr><tr><td class="line">120</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">121</td><td class="hits"></td><td class="source">    * @param {Int} x: Recurring interval</td></tr><tr><td class="line">122</td><td class="hits"></td><td class="source">    * @api public</td></tr><tr><td class="line">123</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">124</td><td class="hits"></td><td class="source">    after: function (x) {</td></tr><tr class="hit"><td class="line">125</td><td class="hits">31</td><td class="source">      modifier = 'a';</td></tr><tr class="hit"><td class="line">126</td><td class="hits">31</td><td class="source">      values = [x];</td></tr><tr class="hit"><td class="line">127</td><td class="hits">31</td><td class="source">      return this;</td></tr><tr><td class="line">128</td><td class="hits"></td><td class="source">    },</td></tr><tr><td class="line">129</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">130</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">131</td><td class="hits"></td><td class="source">    * Specifies the maximum valid value.  For example, to specify a schedule</td></tr><tr><td class="line">132</td><td class="hits"></td><td class="source">    * that is valid for all hours before four:</td></tr><tr><td class="line">133</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">134</td><td class="hits"></td><td class="source">    * recur().before(4).hour();</td></tr><tr><td class="line">135</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">136</td><td class="hits"></td><td class="source">    * @param {Int} x: Recurring interval</td></tr><tr><td class="line">137</td><td class="hits"></td><td class="source">    * @api public</td></tr><tr><td class="line">138</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">139</td><td class="hits"></td><td class="source">    before: function (x) {</td></tr><tr class="hit"><td class="line">140</td><td class="hits">29</td><td class="source">      modifier = 'b';</td></tr><tr class="hit"><td class="line">141</td><td class="hits">29</td><td class="source">      values = [x];</td></tr><tr class="hit"><td class="line">142</td><td class="hits">29</td><td class="source">      return this;</td></tr><tr><td class="line">143</td><td class="hits"></td><td class="source">    },</td></tr><tr><td class="line">144</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">145</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">146</td><td class="hits"></td><td class="source">    * Specifies that the first instance of a time period is valid. Must</td></tr><tr><td class="line">147</td><td class="hits"></td><td class="source">    * be followed by the desired time period (minute(), hour(), etc).</td></tr><tr><td class="line">148</td><td class="hits"></td><td class="source">    * For example, to specify a schedule for the first day of every</td></tr><tr><td class="line">149</td><td class="hits"></td><td class="source">    * month:</td></tr><tr><td class="line">150</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">151</td><td class="hits"></td><td class="source">    * recur().first().dayOfMonth();</td></tr><tr><td class="line">152</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">153</td><td class="hits"></td><td class="source">    * @api public</td></tr><tr><td class="line">154</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">155</td><td class="hits"></td><td class="source">    first: function () {</td></tr><tr class="hit"><td class="line">156</td><td class="hits">8</td><td class="source">      applyMin = 1;</td></tr><tr class="hit"><td class="line">157</td><td class="hits">8</td><td class="source">      return this;</td></tr><tr><td class="line">158</td><td class="hits"></td><td class="source">    },</td></tr><tr><td class="line">159</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">160</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">161</td><td class="hits"></td><td class="source">    * Specifies that the last instance of a time period is valid. Must</td></tr><tr><td class="line">162</td><td class="hits"></td><td class="source">    * be followed by the desired time period (minute(), hour(), etc).</td></tr><tr><td class="line">163</td><td class="hits"></td><td class="source">    * For example, to specify a schedule for the last day of every year:</td></tr><tr><td class="line">164</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">165</td><td class="hits"></td><td class="source">    * recur().last().dayOfYear();</td></tr><tr><td class="line">166</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">167</td><td class="hits"></td><td class="source">    * @api public</td></tr><tr><td class="line">168</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">169</td><td class="hits"></td><td class="source">    last: function () {</td></tr><tr class="hit"><td class="line">170</td><td class="hits">11</td><td class="source">      applyMax = 1;</td></tr><tr class="hit"><td class="line">171</td><td class="hits">11</td><td class="source">      return this;</td></tr><tr><td class="line">172</td><td class="hits"></td><td class="source">    },</td></tr><tr><td class="line">173</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">174</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">175</td><td class="hits"></td><td class="source">    * Specifies a specific time that is valid. Time must be specified in</td></tr><tr><td class="line">176</td><td class="hits"></td><td class="source">    * hh:mm:ss format using 24 hour time. For example, to specify</td></tr><tr><td class="line">177</td><td class="hits"></td><td class="source">    * a schedule for 8:30 pm every day:</td></tr><tr><td class="line">178</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">179</td><td class="hits"></td><td class="source">    * recur().time('20:30:00');</td></tr><tr><td class="line">180</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">181</td><td class="hits"></td><td class="source">    * @param {String} time: Time in hh:mm:ss 24-hour format</td></tr><tr><td class="line">182</td><td class="hits"></td><td class="source">    * @api public</td></tr><tr><td class="line">183</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">184</td><td class="hits"></td><td class="source">    time: function () {</td></tr><tr><td class="line">185</td><td class="hits"></td><td class="source">      //values = arguments;</td></tr><tr class="hit"><td class="line">186</td><td class="hits">47</td><td class="source">      for (var i = 0, len = values.length; i &lt; len; i++) {</td></tr><tr class="hit"><td class="line">187</td><td class="hits">48</td><td class="source">        var split = values[i].split(':');</td></tr><tr class="hit"><td class="line">188</td><td class="hits">92</td><td class="source">        if(split.length &lt; 3) split.push(0);</td></tr><tr class="hit"><td class="line">189</td><td class="hits">48</td><td class="source">        values[i] = (+split[0]) * 3600 + (+split[1]) * 60 + (+split[2]);</td></tr><tr><td class="line">190</td><td class="hits"></td><td class="source">      }</td></tr><tr><td class="line">191</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">192</td><td class="hits">47</td><td class="source">      add('t');</td></tr><tr class="hit"><td class="line">193</td><td class="hits">47</td><td class="source">      return this;</td></tr><tr><td class="line">194</td><td class="hits"></td><td class="source">    },</td></tr><tr><td class="line">195</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">196</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">197</td><td class="hits"></td><td class="source">    * Seconds time period, denotes seconds within each minute.</td></tr><tr><td class="line">198</td><td class="hits"></td><td class="source">    * Minimum value is 0, maximum value is 59. Specify 59 for last.</td></tr><tr><td class="line">199</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">200</td><td class="hits"></td><td class="source">    * recur().on(5, 15, 25).second();</td></tr><tr><td class="line">201</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">202</td><td class="hits"></td><td class="source">    * @api public</td></tr><tr><td class="line">203</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">204</td><td class="hits"></td><td class="source">    second: function () {</td></tr><tr class="hit"><td class="line">205</td><td class="hits">21</td><td class="source">      add('s', 0, 59);</td></tr><tr class="hit"><td class="line">206</td><td class="hits">21</td><td class="source">      return this;</td></tr><tr><td class="line">207</td><td class="hits"></td><td class="source">    },</td></tr><tr><td class="line">208</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">209</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">210</td><td class="hits"></td><td class="source">    * Minutes time period, denotes minutes within each hour.</td></tr><tr><td class="line">211</td><td class="hits"></td><td class="source">    * Minimum value is 0, maximum value is 59. Specify 59 for last.</td></tr><tr><td class="line">212</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">213</td><td class="hits"></td><td class="source">    * recur().on(5, 15, 25).minute();</td></tr><tr><td class="line">214</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">215</td><td class="hits"></td><td class="source">    * @api public</td></tr><tr><td class="line">216</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">217</td><td class="hits"></td><td class="source">    minute: function () {</td></tr><tr class="hit"><td class="line">218</td><td class="hits">48</td><td class="source">      add('m', 0, 59);</td></tr><tr class="hit"><td class="line">219</td><td class="hits">48</td><td class="source">      return this;</td></tr><tr><td class="line">220</td><td class="hits"></td><td class="source">    },</td></tr><tr><td class="line">221</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">222</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">223</td><td class="hits"></td><td class="source">    * Hours time period, denotes hours within each day.</td></tr><tr><td class="line">224</td><td class="hits"></td><td class="source">    * Minimum value is 0, maximum value is 23. Specify 23 for last.</td></tr><tr><td class="line">225</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">226</td><td class="hits"></td><td class="source">    * recur().on(5, 15, 25).hour();</td></tr><tr><td class="line">227</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">228</td><td class="hits"></td><td class="source">    * @api public</td></tr><tr><td class="line">229</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">230</td><td class="hits"></td><td class="source">    hour: function () {</td></tr><tr class="hit"><td class="line">231</td><td class="hits">12</td><td class="source">      add('h', 0, 23);</td></tr><tr class="hit"><td class="line">232</td><td class="hits">12</td><td class="source">      return this;</td></tr><tr><td class="line">233</td><td class="hits"></td><td class="source">    },</td></tr><tr><td class="line">234</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">235</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">236</td><td class="hits"></td><td class="source">    * Days of month time period, denotes number of days within a month.</td></tr><tr><td class="line">237</td><td class="hits"></td><td class="source">    * Minimum value is 1, maximum value is 31.  Specify 0 for last.</td></tr><tr><td class="line">238</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">239</td><td class="hits"></td><td class="source">    * recur().every(2).dayOfMonth();</td></tr><tr><td class="line">240</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">241</td><td class="hits"></td><td class="source">    * @api public</td></tr><tr><td class="line">242</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">243</td><td class="hits"></td><td class="source">    dayOfMonth: function () {</td></tr><tr class="hit"><td class="line">244</td><td class="hits">20</td><td class="source">      add('D', 1, applyMax ? 0 : 31);</td></tr><tr class="hit"><td class="line">245</td><td class="hits">20</td><td class="source">      return this;</td></tr><tr><td class="line">246</td><td class="hits"></td><td class="source">    },</td></tr><tr><td class="line">247</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">248</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">249</td><td class="hits"></td><td class="source">    * Days of week time period, denotes the days within a week.</td></tr><tr><td class="line">250</td><td class="hits"></td><td class="source">    * Minimum value is 1, maximum value is 7.  Specify 0 for last.</td></tr><tr><td class="line">251</td><td class="hits"></td><td class="source">    * 1 - Sunday</td></tr><tr><td class="line">252</td><td class="hits"></td><td class="source">    * 2 - Monday</td></tr><tr><td class="line">253</td><td class="hits"></td><td class="source">    * 3 - Tuesday</td></tr><tr><td class="line">254</td><td class="hits"></td><td class="source">    * 4 - Wednesday</td></tr><tr><td class="line">255</td><td class="hits"></td><td class="source">    * 5 - Thursday</td></tr><tr><td class="line">256</td><td class="hits"></td><td class="source">    * 6 - Friday</td></tr><tr><td class="line">257</td><td class="hits"></td><td class="source">    * 7 - Saturday</td></tr><tr><td class="line">258</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">259</td><td class="hits"></td><td class="source">    * recur().on(1).dayOfWeek();</td></tr><tr><td class="line">260</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">261</td><td class="hits"></td><td class="source">    * @api public</td></tr><tr><td class="line">262</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">263</td><td class="hits"></td><td class="source">    dayOfWeek: function () {</td></tr><tr class="hit"><td class="line">264</td><td class="hits">27</td><td class="source">      add('d', 1, 7);</td></tr><tr class="hit"><td class="line">265</td><td class="hits">27</td><td class="source">      return this;</td></tr><tr><td class="line">266</td><td class="hits"></td><td class="source">    },</td></tr><tr><td class="line">267</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">268</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">269</td><td class="hits"></td><td class="source">    * Short hand for on(1,7).dayOfWeek()</td></tr><tr><td class="line">270</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">271</td><td class="hits"></td><td class="source">    * @api public</td></tr><tr><td class="line">272</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">273</td><td class="hits"></td><td class="source">    onWeekend: function() {</td></tr><tr class="hit"><td class="line">274</td><td class="hits">1</td><td class="source">      values = [1,7];</td></tr><tr class="hit"><td class="line">275</td><td class="hits">1</td><td class="source">      return this.dayOfWeek();</td></tr><tr><td class="line">276</td><td class="hits"></td><td class="source">    },</td></tr><tr><td class="line">277</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">278</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">279</td><td class="hits"></td><td class="source">    * Short hand for on(2,3,4,5,6).dayOfWeek()</td></tr><tr><td class="line">280</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">281</td><td class="hits"></td><td class="source">    * @api public</td></tr><tr><td class="line">282</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">283</td><td class="hits"></td><td class="source">    onWeekday: function() {</td></tr><tr class="hit"><td class="line">284</td><td class="hits">2</td><td class="source">      values = [2,3,4,5,6];</td></tr><tr class="hit"><td class="line">285</td><td class="hits">2</td><td class="source">      return this.dayOfWeek();</td></tr><tr><td class="line">286</td><td class="hits"></td><td class="source">    },</td></tr><tr><td class="line">287</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">288</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">289</td><td class="hits"></td><td class="source">    * Days of week count time period, denotes the number of times a</td></tr><tr><td class="line">290</td><td class="hits"></td><td class="source">    * particular day has occurred within a month.  Used to specify</td></tr><tr><td class="line">291</td><td class="hits"></td><td class="source">    * things like second Tuesday, or third Friday in a month.</td></tr><tr><td class="line">292</td><td class="hits"></td><td class="source">    * Minimum value is 1, maximum value is 5.  Specify 0 for last.</td></tr><tr><td class="line">293</td><td class="hits"></td><td class="source">    * 1 - First occurrence</td></tr><tr><td class="line">294</td><td class="hits"></td><td class="source">    * 2 - Second occurrence</td></tr><tr><td class="line">295</td><td class="hits"></td><td class="source">    * 3 - Third occurrence</td></tr><tr><td class="line">296</td><td class="hits"></td><td class="source">    * 4 - Fourth occurrence</td></tr><tr><td class="line">297</td><td class="hits"></td><td class="source">    * 5 - Fifth occurrence</td></tr><tr><td class="line">298</td><td class="hits"></td><td class="source">    * 0 - Last occurrence</td></tr><tr><td class="line">299</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">300</td><td class="hits"></td><td class="source">    * recur().on(1).dayOfWeek().on(1).dayOfWeekCount();</td></tr><tr><td class="line">301</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">302</td><td class="hits"></td><td class="source">    * @api public</td></tr><tr><td class="line">303</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">304</td><td class="hits"></td><td class="source">    dayOfWeekCount: function () {</td></tr><tr class="hit"><td class="line">305</td><td class="hits">6</td><td class="source">      add('dc', 1, applyMax ? 0 : 5);</td></tr><tr class="hit"><td class="line">306</td><td class="hits">6</td><td class="source">      return this;</td></tr><tr><td class="line">307</td><td class="hits"></td><td class="source">    },</td></tr><tr><td class="line">308</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">309</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">310</td><td class="hits"></td><td class="source">    * Days of year time period, denotes number of days within a year.</td></tr><tr><td class="line">311</td><td class="hits"></td><td class="source">    * Minimum value is 1, maximum value is 366.  Specify 0 for last.</td></tr><tr><td class="line">312</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">313</td><td class="hits"></td><td class="source">    * recur().every(2).dayOfYear();</td></tr><tr><td class="line">314</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">315</td><td class="hits"></td><td class="source">    * @api public</td></tr><tr><td class="line">316</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">317</td><td class="hits"></td><td class="source">    dayOfYear: function () {</td></tr><tr class="hit"><td class="line">318</td><td class="hits">4</td><td class="source">      add('dy', 1, applyMax ? 0 : 366);</td></tr><tr class="hit"><td class="line">319</td><td class="hits">4</td><td class="source">      return this;</td></tr><tr><td class="line">320</td><td class="hits"></td><td class="source">    },</td></tr><tr><td class="line">321</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">322</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">323</td><td class="hits"></td><td class="source">    * Weeks of month time period, denotes number of weeks within a</td></tr><tr><td class="line">324</td><td class="hits"></td><td class="source">    * month. The first week is the week that includes the 1st of the</td></tr><tr><td class="line">325</td><td class="hits"></td><td class="source">    * month. Subsequent weeks start on Sunday.</td></tr><tr><td class="line">326</td><td class="hits"></td><td class="source">    * Minimum value is 1, maximum value is 5.  Specify 0 for last.</td></tr><tr><td class="line">327</td><td class="hits"></td><td class="source">    * February 2nd,  2012 - Week 1</td></tr><tr><td class="line">328</td><td class="hits"></td><td class="source">    * February 5th,  2012 - Week 2</td></tr><tr><td class="line">329</td><td class="hits"></td><td class="source">    * February 12th, 2012 - Week 3</td></tr><tr><td class="line">330</td><td class="hits"></td><td class="source">    * February 19th, 2012 - Week 4</td></tr><tr><td class="line">331</td><td class="hits"></td><td class="source">    * February 26th, 2012 - Week 5 (or 0)</td></tr><tr><td class="line">332</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">333</td><td class="hits"></td><td class="source">    * recur().on(2).weekOfMonth();</td></tr><tr><td class="line">334</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">335</td><td class="hits"></td><td class="source">    * @api public</td></tr><tr><td class="line">336</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">337</td><td class="hits"></td><td class="source">    weekOfMonth: function () {</td></tr><tr class="hit"><td class="line">338</td><td class="hits">5</td><td class="source">      add('wm', 1, applyMax ? 0 : 5);</td></tr><tr class="hit"><td class="line">339</td><td class="hits">5</td><td class="source">      return this;</td></tr><tr><td class="line">340</td><td class="hits"></td><td class="source">    },</td></tr><tr><td class="line">341</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">342</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">343</td><td class="hits"></td><td class="source">    * Weeks of year time period, denotes the ISO 8601 week date. For</td></tr><tr><td class="line">344</td><td class="hits"></td><td class="source">    * more information see: http://en.wikipedia.org/wiki/ISO_week_date.</td></tr><tr><td class="line">345</td><td class="hits"></td><td class="source">    * Minimum value is 1, maximum value is 53.  Specify 0 for last.</td></tr><tr><td class="line">346</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">347</td><td class="hits"></td><td class="source">    * recur().every(2).weekOfYear();</td></tr><tr><td class="line">348</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">349</td><td class="hits"></td><td class="source">    * @api public</td></tr><tr><td class="line">350</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">351</td><td class="hits"></td><td class="source">    weekOfYear: function () {</td></tr><tr class="hit"><td class="line">352</td><td class="hits">12</td><td class="source">      add('wy', 1, applyMax ? 0 : 53);</td></tr><tr class="hit"><td class="line">353</td><td class="hits">12</td><td class="source">      return this;</td></tr><tr><td class="line">354</td><td class="hits"></td><td class="source">    },</td></tr><tr><td class="line">355</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">356</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">357</td><td class="hits"></td><td class="source">    * Month time period, denotes the months within a year.</td></tr><tr><td class="line">358</td><td class="hits"></td><td class="source">    * Minimum value is 1, maximum value is 12.  Specify 0 for last.</td></tr><tr><td class="line">359</td><td class="hits"></td><td class="source">    * 1 - January</td></tr><tr><td class="line">360</td><td class="hits"></td><td class="source">    * 2 - February</td></tr><tr><td class="line">361</td><td class="hits"></td><td class="source">    * 3 - March</td></tr><tr><td class="line">362</td><td class="hits"></td><td class="source">    * 4 - April</td></tr><tr><td class="line">363</td><td class="hits"></td><td class="source">    * 5 - May</td></tr><tr><td class="line">364</td><td class="hits"></td><td class="source">    * 6 - June</td></tr><tr><td class="line">365</td><td class="hits"></td><td class="source">    * 7 - July</td></tr><tr><td class="line">366</td><td class="hits"></td><td class="source">    * 8 - August</td></tr><tr><td class="line">367</td><td class="hits"></td><td class="source">    * 9 - September</td></tr><tr><td class="line">368</td><td class="hits"></td><td class="source">    * 10 - October</td></tr><tr><td class="line">369</td><td class="hits"></td><td class="source">    * 11 - November</td></tr><tr><td class="line">370</td><td class="hits"></td><td class="source">    * 12 - December</td></tr><tr><td class="line">371</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">372</td><td class="hits"></td><td class="source">    * recur().on(1).dayOfWeek();</td></tr><tr><td class="line">373</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">374</td><td class="hits"></td><td class="source">    * @api public</td></tr><tr><td class="line">375</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">376</td><td class="hits"></td><td class="source">    month: function () {</td></tr><tr class="hit"><td class="line">377</td><td class="hits">17</td><td class="source">      add('M', 1, 12);</td></tr><tr class="hit"><td class="line">378</td><td class="hits">17</td><td class="source">      return this;</td></tr><tr><td class="line">379</td><td class="hits"></td><td class="source">    },</td></tr><tr><td class="line">380</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">381</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">382</td><td class="hits"></td><td class="source">    * Year time period, denotes the four digit year.</td></tr><tr><td class="line">383</td><td class="hits"></td><td class="source">    * Minimum value is 1970, maximum value is Jan 1, 2100 (arbitrary)</td></tr><tr><td class="line">384</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">385</td><td class="hits"></td><td class="source">    * recur().on(2011, 2012, 2013).year();</td></tr><tr><td class="line">386</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">387</td><td class="hits"></td><td class="source">    * @api public</td></tr><tr><td class="line">388</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">389</td><td class="hits"></td><td class="source">    year: function () {</td></tr><tr class="hit"><td class="line">390</td><td class="hits">11</td><td class="source">      add('Y', 1970, 2450);</td></tr><tr class="hit"><td class="line">391</td><td class="hits">11</td><td class="source">      return this;</td></tr><tr><td class="line">392</td><td class="hits"></td><td class="source">    },</td></tr><tr><td class="line">393</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">394</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">395</td><td class="hits"></td><td class="source">    * Full date period, denotes a full date and time.</td></tr><tr><td class="line">396</td><td class="hits"></td><td class="source">    * Minimum value is Jan 1, 1970, maximum value is Jan 1, 2100 (arbitrary)</td></tr><tr><td class="line">397</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">398</td><td class="hits"></td><td class="source">    * recur().on(new Date(2013, 3, 2, 10, 30, 0)).fullDate();</td></tr><tr><td class="line">399</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">400</td><td class="hits"></td><td class="source">    * @api public</td></tr><tr><td class="line">401</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">402</td><td class="hits"></td><td class="source">    fullDate: function () {</td></tr><tr class="hit"><td class="line">403</td><td class="hits">2</td><td class="source">      for (var i = 0, len = values.length; i &lt; len; i++) {</td></tr><tr class="hit"><td class="line">404</td><td class="hits">2</td><td class="source">        values[i] = values[i].getTime();</td></tr><tr><td class="line">405</td><td class="hits"></td><td class="source">      }</td></tr><tr><td class="line">406</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">407</td><td class="hits">2</td><td class="source">      add('fd');</td></tr><tr class="hit"><td class="line">408</td><td class="hits">2</td><td class="source">      return this;</td></tr><tr><td class="line">409</td><td class="hits"></td><td class="source">    },</td></tr><tr><td class="line">410</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">411</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">412</td><td class="hits"></td><td class="source">    * Custom modifier.</td></tr><tr><td class="line">413</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">414</td><td class="hits"></td><td class="source">    * recur().on(2011, 2012, 2013).custom('partOfDay');</td></tr><tr><td class="line">415</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">416</td><td class="hits"></td><td class="source">    * @api public</td></tr><tr><td class="line">417</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">418</td><td class="hits"></td><td class="source">    customModifier: function (id, vals) {</td></tr><tr class="miss"><td class="line">419</td><td class="hits">0</td><td class="source">      var custom = later.modifier[id];</td></tr><tr class="miss"><td class="line">420</td><td class="hits">0</td><td class="source">      if(!custom) throw new Error('Custom modifier ' + id + ' not recognized!');</td></tr><tr><td class="line">421</td><td class="hits"></td><td class="source"> </td></tr><tr class="miss"><td class="line">422</td><td class="hits">0</td><td class="source">      modifier = id;</td></tr><tr class="miss"><td class="line">423</td><td class="hits">0</td><td class="source">      values = arguments[1] instanceof Array ? arguments[1] : [arguments[1]];</td></tr><tr class="miss"><td class="line">424</td><td class="hits">0</td><td class="source">      return this;</td></tr><tr><td class="line">425</td><td class="hits"></td><td class="source">    },</td></tr><tr><td class="line">426</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">427</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">428</td><td class="hits"></td><td class="source">    * Custom time period.</td></tr><tr><td class="line">429</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">430</td><td class="hits"></td><td class="source">    * recur().on(2011, 2012, 2013).customPeriod('partOfDay');</td></tr><tr><td class="line">431</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">432</td><td class="hits"></td><td class="source">    * @api public</td></tr><tr><td class="line">433</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">434</td><td class="hits"></td><td class="source">    customPeriod: function (id) {</td></tr><tr class="miss"><td class="line">435</td><td class="hits">0</td><td class="source">      var custom = later[id];</td></tr><tr class="miss"><td class="line">436</td><td class="hits">0</td><td class="source">      if(!custom) throw new Error('Custom time period ' + id + ' not recognized!');</td></tr><tr><td class="line">437</td><td class="hits"></td><td class="source"> </td></tr><tr class="miss"><td class="line">438</td><td class="hits">0</td><td class="source">      add(id, custom.extent(new Date())[0], custom.extent(new Date())[1]);</td></tr><tr class="miss"><td class="line">439</td><td class="hits">0</td><td class="source">      return this;</td></tr><tr><td class="line">440</td><td class="hits"></td><td class="source">    },</td></tr><tr><td class="line">441</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">442</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">443</td><td class="hits"></td><td class="source">    * Modifies a recurring interval (specified using every) to start</td></tr><tr><td class="line">444</td><td class="hits"></td><td class="source">    * at a given offset.  To create a schedule for every 5 minutes</td></tr><tr><td class="line">445</td><td class="hits"></td><td class="source">    * starting on the 6th minute - making minutes 6, 11, 16, etc valid:</td></tr><tr><td class="line">446</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">447</td><td class="hits"></td><td class="source">    * recur().every(5).minute().startingOn(6);</td></tr><tr><td class="line">448</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">449</td><td class="hits"></td><td class="source">    * @param {Int} start: The desired starting offset</td></tr><tr><td class="line">450</td><td class="hits"></td><td class="source">    * @api public</td></tr><tr><td class="line">451</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">452</td><td class="hits"></td><td class="source">    startingOn: function (start) {</td></tr><tr class="hit"><td class="line">453</td><td class="hits">4</td><td class="source">      return this.between(start, last.m);</td></tr><tr><td class="line">454</td><td class="hits"></td><td class="source">    },</td></tr><tr><td class="line">455</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">456</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">457</td><td class="hits"></td><td class="source">    * Modifies a recurring interval (specified using every) to start</td></tr><tr><td class="line">458</td><td class="hits"></td><td class="source">    * and stop at specified times.  To create a schedule for every</td></tr><tr><td class="line">459</td><td class="hits"></td><td class="source">    * 5 minutes starting on the 6th minute and ending on the 11th</td></tr><tr><td class="line">460</td><td class="hits"></td><td class="source">    * minute - making minutes 6 and 11 valid:</td></tr><tr><td class="line">461</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">462</td><td class="hits"></td><td class="source">    * recur().every(5).minute().between(6, 11);</td></tr><tr><td class="line">463</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">464</td><td class="hits"></td><td class="source">    * @param {Int} start: The desired starting offset</td></tr><tr><td class="line">465</td><td class="hits"></td><td class="source">    * @param {Int} end: The last valid value</td></tr><tr><td class="line">466</td><td class="hits"></td><td class="source">    * @api public</td></tr><tr><td class="line">467</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">468</td><td class="hits"></td><td class="source">    between: function (start, end) {</td></tr><tr><td class="line">469</td><td class="hits"></td><td class="source">      // remove the values added as part of specifying the last</td></tr><tr><td class="line">470</td><td class="hits"></td><td class="source">      // time period and replace them with the new restricted values</td></tr><tr class="hit"><td class="line">471</td><td class="hits">8</td><td class="source">      cur[last.n] = cur[last.n].splice(0, last.c);</td></tr><tr class="hit"><td class="line">472</td><td class="hits">8</td><td class="source">      every = last.x;</td></tr><tr class="hit"><td class="line">473</td><td class="hits">8</td><td class="source">      add(last.n, start, end);</td></tr><tr class="hit"><td class="line">474</td><td class="hits">8</td><td class="source">      return this;</td></tr><tr><td class="line">475</td><td class="hits"></td><td class="source">    },</td></tr><tr><td class="line">476</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">477</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">478</td><td class="hits"></td><td class="source">    * Creates a composite schedule.  With a composite schedule, a valid</td></tr><tr><td class="line">479</td><td class="hits"></td><td class="source">    * occurrence of any of the component schedules is considered a valid</td></tr><tr><td class="line">480</td><td class="hits"></td><td class="source">    * value for the composite schedule (e.g. they are OR'ed together).</td></tr><tr><td class="line">481</td><td class="hits"></td><td class="source">    * To create a schedule for every 5 minutes on Mondays and every 10</td></tr><tr><td class="line">482</td><td class="hits"></td><td class="source">    * minutes on Tuesdays:</td></tr><tr><td class="line">483</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">484</td><td class="hits"></td><td class="source">    * recur().every(5).minutes().on(1).dayOfWeek().and().every(10)</td></tr><tr><td class="line">485</td><td class="hits"></td><td class="source">    *    .minutes().on(2).dayOfWeek();</td></tr><tr><td class="line">486</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">487</td><td class="hits"></td><td class="source">    * @api public</td></tr><tr><td class="line">488</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">489</td><td class="hits"></td><td class="source">    and: function () {</td></tr><tr class="hit"><td class="line">490</td><td class="hits">15</td><td class="source">      cur = curArr[curArr.push({}) - 1];</td></tr><tr class="hit"><td class="line">491</td><td class="hits">15</td><td class="source">      return this;</td></tr><tr><td class="line">492</td><td class="hits"></td><td class="source">    },</td></tr><tr><td class="line">493</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">494</td><td class="hits"></td><td class="source">    /**</td></tr><tr><td class="line">495</td><td class="hits"></td><td class="source">    * Creates exceptions to a schedule. Any valid occurrence of the</td></tr><tr><td class="line">496</td><td class="hits"></td><td class="source">    * exception schedule (which may also be composite schedules) is</td></tr><tr><td class="line">497</td><td class="hits"></td><td class="source">    * considered a invalid schedule occurrence. Everything that follows</td></tr><tr><td class="line">498</td><td class="hits"></td><td class="source">    * except will be treated as an exception schedule.  To create a</td></tr><tr><td class="line">499</td><td class="hits"></td><td class="source">    * schedule for 8:00 am every Tuesday except for patch Tuesday</td></tr><tr><td class="line">500</td><td class="hits"></td><td class="source">    * (second Tuesday each month):</td></tr><tr><td class="line">501</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">502</td><td class="hits"></td><td class="source">    * recur().at('08:00:00').on(2).dayOfWeek().except()</td></tr><tr><td class="line">503</td><td class="hits"></td><td class="source">    *    .dayOfWeekCount(1);</td></tr><tr><td class="line">504</td><td class="hits"></td><td class="source">    *</td></tr><tr><td class="line">505</td><td class="hits"></td><td class="source">    * @api public</td></tr><tr><td class="line">506</td><td class="hits"></td><td class="source">    */</td></tr><tr><td class="line">507</td><td class="hits"></td><td class="source">    except: function () {</td></tr><tr class="hit"><td class="line">508</td><td class="hits">10</td><td class="source">      curArr = exceptions;</td></tr><tr class="hit"><td class="line">509</td><td class="hits">10</td><td class="source">      cur = null;</td></tr><tr class="hit"><td class="line">510</td><td class="hits">10</td><td class="source">      return this;</td></tr><tr><td class="line">511</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">512</td><td class="hits"></td><td class="source">  };</td></tr><tr><td class="line">513</td><td class="hits"></td><td class="source">};</td></tr></tbody></table></div><div class="file"><h2 id="parse/text.js">parse/text.js</h2><div id="stats" class="high"><div class="percentage">99%</div><div class="sloc">156</div><div class="hits">155</div><div class="misses">1</div></div><table id="source"><thead><tr><th>Line</th><th>Hits</th><th>Source</th></tr></thead><tbody><tr><td class="line">1</td><td class="hits"></td><td class="source">/**</td></tr><tr><td class="line">2</td><td class="hits"></td><td class="source">* Parses an English string expression and produces a schedule that is</td></tr><tr><td class="line">3</td><td class="hits"></td><td class="source">* compatible with Later.js.</td></tr><tr><td class="line">4</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">5</td><td class="hits"></td><td class="source">* Examples:</td></tr><tr><td class="line">6</td><td class="hits"></td><td class="source">*</td></tr><tr><td class="line">7</td><td class="hits"></td><td class="source">* every 5 minutes between the 1st and 30th minute</td></tr><tr><td class="line">8</td><td class="hits"></td><td class="source">* at 10:00 am on tues of may in 2012</td></tr><tr><td class="line">9</td><td class="hits"></td><td class="source">* on the 15-20th day of march-dec</td></tr><tr><td class="line">10</td><td class="hits"></td><td class="source">* every 20 seconds every 5 minutes every 4 hours between the 10th and 20th hour</td></tr><tr><td class="line">11</td><td class="hits"></td><td class="source">*/</td></tr><tr class="hit"><td class="line">12</td><td class="hits">1</td><td class="source">later.parse.text = function(str) {</td></tr><tr><td class="line">13</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">14</td><td class="hits">95</td><td class="source">  var recur = later.parse.recur,</td></tr><tr><td class="line">15</td><td class="hits"></td><td class="source">      pos = 0,</td></tr><tr><td class="line">16</td><td class="hits"></td><td class="source">      input = '',</td></tr><tr><td class="line">17</td><td class="hits"></td><td class="source">      error;</td></tr><tr><td class="line">18</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">19</td><td class="hits"></td><td class="source">  // Regex expressions for all of the valid tokens</td></tr><tr class="hit"><td class="line">20</td><td class="hits">95</td><td class="source">  var TOKENTYPES = {</td></tr><tr><td class="line">21</td><td class="hits"></td><td class="source">        eof: /^$/,</td></tr><tr><td class="line">22</td><td class="hits"></td><td class="source">        rank: /^((\d\d\d\d)|([2-5]?1(st)?|[2-5]?2(nd)?|[2-5]?3(rd)?|(0|[1-5]?[4-9]|[1-5]0|1[1-3])(th)?))\b/,</td></tr><tr><td class="line">23</td><td class="hits"></td><td class="source">        time: /^((([0]?[1-9]|1[0-2]):[0-5]\d(\s)?(am|pm))|(([0]?\d|1\d|2[0-3]):[0-5]\d))\b/,</td></tr><tr><td class="line">24</td><td class="hits"></td><td class="source">        dayName: /^((sun|mon|tue(s)?|wed(nes)?|thu(r(s)?)?|fri|sat(ur)?)(day)?)\b/,</td></tr><tr><td class="line">25</td><td class="hits"></td><td class="source">        monthName: /^(jan(uary)?|feb(ruary)?|ma((r(ch)?)?|y)|apr(il)?|ju(ly|ne)|aug(ust)?|oct(ober)?|(sept|nov|dec)(ember)?)\b/,</td></tr><tr><td class="line">26</td><td class="hits"></td><td class="source">        yearIndex: /^(\d\d\d\d)\b/,</td></tr><tr><td class="line">27</td><td class="hits"></td><td class="source">        every: /^every\b/,</td></tr><tr><td class="line">28</td><td class="hits"></td><td class="source">        after: /^after\b/,</td></tr><tr><td class="line">29</td><td class="hits"></td><td class="source">        before: /^before\b/,</td></tr><tr><td class="line">30</td><td class="hits"></td><td class="source">        second: /^(s|sec(ond)?(s)?)\b/,</td></tr><tr><td class="line">31</td><td class="hits"></td><td class="source">        minute: /^(m|min(ute)?(s)?)\b/,</td></tr><tr><td class="line">32</td><td class="hits"></td><td class="source">        hour: /^(h|hour(s)?)\b/,</td></tr><tr><td class="line">33</td><td class="hits"></td><td class="source">        day: /^(day(s)?( of the month)?)\b/,</td></tr><tr><td class="line">34</td><td class="hits"></td><td class="source">        dayInstance: /^day instance\b/,</td></tr><tr><td class="line">35</td><td class="hits"></td><td class="source">        dayOfWeek: /^day(s)? of the week\b/,</td></tr><tr><td class="line">36</td><td class="hits"></td><td class="source">        dayOfYear: /^day(s)? of the year\b/,</td></tr><tr><td class="line">37</td><td class="hits"></td><td class="source">        weekOfYear: /^week(s)?( of the year)?\b/,</td></tr><tr><td class="line">38</td><td class="hits"></td><td class="source">        weekOfMonth: /^week(s)? of the month\b/,</td></tr><tr><td class="line">39</td><td class="hits"></td><td class="source">        weekday: /^weekday\b/,</td></tr><tr><td class="line">40</td><td class="hits"></td><td class="source">        weekend: /^weekend\b/,</td></tr><tr><td class="line">41</td><td class="hits"></td><td class="source">        month: /^month(s)?\b/,</td></tr><tr><td class="line">42</td><td class="hits"></td><td class="source">        year: /^year(s)?\b/,</td></tr><tr><td class="line">43</td><td class="hits"></td><td class="source">        between: /^between (the)?\b/,</td></tr><tr><td class="line">44</td><td class="hits"></td><td class="source">        start: /^(start(ing)? (at|on( the)?)?)\b/,</td></tr><tr><td class="line">45</td><td class="hits"></td><td class="source">        at: /^(at|@)\b/,</td></tr><tr><td class="line">46</td><td class="hits"></td><td class="source">        and: /^(,|and\b)/,</td></tr><tr><td class="line">47</td><td class="hits"></td><td class="source">        except: /^(except\b)/,</td></tr><tr><td class="line">48</td><td class="hits"></td><td class="source">        also: /(also)\b/,</td></tr><tr><td class="line">49</td><td class="hits"></td><td class="source">        first: /^(first)\b/,</td></tr><tr><td class="line">50</td><td class="hits"></td><td class="source">        last: /^last\b/,</td></tr><tr><td class="line">51</td><td class="hits"></td><td class="source">        &quot;in&quot;: /^in\b/,</td></tr><tr><td class="line">52</td><td class="hits"></td><td class="source">        of: /^of\b/,</td></tr><tr><td class="line">53</td><td class="hits"></td><td class="source">        onthe: /^on the\b/,</td></tr><tr><td class="line">54</td><td class="hits"></td><td class="source">        on: /^on\b/,</td></tr><tr><td class="line">55</td><td class="hits"></td><td class="source">        through: /(-|^(to|through)\b)/</td></tr><tr><td class="line">56</td><td class="hits"></td><td class="source">      };</td></tr><tr><td class="line">57</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">58</td><td class="hits"></td><td class="source">  // Array to convert string names to valid numerical values</td></tr><tr class="hit"><td class="line">59</td><td class="hits">95</td><td class="source">  var NAMES = { jan: 1, feb: 2, mar: 3, apr: 4, may: 5, jun: 6, jul: 7,</td></tr><tr><td class="line">60</td><td class="hits"></td><td class="source">        aug: 8, sep: 9, oct: 10, nov: 11, dec: 12, sun: 1, mon: 2, tue: 3,</td></tr><tr><td class="line">61</td><td class="hits"></td><td class="source">        wed: 4, thu: 5, fri: 6, sat: 7, '1st': 1, fir: 1, '2nd': 2, sec: 2,</td></tr><tr><td class="line">62</td><td class="hits"></td><td class="source">        '3rd': 3, thi: 3, '4th': 4, 'for': 4</td></tr><tr><td class="line">63</td><td class="hits"></td><td class="source">      };</td></tr><tr><td class="line">64</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">65</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">66</td><td class="hits"></td><td class="source">  * Bundles up the results of the peek operation into a token.</td></tr><tr><td class="line">67</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">68</td><td class="hits"></td><td class="source">  * @param {Int} start: The start position of the token</td></tr><tr><td class="line">69</td><td class="hits"></td><td class="source">  * @param {Int} end: The end position of the token</td></tr><tr><td class="line">70</td><td class="hits"></td><td class="source">  * @param {String} text: The actual text that was parsed</td></tr><tr><td class="line">71</td><td class="hits"></td><td class="source">  * @param {TokenType} type: The TokenType of the token</td></tr><tr><td class="line">72</td><td class="hits"></td><td class="source">  */</td></tr><tr class="hit"><td class="line">73</td><td class="hits">95</td><td class="source">  function t(start, end, text, type) {</td></tr><tr class="hit"><td class="line">74</td><td class="hits">1980</td><td class="source">    return {startPos: start, endPos: end, text: text, type: type};</td></tr><tr><td class="line">75</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">76</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">77</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">78</td><td class="hits"></td><td class="source">  * Peeks forward to see if the next token is the expected token and</td></tr><tr><td class="line">79</td><td class="hits"></td><td class="source">  * returns the token if found.  Pos is not moved during a Peek operation.</td></tr><tr><td class="line">80</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">81</td><td class="hits"></td><td class="source">  * @param {TokenType} exepected: The types of token to scan for</td></tr><tr><td class="line">82</td><td class="hits"></td><td class="source">  */</td></tr><tr class="hit"><td class="line">83</td><td class="hits">95</td><td class="source">  function peek(expected) {</td></tr><tr class="hit"><td class="line">84</td><td class="hits">658</td><td class="source">    var scanTokens = expected instanceof Array ? expected : [expected],</td></tr><tr><td class="line">85</td><td class="hits"></td><td class="source">        whiteSpace = /\s+/,</td></tr><tr><td class="line">86</td><td class="hits"></td><td class="source">        token, curInput, m, scanToken, start, len;</td></tr><tr><td class="line">87</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">88</td><td class="hits">658</td><td class="source">    scanTokens.push(whiteSpace);</td></tr><tr><td class="line">89</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">90</td><td class="hits"></td><td class="source">    // loop past any skipped tokens and only look for expected tokens</td></tr><tr class="hit"><td class="line">91</td><td class="hits">658</td><td class="source">    start = pos;</td></tr><tr class="hit"><td class="line">92</td><td class="hits">658</td><td class="source">    while (!token || token.type === whiteSpace) {</td></tr><tr class="hit"><td class="line">93</td><td class="hits">1112</td><td class="source">      len = -1;</td></tr><tr class="hit"><td class="line">94</td><td class="hits">1112</td><td class="source">      curInput = input.substring(start);</td></tr><tr class="hit"><td class="line">95</td><td class="hits">1112</td><td class="source">      token = t(start, start, input.split(whiteSpace)[0]);</td></tr><tr><td class="line">96</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">97</td><td class="hits">1112</td><td class="source">      var i, length = scanTokens.length;</td></tr><tr class="hit"><td class="line">98</td><td class="hits">1112</td><td class="source">      for(i = 0; i &lt; length; i++) {</td></tr><tr class="hit"><td class="line">99</td><td class="hits">5424</td><td class="source">        scanToken = scanTokens[i];</td></tr><tr class="hit"><td class="line">100</td><td class="hits">5424</td><td class="source">        m = scanToken.exec(curInput);</td></tr><tr class="hit"><td class="line">101</td><td class="hits">5424</td><td class="source">        if (m &amp;&amp; m.index === 0 &amp;&amp; m[0].length &gt; len) {</td></tr><tr class="hit"><td class="line">102</td><td class="hits">868</td><td class="source">          len = m[0].length;</td></tr><tr class="hit"><td class="line">103</td><td class="hits">868</td><td class="source">          token = t(start, start + len, curInput.substring(0, len), scanToken);</td></tr><tr><td class="line">104</td><td class="hits"></td><td class="source">        }</td></tr><tr><td class="line">105</td><td class="hits"></td><td class="source">      }</td></tr><tr><td class="line">106</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">107</td><td class="hits"></td><td class="source">      // update the start position if this token should be skipped</td></tr><tr class="hit"><td class="line">108</td><td class="hits">1112</td><td class="source">      if (token.type === whiteSpace) {</td></tr><tr class="hit"><td class="line">109</td><td class="hits">454</td><td class="source">        start = token.endPos;</td></tr><tr><td class="line">110</td><td class="hits"></td><td class="source">      }</td></tr><tr><td class="line">111</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">112</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">113</td><td class="hits">658</td><td class="source">    return token;</td></tr><tr><td class="line">114</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">115</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">116</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">117</td><td class="hits"></td><td class="source">  * Moves pos to the end of the expectedToken if it is found.</td></tr><tr><td class="line">118</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">119</td><td class="hits"></td><td class="source">  * @param {TokenType} exepectedToken: The types of token to scan for</td></tr><tr><td class="line">120</td><td class="hits"></td><td class="source">  */</td></tr><tr class="hit"><td class="line">121</td><td class="hits">95</td><td class="source">  function scan(expectedToken) {</td></tr><tr class="hit"><td class="line">122</td><td class="hits">376</td><td class="source">    var token = peek(expectedToken);</td></tr><tr class="hit"><td class="line">123</td><td class="hits">376</td><td class="source">    pos = token.endPos;</td></tr><tr class="hit"><td class="line">124</td><td class="hits">376</td><td class="source">    return token;</td></tr><tr><td class="line">125</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">126</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">127</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">128</td><td class="hits"></td><td class="source">  * Parses the next 'y-z' expression and returns the resulting valid</td></tr><tr><td class="line">129</td><td class="hits"></td><td class="source">  * value array.</td></tr><tr><td class="line">130</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">131</td><td class="hits"></td><td class="source">  * @param {TokenType} tokenType: The type of range values allowed</td></tr><tr><td class="line">132</td><td class="hits"></td><td class="source">  */</td></tr><tr class="hit"><td class="line">133</td><td class="hits">95</td><td class="source">  function parseThroughExpr(tokenType) {</td></tr><tr class="hit"><td class="line">134</td><td class="hits">44</td><td class="source">    var start = +parseTokenValue(tokenType),</td></tr><tr><td class="line">135</td><td class="hits"></td><td class="source">        end = checkAndParse(TOKENTYPES.through) ? +parseTokenValue(tokenType) : start,</td></tr><tr><td class="line">136</td><td class="hits"></td><td class="source">        nums = [];</td></tr><tr><td class="line">137</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">138</td><td class="hits">44</td><td class="source">    for (var i = start; i &lt;= end; i++) {</td></tr><tr class="hit"><td class="line">139</td><td class="hits">62</td><td class="source">      nums.push(i);</td></tr><tr><td class="line">140</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">141</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">142</td><td class="hits">44</td><td class="source">    return nums;</td></tr><tr><td class="line">143</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">144</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">145</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">146</td><td class="hits"></td><td class="source">  * Parses the next 'x,y-z' expression and returns the resulting valid</td></tr><tr><td class="line">147</td><td class="hits"></td><td class="source">  * value array.</td></tr><tr><td class="line">148</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">149</td><td class="hits"></td><td class="source">  * @param {TokenType} tokenType: The type of range values allowed</td></tr><tr><td class="line">150</td><td class="hits"></td><td class="source">  */</td></tr><tr class="hit"><td class="line">151</td><td class="hits">95</td><td class="source">  function parseRanges(tokenType) {</td></tr><tr class="hit"><td class="line">152</td><td class="hits">35</td><td class="source">    var nums = parseThroughExpr(tokenType);</td></tr><tr class="hit"><td class="line">153</td><td class="hits">35</td><td class="source">    while (checkAndParse(TOKENTYPES.and)) {</td></tr><tr class="hit"><td class="line">154</td><td class="hits">9</td><td class="source">      nums = nums.concat(parseThroughExpr(tokenType));</td></tr><tr><td class="line">155</td><td class="hits"></td><td class="source">    }</td></tr><tr class="hit"><td class="line">156</td><td class="hits">35</td><td class="source">    return nums;</td></tr><tr><td class="line">157</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">158</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">159</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">160</td><td class="hits"></td><td class="source">  * Parses the next 'every (weekend|weekday|x) (starting on|between)' expression.</td></tr><tr><td class="line">161</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">162</td><td class="hits"></td><td class="source">  * @param {Recur} r: The recurrence to add the expression to</td></tr><tr><td class="line">163</td><td class="hits"></td><td class="source">  */</td></tr><tr class="hit"><td class="line">164</td><td class="hits">95</td><td class="source">  function parseEvery(r) {</td></tr><tr class="hit"><td class="line">165</td><td class="hits">22</td><td class="source">    var num, period, start, end;</td></tr><tr><td class="line">166</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">167</td><td class="hits">22</td><td class="source">    if (checkAndParse(TOKENTYPES.weekend)) {</td></tr><tr class="hit"><td class="line">168</td><td class="hits">1</td><td class="source">      r.on(NAMES.sun,NAMES.sat).dayOfWeek();</td></tr><tr><td class="line">169</td><td class="hits"></td><td class="source">    }</td></tr><tr class="hit"><td class="line">170</td><td class="hits">21</td><td class="source">    else if (checkAndParse(TOKENTYPES.weekday)) {</td></tr><tr class="hit"><td class="line">171</td><td class="hits">2</td><td class="source">      r.on(NAMES.mon,NAMES.tue,NAMES.wed,NAMES.thu,NAMES.fri).dayOfWeek();</td></tr><tr><td class="line">172</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">173</td><td class="hits"></td><td class="source">    else {</td></tr><tr class="hit"><td class="line">174</td><td class="hits">19</td><td class="source">      num = parseTokenValue(TOKENTYPES.rank);</td></tr><tr class="hit"><td class="line">175</td><td class="hits">19</td><td class="source">      r.every(num);</td></tr><tr class="hit"><td class="line">176</td><td class="hits">19</td><td class="source">      period = parseTimePeriod(r);</td></tr><tr><td class="line">177</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">178</td><td class="hits">19</td><td class="source">      if (checkAndParse(TOKENTYPES.start)) {</td></tr><tr class="hit"><td class="line">179</td><td class="hits">1</td><td class="source">        num = parseTokenValue(TOKENTYPES.rank);</td></tr><tr class="hit"><td class="line">180</td><td class="hits">1</td><td class="source">        r.startingOn(num);</td></tr><tr class="hit"><td class="line">181</td><td class="hits">1</td><td class="source">        parseToken(period.type);</td></tr><tr><td class="line">182</td><td class="hits"></td><td class="source">      }</td></tr><tr class="hit"><td class="line">183</td><td class="hits">18</td><td class="source">      else if (checkAndParse(TOKENTYPES.between)) {</td></tr><tr class="hit"><td class="line">184</td><td class="hits">1</td><td class="source">        start = parseTokenValue(TOKENTYPES.rank);</td></tr><tr class="hit"><td class="line">185</td><td class="hits">1</td><td class="source">        if (checkAndParse(TOKENTYPES.and)) {</td></tr><tr class="hit"><td class="line">186</td><td class="hits">1</td><td class="source">          end = parseTokenValue(TOKENTYPES.rank);</td></tr><tr class="hit"><td class="line">187</td><td class="hits">1</td><td class="source">          r.between(start,end);</td></tr><tr><td class="line">188</td><td class="hits"></td><td class="source">        }</td></tr><tr><td class="line">189</td><td class="hits"></td><td class="source">      }</td></tr><tr><td class="line">190</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">191</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">192</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">193</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">194</td><td class="hits"></td><td class="source">  * Parses the next 'on the (first|last|x,y-z)' expression.</td></tr><tr><td class="line">195</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">196</td><td class="hits"></td><td class="source">  * @param {Recur} r: The recurrence to add the expression to</td></tr><tr><td class="line">197</td><td class="hits"></td><td class="source">  */</td></tr><tr class="hit"><td class="line">198</td><td class="hits">95</td><td class="source">  function parseOnThe(r) {</td></tr><tr class="hit"><td class="line">199</td><td class="hits">23</td><td class="source">    if (checkAndParse(TOKENTYPES.first)) {</td></tr><tr class="hit"><td class="line">200</td><td class="hits">1</td><td class="source">      r.first();</td></tr><tr><td class="line">201</td><td class="hits"></td><td class="source">    }</td></tr><tr class="hit"><td class="line">202</td><td class="hits">22</td><td class="source">    else if (checkAndParse(TOKENTYPES.last)) {</td></tr><tr class="hit"><td class="line">203</td><td class="hits">4</td><td class="source">      r.last();</td></tr><tr><td class="line">204</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">205</td><td class="hits"></td><td class="source">    else {</td></tr><tr class="hit"><td class="line">206</td><td class="hits">18</td><td class="source">      r.on(parseRanges(TOKENTYPES.rank));</td></tr><tr><td class="line">207</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">208</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">209</td><td class="hits">23</td><td class="source">    parseTimePeriod(r);</td></tr><tr><td class="line">210</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">211</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">212</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">213</td><td class="hits"></td><td class="source">  * Parses the schedule expression and returns the resulting schedules,</td></tr><tr><td class="line">214</td><td class="hits"></td><td class="source">  * and exceptions.  Error will return the position in the string where</td></tr><tr><td class="line">215</td><td class="hits"></td><td class="source">  * an error occurred, will be null if no errors were found in the</td></tr><tr><td class="line">216</td><td class="hits"></td><td class="source">  * expression.</td></tr><tr><td class="line">217</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">218</td><td class="hits"></td><td class="source">  * @param {String} str: The schedule expression to parse</td></tr><tr><td class="line">219</td><td class="hits"></td><td class="source">  */</td></tr><tr class="hit"><td class="line">220</td><td class="hits">95</td><td class="source">  function parseScheduleExpr(str) {</td></tr><tr class="hit"><td class="line">221</td><td class="hits">95</td><td class="source">    pos = 0;</td></tr><tr class="hit"><td class="line">222</td><td class="hits">95</td><td class="source">    input = str;</td></tr><tr class="hit"><td class="line">223</td><td class="hits">95</td><td class="source">    error = -1;</td></tr><tr><td class="line">224</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">225</td><td class="hits">95</td><td class="source">    var r = recur();</td></tr><tr class="hit"><td class="line">226</td><td class="hits">95</td><td class="source">    while (pos &lt; input.length &amp;&amp; error &lt; 0) {</td></tr><tr><td class="line">227</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">228</td><td class="hits">138</td><td class="source">      var token = parseToken([TOKENTYPES.every, TOKENTYPES.after, TOKENTYPES.before,</td></tr><tr><td class="line">229</td><td class="hits"></td><td class="source">            TOKENTYPES.onthe, TOKENTYPES.on, TOKENTYPES.of, TOKENTYPES[&quot;in&quot;],</td></tr><tr><td class="line">230</td><td class="hits"></td><td class="source">            TOKENTYPES.at, TOKENTYPES.and, TOKENTYPES.except,</td></tr><tr><td class="line">231</td><td class="hits"></td><td class="source">            TOKENTYPES.also]);</td></tr><tr><td class="line">232</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">233</td><td class="hits">138</td><td class="source">      switch (token.type) {</td></tr><tr><td class="line">234</td><td class="hits"></td><td class="source">        case TOKENTYPES.every:</td></tr><tr class="hit"><td class="line">235</td><td class="hits">22</td><td class="source">          parseEvery(r);</td></tr><tr class="hit"><td class="line">236</td><td class="hits">22</td><td class="source">          break;</td></tr><tr><td class="line">237</td><td class="hits"></td><td class="source">        case TOKENTYPES.after:</td></tr><tr class="hit"><td class="line">238</td><td class="hits">21</td><td class="source">          if(peek(TOKENTYPES.time).type !== undefined) {</td></tr><tr class="hit"><td class="line">239</td><td class="hits">7</td><td class="source">            r.after(parseTokenValue(TOKENTYPES.time));</td></tr><tr class="hit"><td class="line">240</td><td class="hits">7</td><td class="source">            r.time();</td></tr><tr><td class="line">241</td><td class="hits"></td><td class="source">          }</td></tr><tr><td class="line">242</td><td class="hits"></td><td class="source">          else {</td></tr><tr class="hit"><td class="line">243</td><td class="hits">14</td><td class="source">            r.after(parseTokenValue(TOKENTYPES.rank));</td></tr><tr class="hit"><td class="line">244</td><td class="hits">14</td><td class="source">            parseTimePeriod(r);</td></tr><tr><td class="line">245</td><td class="hits"></td><td class="source">          }</td></tr><tr class="hit"><td class="line">246</td><td class="hits">21</td><td class="source">          break;</td></tr><tr><td class="line">247</td><td class="hits"></td><td class="source">        case TOKENTYPES.before:</td></tr><tr class="hit"><td class="line">248</td><td class="hits">21</td><td class="source">          if(peek(TOKENTYPES.time).type !== undefined) {</td></tr><tr class="hit"><td class="line">249</td><td class="hits">7</td><td class="source">            r.before(parseTokenValue(TOKENTYPES.time));</td></tr><tr class="hit"><td class="line">250</td><td class="hits">7</td><td class="source">            r.time();</td></tr><tr><td class="line">251</td><td class="hits"></td><td class="source">          }</td></tr><tr><td class="line">252</td><td class="hits"></td><td class="source">          else {</td></tr><tr class="hit"><td class="line">253</td><td class="hits">14</td><td class="source">            r.before(parseTokenValue(TOKENTYPES.rank));</td></tr><tr class="hit"><td class="line">254</td><td class="hits">14</td><td class="source">            parseTimePeriod(r);</td></tr><tr><td class="line">255</td><td class="hits"></td><td class="source">          }</td></tr><tr class="hit"><td class="line">256</td><td class="hits">21</td><td class="source">          break;</td></tr><tr><td class="line">257</td><td class="hits"></td><td class="source">        case TOKENTYPES.onthe:</td></tr><tr class="hit"><td class="line">258</td><td class="hits">23</td><td class="source">          parseOnThe(r);</td></tr><tr class="hit"><td class="line">259</td><td class="hits">23</td><td class="source">          break;</td></tr><tr><td class="line">260</td><td class="hits"></td><td class="source">        case TOKENTYPES.on:</td></tr><tr class="hit"><td class="line">261</td><td class="hits">8</td><td class="source">          r.on(parseRanges(TOKENTYPES.dayName)).dayOfWeek();</td></tr><tr class="hit"><td class="line">262</td><td class="hits">8</td><td class="source">          break;</td></tr><tr><td class="line">263</td><td class="hits"></td><td class="source">        case TOKENTYPES.of:</td></tr><tr class="hit"><td class="line">264</td><td class="hits">5</td><td class="source">          r.on(parseRanges(TOKENTYPES.monthName)).month();</td></tr><tr class="hit"><td class="line">265</td><td class="hits">5</td><td class="source">          break;</td></tr><tr><td class="line">266</td><td class="hits"></td><td class="source">        case TOKENTYPES[&quot;in&quot;]:</td></tr><tr class="hit"><td class="line">267</td><td class="hits">4</td><td class="source">          r.on(parseRanges(TOKENTYPES.yearIndex)).year();</td></tr><tr class="hit"><td class="line">268</td><td class="hits">4</td><td class="source">          break;</td></tr><tr><td class="line">269</td><td class="hits"></td><td class="source">        case TOKENTYPES.at:</td></tr><tr class="hit"><td class="line">270</td><td class="hits">23</td><td class="source">          r.on(parseTokenValue(TOKENTYPES.time)).time();</td></tr><tr class="hit"><td class="line">271</td><td class="hits">23</td><td class="source">          while (checkAndParse(TOKENTYPES.and)) {</td></tr><tr class="hit"><td class="line">272</td><td class="hits">3</td><td class="source">            r.on(parseTokenValue(TOKENTYPES.time)).time();</td></tr><tr><td class="line">273</td><td class="hits"></td><td class="source">          }</td></tr><tr class="hit"><td class="line">274</td><td class="hits">23</td><td class="source">          break;</td></tr><tr><td class="line">275</td><td class="hits"></td><td class="source">        case TOKENTYPES.and:</td></tr><tr class="hit"><td class="line">276</td><td class="hits">4</td><td class="source">          break;</td></tr><tr><td class="line">277</td><td class="hits"></td><td class="source">        case TOKENTYPES.also:</td></tr><tr class="hit"><td class="line">278</td><td class="hits">2</td><td class="source">          r.and();</td></tr><tr class="hit"><td class="line">279</td><td class="hits">2</td><td class="source">          break;</td></tr><tr><td class="line">280</td><td class="hits"></td><td class="source">        case TOKENTYPES.except:</td></tr><tr class="hit"><td class="line">281</td><td class="hits">2</td><td class="source">          r.except();</td></tr><tr class="hit"><td class="line">282</td><td class="hits">2</td><td class="source">          break;</td></tr><tr><td class="line">283</td><td class="hits"></td><td class="source">        default:</td></tr><tr class="hit"><td class="line">284</td><td class="hits">3</td><td class="source">          error = pos;</td></tr><tr><td class="line">285</td><td class="hits"></td><td class="source">      }</td></tr><tr><td class="line">286</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">287</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">288</td><td class="hits">95</td><td class="source">    return {schedules: r.schedules, exceptions: r.exceptions, error: error};</td></tr><tr><td class="line">289</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">290</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">291</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">292</td><td class="hits"></td><td class="source">  * Parses the next token representing a time period and adds it to</td></tr><tr><td class="line">293</td><td class="hits"></td><td class="source">  * the provided recur object.</td></tr><tr><td class="line">294</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">295</td><td class="hits"></td><td class="source">  * @param {Recur} r: The recurrence to add the time period to</td></tr><tr><td class="line">296</td><td class="hits"></td><td class="source">  */</td></tr><tr class="hit"><td class="line">297</td><td class="hits">95</td><td class="source">  function parseTimePeriod(r) {</td></tr><tr class="hit"><td class="line">298</td><td class="hits">70</td><td class="source">    var timePeriod = parseToken([TOKENTYPES.second, TOKENTYPES.minute,</td></tr><tr><td class="line">299</td><td class="hits"></td><td class="source">          TOKENTYPES.hour, TOKENTYPES.dayOfYear, TOKENTYPES.dayOfWeek,</td></tr><tr><td class="line">300</td><td class="hits"></td><td class="source">          TOKENTYPES.dayInstance, TOKENTYPES.day, TOKENTYPES.month,</td></tr><tr><td class="line">301</td><td class="hits"></td><td class="source">          TOKENTYPES.year, TOKENTYPES.weekOfMonth, TOKENTYPES.weekOfYear]);</td></tr><tr><td class="line">302</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">303</td><td class="hits">70</td><td class="source">    switch (timePeriod.type) {</td></tr><tr><td class="line">304</td><td class="hits"></td><td class="source">      case TOKENTYPES.second:</td></tr><tr class="hit"><td class="line">305</td><td class="hits">6</td><td class="source">        r.second();</td></tr><tr class="hit"><td class="line">306</td><td class="hits">6</td><td class="source">        break;</td></tr><tr><td class="line">307</td><td class="hits"></td><td class="source">      case TOKENTYPES.minute:</td></tr><tr class="hit"><td class="line">308</td><td class="hits">15</td><td class="source">        r.minute();</td></tr><tr class="hit"><td class="line">309</td><td class="hits">15</td><td class="source">        break;</td></tr><tr><td class="line">310</td><td class="hits"></td><td class="source">      case TOKENTYPES.hour:</td></tr><tr class="hit"><td class="line">311</td><td class="hits">7</td><td class="source">        r.hour();</td></tr><tr class="hit"><td class="line">312</td><td class="hits">7</td><td class="source">        break;</td></tr><tr><td class="line">313</td><td class="hits"></td><td class="source">      case TOKENTYPES.dayOfYear:</td></tr><tr class="hit"><td class="line">314</td><td class="hits">3</td><td class="source">        r.dayOfYear();</td></tr><tr class="hit"><td class="line">315</td><td class="hits">3</td><td class="source">        break;</td></tr><tr><td class="line">316</td><td class="hits"></td><td class="source">      case TOKENTYPES.dayOfWeek:</td></tr><tr class="hit"><td class="line">317</td><td class="hits">5</td><td class="source">        r.dayOfWeek();</td></tr><tr class="hit"><td class="line">318</td><td class="hits">5</td><td class="source">        break;</td></tr><tr><td class="line">319</td><td class="hits"></td><td class="source">      case TOKENTYPES.dayInstance:</td></tr><tr class="hit"><td class="line">320</td><td class="hits">3</td><td class="source">        r.dayOfWeekCount();</td></tr><tr class="hit"><td class="line">321</td><td class="hits">3</td><td class="source">        break;</td></tr><tr><td class="line">322</td><td class="hits"></td><td class="source">      case TOKENTYPES.day:</td></tr><tr class="hit"><td class="line">323</td><td class="hits">10</td><td class="source">        r.dayOfMonth();</td></tr><tr class="hit"><td class="line">324</td><td class="hits">10</td><td class="source">        break;</td></tr><tr><td class="line">325</td><td class="hits"></td><td class="source">      case TOKENTYPES.weekOfMonth:</td></tr><tr class="hit"><td class="line">326</td><td class="hits">4</td><td class="source">        r.weekOfMonth();</td></tr><tr class="hit"><td class="line">327</td><td class="hits">4</td><td class="source">        break;</td></tr><tr><td class="line">328</td><td class="hits"></td><td class="source">      case TOKENTYPES.weekOfYear:</td></tr><tr class="hit"><td class="line">329</td><td class="hits">6</td><td class="source">        r.weekOfYear();</td></tr><tr class="hit"><td class="line">330</td><td class="hits">6</td><td class="source">        break;</td></tr><tr><td class="line">331</td><td class="hits"></td><td class="source">      case TOKENTYPES.month:</td></tr><tr class="hit"><td class="line">332</td><td class="hits">8</td><td class="source">        r.month();</td></tr><tr class="hit"><td class="line">333</td><td class="hits">8</td><td class="source">        break;</td></tr><tr><td class="line">334</td><td class="hits"></td><td class="source">      case TOKENTYPES.year:</td></tr><tr class="hit"><td class="line">335</td><td class="hits">3</td><td class="source">        r.year();</td></tr><tr class="hit"><td class="line">336</td><td class="hits">3</td><td class="source">        break;</td></tr><tr><td class="line">337</td><td class="hits"></td><td class="source">      default:</td></tr><tr class="miss"><td class="line">338</td><td class="hits">0</td><td class="source">        error = pos;</td></tr><tr><td class="line">339</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">340</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">341</td><td class="hits">70</td><td class="source">    return timePeriod;</td></tr><tr><td class="line">342</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">343</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">344</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">345</td><td class="hits"></td><td class="source">  * Checks the next token to see if it is of tokenType. Returns true if</td></tr><tr><td class="line">346</td><td class="hits"></td><td class="source">  * it is and discards the token.  Returns false otherwise.</td></tr><tr><td class="line">347</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">348</td><td class="hits"></td><td class="source">  * @param {TokenType} tokenType: The type or types of token to parse</td></tr><tr><td class="line">349</td><td class="hits"></td><td class="source">  */</td></tr><tr class="hit"><td class="line">350</td><td class="hits">95</td><td class="source">  function checkAndParse(tokenType) {</td></tr><tr class="hit"><td class="line">351</td><td class="hits">240</td><td class="source">    var found = (peek(tokenType)).type === tokenType;</td></tr><tr class="hit"><td class="line">352</td><td class="hits">240</td><td class="source">    if (found) {</td></tr><tr class="hit"><td class="line">353</td><td class="hits">28</td><td class="source">      scan(tokenType);</td></tr><tr><td class="line">354</td><td class="hits"></td><td class="source">    }</td></tr><tr class="hit"><td class="line">355</td><td class="hits">240</td><td class="source">    return found;</td></tr><tr><td class="line">356</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">357</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">358</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">359</td><td class="hits"></td><td class="source">  * Parses and returns the next token.</td></tr><tr><td class="line">360</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">361</td><td class="hits"></td><td class="source">  * @param {TokenType} tokenType: The type or types of token to parse</td></tr><tr><td class="line">362</td><td class="hits"></td><td class="source">  */</td></tr><tr class="hit"><td class="line">363</td><td class="hits">95</td><td class="source">  function parseToken(tokenType) {</td></tr><tr class="hit"><td class="line">364</td><td class="hits">348</td><td class="source">    var t = scan(tokenType);</td></tr><tr class="hit"><td class="line">365</td><td class="hits">348</td><td class="source">    if (t.type) {</td></tr><tr class="hit"><td class="line">366</td><td class="hits">344</td><td class="source">      t.text = convertString(t.text, tokenType);</td></tr><tr><td class="line">367</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">368</td><td class="hits"></td><td class="source">    else {</td></tr><tr class="hit"><td class="line">369</td><td class="hits">4</td><td class="source">      error = pos;</td></tr><tr><td class="line">370</td><td class="hits"></td><td class="source">    }</td></tr><tr class="hit"><td class="line">371</td><td class="hits">348</td><td class="source">    return t;</td></tr><tr><td class="line">372</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">373</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">374</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">375</td><td class="hits"></td><td class="source">  * Returns the text value of the token that was parsed.</td></tr><tr><td class="line">376</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">377</td><td class="hits"></td><td class="source">  * @param {TokenType} tokenType: The type of token to parse</td></tr><tr><td class="line">378</td><td class="hits"></td><td class="source">  */</td></tr><tr class="hit"><td class="line">379</td><td class="hits">95</td><td class="source">  function parseTokenValue(tokenType) {</td></tr><tr class="hit"><td class="line">380</td><td class="hits">139</td><td class="source">    return (parseToken(tokenType)).text;</td></tr><tr><td class="line">381</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">382</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">383</td><td class="hits"></td><td class="source">  /**</td></tr><tr><td class="line">384</td><td class="hits"></td><td class="source">  * Converts a string value to a numerical value based on the type of</td></tr><tr><td class="line">385</td><td class="hits"></td><td class="source">  * token that was parsed.</td></tr><tr><td class="line">386</td><td class="hits"></td><td class="source">  *</td></tr><tr><td class="line">387</td><td class="hits"></td><td class="source">  * @param {String} str: The schedule string to parse</td></tr><tr><td class="line">388</td><td class="hits"></td><td class="source">  * @param {TokenType} tokenType: The type of token to convert</td></tr><tr><td class="line">389</td><td class="hits"></td><td class="source">  */</td></tr><tr class="hit"><td class="line">390</td><td class="hits">95</td><td class="source">  function convertString(str, tokenType) {</td></tr><tr class="hit"><td class="line">391</td><td class="hits">344</td><td class="source">    var output = str;</td></tr><tr><td class="line">392</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">393</td><td class="hits">344</td><td class="source">    switch (tokenType) {</td></tr><tr><td class="line">394</td><td class="hits"></td><td class="source">      case TOKENTYPES.time:</td></tr><tr class="hit"><td class="line">395</td><td class="hits">40</td><td class="source">        var parts = str.split(/(:|am|pm)/),</td></tr><tr><td class="line">396</td><td class="hits"></td><td class="source">            hour = parts[3] === 'pm' &amp;&amp; parts[0] &lt; 12 ? parseInt(parts[0],10) + 12 : parts[0],</td></tr><tr><td class="line">397</td><td class="hits"></td><td class="source">            min = parts[2].trim();</td></tr><tr><td class="line">398</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">399</td><td class="hits">40</td><td class="source">        output = (hour.length === 1 ? '0' : '') + hour + &quot;:&quot; + min;</td></tr><tr class="hit"><td class="line">400</td><td class="hits">40</td><td class="source">        break;</td></tr><tr><td class="line">401</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">402</td><td class="hits"></td><td class="source">      case TOKENTYPES.rank:</td></tr><tr class="hit"><td class="line">403</td><td class="hits">74</td><td class="source">        output = parseInt((/^\d+/.exec(str))[0],10);</td></tr><tr class="hit"><td class="line">404</td><td class="hits">74</td><td class="source">        break;</td></tr><tr><td class="line">405</td><td class="hits"></td><td class="source"> </td></tr><tr><td class="line">406</td><td class="hits"></td><td class="source">      case TOKENTYPES.monthName:</td></tr><tr><td class="line">407</td><td class="hits"></td><td class="source">      case TOKENTYPES.dayName:</td></tr><tr class="hit"><td class="line">408</td><td class="hits">17</td><td class="source">        output = NAMES[str.substring(0,3)];</td></tr><tr class="hit"><td class="line">409</td><td class="hits">17</td><td class="source">        break;</td></tr><tr><td class="line">410</td><td class="hits"></td><td class="source">    }</td></tr><tr><td class="line">411</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">412</td><td class="hits">344</td><td class="source">    return output;</td></tr><tr><td class="line">413</td><td class="hits"></td><td class="source">  }</td></tr><tr><td class="line">414</td><td class="hits"></td><td class="source"> </td></tr><tr class="hit"><td class="line">415</td><td class="hits">95</td><td class="source">  return parseScheduleExpr(str.toLowerCase());</td></tr><tr><td class="line">416</td><td class="hits"></td><td class="source">};</td></tr></tbody></table></div></div></div></body></html>make[1]: Leaving directory `/home/bill/dev/later'
