var sys = require('sys'),
    path = require('path'),
    fs = require('fs'),
    events = require('events').EventEmitter;

var callBacks = {
    previousResult: function(){return "";}
};

exports.exists=function(path){
    return function(options){
        try {
            fs.statSync(path);
            return options.passed();
        } catch (e){
            return options.failed();
        }
    }
};
exports.missingDb=function(){
	return function(options){
		var db = options.db;
		db.exists(function(error, ok){
            if(error) {
                options.error(error);
                return;
            }
			if (!ok) {
				options.passed();
			}
			else {
				options.failed();
			}
		});
	}
};
exports.docExists=function(){
	return function(options){
		var db = options.db;
		db.exists(function(error, ok){
            if(error) {
                options.error(error);
                return;
            }
			if (!ok) {
				options.passed();
			}
			else {
				options.failed();
			}
		});
	}
};
exports.contains=function(pattern){
    return function(){
        var passed =  callBacks.previousResult().indexOf(pattern)>0
        if(passed) {
            options.passed();
        }
        else {
            options.failed();
        }
    };
};
exports.register=function(previousResult){
    callBacks.previousResult=previousResult;
};

exports.not=function(){
    var inverted = {};
    for (var attrname in exports) {
            if(!exports.hasOwnProperty(attrname)) continue;
            if(attrname=='not') continue;
            inverted[attrname] = invert(attrname);
    }
    return inverted;
}

function invert(name){
    return function(){
                var whenClause = exports[name].apply(this, arguments);
                return function(options){
                    var inverted = {
                        db: options.db,
                        passed: options.failed,
                        failed: options.passed,
                        error: options.error
                    }
                    whenClause(inverted);
                }
            }
}