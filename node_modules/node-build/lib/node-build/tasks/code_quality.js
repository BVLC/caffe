var jsmeter = require('./dep/jsmeter/jsmeter');

tasks.readCoverage=function(options){
        var rawCoverage = fs.readFileSync(options.file, 'utf8');
        var json = JSON.parse(rawCoverage);
        var result = {};
        var total = {lines: 0, covered: 0};
        for (file in json) {
            var fileCoverage=json[file].coverage;
            var stats = calcCoverage(fileCoverage);
            total.lines=total.lines+stats.lines;
            total.covered=total.covered+stats.covered;
            result[file]=stats;
        }
        total.coverage=(total.covered/total.lines)*100.0;
        result["total"]=total;
        done(result);
    };
tasks.demandCoverage=function(options){
        var coverage = callBacks.previousResult();
        for (var key in coverage) {
            if(coverage[key].coverage<options.expected){
                if(!options.matcher || key.match(options.matcher)){
                    fail(key+" has coverage of "+coverage[key].coverage+"%. It should at least be "+options.expected+"%");
                }
            }
        }
        sys.log("Passed coverage of "+options.expected+"% "+(options.matcher?options.matcher:"all files"));
        done(coverage);
    };
tasks.demandComplexity=function(options){
        var pathname = options.path;
        var maxComplexity = options.maxComplexity;
        var success = true;
        var files = findFiles(pathname, /.*\.js/);
        for(var i=0; i < files.length; i++) {
            var filename = files[i];
            if(options.exclude(filename)) continue;
            var functions = jsmeter.run(fs.readFileSync(filename).toString(), filename);
            for (var j=0; j < functions.length; j++) {
                var f = functions[j];
                if (f.complexity > maxComplexity) {
                    success = false;
                    sys.log("FAIL: "+f.name+" has complexity "+f.complexity+" (max "+maxComplexity+")");
                }
            }
        }
        if (!success)
            fail("Maximum complexity ("+maxComplexity+") exceeded!");
        else
            done();
    };
tasks.prepareTestResults=function(options) {
        var rawCoverage = fs.readFileSync(options.file, 'utf8');
        var tests = JSON.parse(rawCoverage);
        fs.writeFileSync(options.outputFile, tests["tests"].source[0], 'utf8');
        done();
    };
tasks.readTestResults=function(options) {
        var rawTests = fs.readFileSync(options.file, 'utf8');
        var tests = JSON.parse(rawTests);
        done(tests);
    };
tasks.checkTestResults=function(options) {
        var results = callBacks.previousResult();
        var failures = checkResult(results);
        if(failures.length>0){
            fail(sys.inspect(failures));
        }
        sys.log("All tests passed");
        done(results);
    };
tasks.generateTestHtml=function(options){
        var results = callBacks.previousResult();

        var html = "<html><body>";
        html = html + "<h1>Test results</h1>";

        html = html + formatAsHtml(results);

        html = html + "</body></html>";
        fs.writeFileSync(options.file, html, 'utf8');

        done(results);
    };
tasks.demandAppearanceInCoverage=function(options){
        var coverage = callBacks.previousResult();
        var pathname = options.path;
        var success = true;
        //sys.puts(sys.inspect(coverage));
        var files = findFiles(pathname, /.*\.js/);
        for(var i=0; i < files.length; i++) {
            var filename = files[i];
            if(options.exclude && options.exclude(filename)) continue;
            if(coverage['/'+filename]) continue;
            sys.log("FAIL: "+filename+" has no coverage at all");
            success=false;
        }
        if (!success)
            fail("Some source files where not covered by tests at all!");
        else {
            sys.log("All expected files are accounted for in coverage report.");
            done(coverage);
        }
    };
tasks.guardConsole=function(options){
        var pathname = options.path;
        var success = true;
        //sys.puts(sys.inspect(coverage));
        var files = findFiles(pathname, /.*\.js/);
        for(var i=0; i < files.length; i++) {
            var filename = files[i];
            if(options.exclude && options.exclude(filename)) continue;
            var raw = fs.readFileSync(filename, 'utf8');
            if(!/console/.test(raw)) continue;
            sys.log("FAIL: "+filename+" writes to console");
            success=false;
        }
        if (!success)
            fail("Some source files use console");
        else {
            sys.log("No of the files uses console.");
            done();
        }
    };


function formatAsHtml(result) {

    if (result.type=='suite') {
        var html;
        if(result.status) {
            html = "<table style='background-color:"+(result.status=="failed" ? "#ffcccc" : "#ccffcc") +"; width: 100%'>";
        } else {
            html = "<table>"
        }
        html = html + "<tr><td><h2 style='margin-top: 25px; margin-bottom: 4px'>" + result.name + "</h2></td></tr>"+
                "<tr><td>";

        for (var i=0; i<result.results.length; i++) {
            html = html + formatAsHtml(result.results[i]);
        }

        html = html + "</tr></td></table>";
        return html;
    } else {
        return "<p style='background-color:"+(result.status=="failed" ? "#ffcccc" : "#ccffcc") +";'>" + result.name + "</p>";
    }
}

function checkResult(result, suite) {
    var failures = [];
    if (result.type=='suite') {
        for (var i=0; i<result.results.length; i++) {
            failures=failures.concat(
                    checkResult(
                            result.results[i],
                            suite?(suite + " > "+ result.name):result.name
                            ));
        }
    } else {
        if (result.status == 'failed') {
            failures.push(suite+" > "+result.name + ' failed. Reason '+result.message);
        }
    }
    return failures;
}

function calcCoverage(lineData){
    var lines=0;
    var covered=0;
    var lineData = lineData || [];
    for(var i=0; i<lineData.length; i++){
        var line = lineData[i];
        if(line==null) continue;
        if(line>=0) lines++;
        if(line>0) covered++;
    }
    return {lines: lines, covered: covered, coverage: (covered/lines)*100.0};
}

language_definition.readCoverage = {
    name: "readCoverage",
    description: "Reads a coverage file so that it's possible to query it. The parsed coverage resutls are handed over to \
                  the next task.",
    arguments: [{type: "direct", name: "file", description: "The jscoverage json file to read."}],
    example:
 'maker.define("coverage").dependsOn("test").perform.\n\
    readCoverage("build/jscoverage.json"). \n\
    demandCoverage(100). \n\
    demandCoverage(100, /^total$/);',
    note: 'We use jscoverage for coverage. To get a jscoverage.json file read this <a href="howto_coverage.html" target="_coverage">section</a>'
};
language_definition.demandAppearanceInCoverage = {
     name: "demandAppearanceInCoverage",
     description: "This taks ensures that files on a certain path appear in the parsed coverage file of the previous task, the coverage will also passed to next task to allow for chaining.",
     arguments: [
         {type: "direct", name: "path", description: "Path to files."},
         {type: "direct", name: "exclude", description: "Optional function to exclude files."}],
     example:
 'maker.define("coverage").dependsOn("test").perform.\n\
    readCoverage("build/jscoverage.json"). \n\
    demandAppearanceInCoverage("./app",\n\
        function(filename){ \n\
           return (/\/jquery\//.test(filename)) \n\
        });'
};
language_definition.demandCoverage = {
    name: "demandCoverage",
    description: "Checks coverage percentage against a treshold. The parsed coverage file of the previous task, the coverage will also passed to next task to allow for chaining",
    arguments: [
        {type: "direct", name: "expected", description: "Expected coverage treshold."},
        {type: "direct", name: "matcher", description: "Optional matched on file name. There's on special entry named 'total'. This entries contains the total coverage."}],
    example:
 'maker.define("coverage").dependsOn("test").perform.\n\
    readCoverage("build/jscoverage.json"). \n\
    demandCoverage(100). \n\
    demandCoverage(100, /^total$/);'
};
language_definition.demandComplexity = {
    name: "demandComplexity",
    description: "Checks coverage percentage against a treshold. The parsed coverage file on the context is evaluated.",
    arguments: [
        {type: "direct", name: "maxComplexity", description: "The number of maximum McCabe complexity."},
        {type: "direct", name: "path", description: "Path to the files, that needs to be checked."},
        {type: "direct", name: "exclude", description: "Optional function to exclude files."}],
    example:
'var defaultExcludes = function(filename){ \n\
       return (/\/jquery\//.test(filename)) \n\
 }); \n\
 \n\
 maker.define("check-complexity").perform. \n\
    demandComplexity(10, "./app", defaultExcludes);'
};
language_definition.prepareTestResults = {
    name: "prepareTestResults",
    description: "We allow for a setup where the jasmine test results are piggy backed on the jscoverage results. \
                  this tasks extracts the piggy backed data and stored them in a file",
    arguments: [
        {type: "direct", name: "file", description: "Path to jscoverage json input file"},
        {type: "direct", name: "outputFile", description: "Path to jasmine json output file"}],
    example:
'maker.define("test-results").perform. \n\
     prepareTestResults("jscoverage.json", "test-results.json"). \n\
     readTestResults("test-results.json"). \n\
     generateTestHtml("test-results.html"). \n\
     checkTestResults();',
    note: 'Read this <a href="howto_setup.html" target="_setup">section</a> to see our setup'
    
};
language_definition.readTestResults = {
    name: "readTestResults",
    description: "Reads a test result file from jasmine so that it's possible to query it. The parsed test results are handed over to \
                  the next task.",
    arguments: [{type: "direct", name: "file", description: "The jasmine(JSON-reporter) json file to parse."}],
    example:
'maker.define("test-results").perform. \n\
  readTestResults("test-results.json"). \n\
  generateTestHtml("test-results.html"). \n\
  checkTestResults();',
    note: 'To get the test-results.json from json file we used A JSON reporter on jasmine. Click <a href="howto_json.html" target="_json">here</a> for more information'
};
language_definition.checkTestResults = {
    name: "checkTestResults",
    description: "Guards that all tests are passed. The test results file of the previous task are evaluted, the test results will also passed to next task to allow for chaining.",
    arguments: [],
    example:
'maker.define("test-results").perform. \n\
  readTestResults("test-results.json"). \n\
  generateTestHtml("test-results.html"). \n\
  checkTestResults();'
};
language_definition.generateTestHtml = {
    name: "generateTestHtml",
    description: "Formats the test results as html (to use as an artificat in your continous intergration.) The test results file of the previous task are evaluted, the test results will also passed to next task to allow for chaining.",
    arguments: [{type: "direct", name: "file", description: 'File to output html to'}],
    example:
'maker.define("test-results").perform. \n\
  readTestResults("test-results.json"). \n\
  generateTestHtml("test-results.html"). \n\
  checkTestResults();'
};
language_definition.guardConsole = {
    name: "guardConsole",
    description: "Checks the files in the path for the string console.",
    arguments: [
        {type: "direct", name: "path", description: "Path to the files, that needs to be checked."},
        {type: "direct", name: "exclude", description: "Optional function to exclude files."}],
    example:
'var defaultExcludes = function(filename){ \n\
       return (/\/jquery\//.test(filename)) \n\
 }); \n\
 \n\
 maker.define("check-console-usage").perform. \n\
    guardConsole("./app", defaultExcludes);'
};