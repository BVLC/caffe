var sys = require('sys'),
    path = require('path'),
    fs = require('fs'),
    events = require('events').EventEmitter,
    Script = process.binding('evals').Script;

eval(fs.readFileSync(__dirname+'/dep/underscore/underscore-min.js', encoding='utf8'));

var callBacks = {
    fail: function(msg){},
    done: function(){},
    previousResult: function(){return "";},
    achieve: function(goal){},
    insert: function(options){}
};

function achiveTask(task){
    task.cmd(task.options);
}


var tasks = {}
var language_definition = {}
function language(tasks){
    this.tasks=tasks;
}

function load_tasks(module){
    eval(fs.readFileSync(module, encoding='utf8'));
}

var conditionals = {type: "options", options: [{name: "condition", description: "Optional condition. If set and false the task will not be executed"}]}
var dont_conditionalize = {};

function build_language(){
    for (var taskname in language_definition) {
            if(!language_definition.hasOwnProperty(taskname)) continue;
            //sys.puts("Extending task lib with "+taskname)
            var definition = language_definition[taskname].arguments;
            extendWithConditionals(definition,taskname);
            language.prototype[taskname] = languageFragment(taskname,definition);
    }
}

function extendWithConditionals(definition,taskname){
    var _definition = _(definition);
    if(_definition.size()==0 || _definition.last().type!="options"){
        definition.push(conditionals);
        return;
    } else {
        var last = _definition.last().options;
        if(_(last).all(function(el){return el.name!='condition'})) {
            _(conditionals.options).each(function(el){last.push(el)});
            return;
        }
    }
    dont_conditionalize[taskname]=true;
}

function languageFragment(taskname, definition){
    return function(){
            var options = {};
            var args = arguments;
            definition.forEach(function (mapping, index){
                if(index>=args.length) return;
                switch(mapping.type){
                    case 'direct':
                        options[mapping.name]=args[index];
                        break;
                    case 'options':
                        mapping.options.forEach(function (option, _){
                            options[option.name]=args[index][option.name];
                        });
                        break;
                    default:
                        fail("Not supported "+mapping.type)
                    break;
                }
            });
            this.tasks.push(command(taskname, options));
            return this
        }
}


function done(result){
    callBacks.done(result);
}

function fail(msg){
    callBacks.fail(msg);
}

function conditionalize(task){
    return function(options){
        if(options.condition && !options.condition(
        {db: global['db'],
         passed: function(){task(options);},
         failed: done,
         error: fail})) {
            return
        };
        return task(options);
    }
}

function command(name, options){
    var task = tasks[name];
    if(!dont_conditionalize[name]) {
        task = conditionalize(task);
    }
    if(task==null) {
        sys.log("No such task "+name);
        process.exit(1);
    }
    return {name: name, cmd: task, options: options}
}

load_tasks(__dirname+'/tasks/basic.js');
load_tasks(__dirname+'/tasks/filesystem.js');
load_tasks(__dirname+'/tasks/process.js');
load_tasks(__dirname+'/tasks/code_quality.js');
load_tasks(__dirname+'/tasks/couchdb.js');
load_tasks(__dirname+'/tasks/releasing.js');
load_tasks(__dirname+'/tasks/remote.js');
build_language();

exports.achieve=achiveTask;
exports.decorator = language;
exports.register = function(done, fail, previousResult,achieve, insert){
    callBacks.done=done;
    callBacks.fail=fail;
    callBacks.previousResult=previousResult;
    callBacks.achieve=achieve;
    callBacks.insert=insert;
}