<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>Caffe: caffe::Layer&lt; Dtype &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Caffe
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>caffe</b></li><li class="navelem"><a class="el" href="classcaffe_1_1Layer.html">Layer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classcaffe_1_1Layer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">caffe::Layer&lt; Dtype &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>An interface for the units of computation which can be composed into a <a class="el" href="classcaffe_1_1Net.html" title="Connects Layers together into a directed acyclic graph (DAG) specified by a NetParameter. ">Net</a>.  
 <a href="classcaffe_1_1Layer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="layer_8hpp_source.html">layer.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for caffe::Layer&lt; Dtype &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcaffe_1_1Layer.png" usemap="#caffe::Layer&lt; Dtype &gt;_map" alt=""/>
  <map id="caffe::Layer&lt; Dtype &gt;_map" name="caffe::Layer&lt; Dtype &gt;_map">
<area href="classcaffe_1_1AccuracyLayer.html" title="Computes the classification accuracy for a one-of-many classification task. " alt="caffe::AccuracyLayer&lt; Dtype &gt;" shape="rect" coords="220,56,430,80"/>
<area href="classcaffe_1_1ArgMaxLayer.html" title="Compute the index of the  max values for each datum across all dimensions . " alt="caffe::ArgMaxLayer&lt; Dtype &gt;" shape="rect" coords="220,112,430,136"/>
<area href="classcaffe_1_1BaseDataLayer.html" title="Provides base for data layers that feed blobs to the Net. " alt="caffe::BaseDataLayer&lt; Dtype &gt;" shape="rect" coords="220,168,430,192"/>
<area href="classcaffe_1_1ConcatLayer.html" title="Takes at least two Blobs and concatenates them along either the num or channel dimension, outputting the result. " alt="caffe::ConcatLayer&lt; Dtype &gt;" shape="rect" coords="220,224,430,248"/>
<area href="classcaffe_1_1ConvolutionLayer.html" title="Convolves the input image with a bank of learned filters, and (optionally) adds biases. " alt="caffe::ConvolutionLayer&lt; Dtype &gt;" shape="rect" coords="220,280,430,304"/>
<area href="classcaffe_1_1DummyDataLayer.html" title="Provides data to the Net generated by a Filler. " alt="caffe::DummyDataLayer&lt; Dtype &gt;" shape="rect" coords="220,336,430,360"/>
<area href="classcaffe_1_1EltwiseLayer.html" title="Compute elementwise operations, such as product and sum, along multiple input Blobs. " alt="caffe::EltwiseLayer&lt; Dtype &gt;" shape="rect" coords="220,392,430,416"/>
<area href="classcaffe_1_1FlattenLayer.html" title="Reshapes the input Blob into flat vectors. " alt="caffe::FlattenLayer&lt; Dtype &gt;" shape="rect" coords="220,448,430,472"/>
<area href="classcaffe_1_1HDF5DataLayer.html" title="Provides data to the Net from HDF5 files. " alt="caffe::HDF5DataLayer&lt; Dtype &gt;" shape="rect" coords="220,504,430,528"/>
<area href="classcaffe_1_1HDF5OutputLayer.html" title="Write blobs to disk as HDF5 files. " alt="caffe::HDF5OutputLayer&lt; Dtype &gt;" shape="rect" coords="220,560,430,584"/>
<area href="classcaffe_1_1Im2colLayer.html" title="A helper for image operations that rearranges image regions into column vectors. Used by ConvolutionL..." alt="caffe::Im2colLayer&lt; Dtype &gt;" shape="rect" coords="220,616,430,640"/>
<area href="classcaffe_1_1InnerProductLayer.html" title="Also known as a "fully-connected" layer, computes an inner product with a set of learned weights..." alt="caffe::InnerProductLayer&lt; Dtype &gt;" shape="rect" coords="220,672,430,696"/>
<area href="classcaffe_1_1LossLayer.html" title="An interface for Layers that take two Blobs as input â€“ usually (1) predictions and (2) ground-truth ..." alt="caffe::LossLayer&lt; Dtype &gt;" shape="rect" coords="220,728,430,752"/>
<area href="classcaffe_1_1LRNLayer.html" title="Normalize the input in a local region across or within feature maps. " alt="caffe::LRNLayer&lt; Dtype &gt;" shape="rect" coords="220,784,430,808"/>
<area href="classcaffe_1_1MVNLayer.html" title="Normalizes the input to have 0-mean and/or unit (1) variance. " alt="caffe::MVNLayer&lt; Dtype &gt;" shape="rect" coords="220,840,430,864"/>
<area href="classcaffe_1_1NeuronLayer.html" title="An interface for layers that take one blob as input ( ) and produce one equally-sized blob as output ..." alt="caffe::NeuronLayer&lt; Dtype &gt;" shape="rect" coords="220,896,430,920"/>
<area href="singletoncaffe_1_1PoolingLayer.html" title="Pools the input image by taking the max, average, etc. within regions. " alt="caffe::PoolingLayer&lt; Dtype &gt;" shape="rect" coords="220,952,430,976"/>
<area href="classcaffe_1_1SilenceLayer.html" title="Ignores bottom blobs while producing no top blobs. (This is useful to suppress outputs during testing..." alt="caffe::SilenceLayer&lt; Dtype &gt;" shape="rect" coords="220,1008,430,1032"/>
<area href="classcaffe_1_1SliceLayer.html" title="Takes a Blob and slices it along either the num or channel dimension, outputting multiple sliced Blob..." alt="caffe::SliceLayer&lt; Dtype &gt;" shape="rect" coords="220,1064,430,1088"/>
<area href="classcaffe_1_1SoftmaxLayer.html" title="Computes the softmax function. " alt="caffe::SoftmaxLayer&lt; Dtype &gt;" shape="rect" coords="220,1120,430,1144"/>
<area href="classcaffe_1_1SplitLayer.html" title="Creates a "split" path in the network by copying the bottom Blob into multiple top Blobs to be used b..." alt="caffe::SplitLayer&lt; Dtype &gt;" shape="rect" coords="220,1176,430,1200"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7b4e4ccea08c7b8b15acc6829d5735f6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#a7b4e4ccea08c7b8b15acc6829d5735f6">Layer</a> (const LayerParameter &amp;param)</td></tr>
<tr class="separator:a7b4e4ccea08c7b8b15acc6829d5735f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f7809d8e708c4408a96af0752aec481"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#a4f7809d8e708c4408a96af0752aec481">SetUp</a> (const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; * &gt; &amp;bottom, vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; * &gt; *top)</td></tr>
<tr class="memdesc:a4f7809d8e708c4408a96af0752aec481"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements common layer setup functionality.  <a href="#a4f7809d8e708c4408a96af0752aec481">More...</a><br /></td></tr>
<tr class="separator:a4f7809d8e708c4408a96af0752aec481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a81d8a3722fcbceab72e6a964695e2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#a11a81d8a3722fcbceab72e6a964695e2">LayerSetUp</a> (const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; * &gt; &amp;bottom, vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; * &gt; *top)</td></tr>
<tr class="memdesc:a11a81d8a3722fcbceab72e6a964695e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does layer-specific setup: your layer should implement this function as well as Reshape.  <a href="#a11a81d8a3722fcbceab72e6a964695e2">More...</a><br /></td></tr>
<tr class="separator:a11a81d8a3722fcbceab72e6a964695e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a288c68a7fc6882fd3f0bc40126bf61f9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#a288c68a7fc6882fd3f0bc40126bf61f9">Reshape</a> (const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; * &gt; &amp;bottom, vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; * &gt; *top)=0</td></tr>
<tr class="memdesc:a288c68a7fc6882fd3f0bc40126bf61f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust the shapes of top blobs and internal buffers to accomodate the shapes of the bottom blobs.  <a href="#a288c68a7fc6882fd3f0bc40126bf61f9">More...</a><br /></td></tr>
<tr class="separator:a288c68a7fc6882fd3f0bc40126bf61f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d00947960a1334be6e45c9a43d8d58"><td class="memItemLeft" align="right" valign="top">Dtype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#a31d00947960a1334be6e45c9a43d8d58">Forward</a> (const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; * &gt; &amp;bottom, vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; * &gt; *top)</td></tr>
<tr class="memdesc:a31d00947960a1334be6e45c9a43d8d58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the bottom blobs, compute the top blobs and the loss.  <a href="#a31d00947960a1334be6e45c9a43d8d58">More...</a><br /></td></tr>
<tr class="separator:a31d00947960a1334be6e45c9a43d8d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38823aa5348f83afd589ec3ac954657e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#a38823aa5348f83afd589ec3ac954657e">Backward</a> (const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; * &gt; &amp;top, const vector&lt; bool &gt; &amp;propagate_down, vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; * &gt; *bottom)</td></tr>
<tr class="memdesc:a38823aa5348f83afd589ec3ac954657e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given the top blob error gradients, compute the bottom blob error gradients.  <a href="#a38823aa5348f83afd589ec3ac954657e">More...</a><br /></td></tr>
<tr class="separator:a38823aa5348f83afd589ec3ac954657e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf4524ce8641a30a8a4784aee1b2b4c8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaf4524ce8641a30a8a4784aee1b2b4c8"></a>
vector&lt; shared_ptr&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a><br class="typebreak" />
&lt; Dtype &gt; &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#aaf4524ce8641a30a8a4784aee1b2b4c8">blobs</a> ()</td></tr>
<tr class="memdesc:aaf4524ce8641a30a8a4784aee1b2b4c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the vector of learnable parameter blobs. <br /></td></tr>
<tr class="separator:aaf4524ce8641a30a8a4784aee1b2b4c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af475062fe280614b18f642c4ccf50b40"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af475062fe280614b18f642c4ccf50b40"></a>
const LayerParameter &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#af475062fe280614b18f642c4ccf50b40">layer_param</a> () const </td></tr>
<tr class="memdesc:af475062fe280614b18f642c4ccf50b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the layer parameter. <br /></td></tr>
<tr class="separator:af475062fe280614b18f642c4ccf50b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a1754828dda22cc8daa2f63377f3579"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a1754828dda22cc8daa2f63377f3579"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#a4a1754828dda22cc8daa2f63377f3579">ToProto</a> (LayerParameter *param, bool write_diff=false)</td></tr>
<tr class="memdesc:a4a1754828dda22cc8daa2f63377f3579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the layer parameter to a protocol buffer. <br /></td></tr>
<tr class="separator:a4a1754828dda22cc8daa2f63377f3579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a964ccba33b9a4b69391a72508f764eaf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a964ccba33b9a4b69391a72508f764eaf"></a>
Dtype&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#a964ccba33b9a4b69391a72508f764eaf">loss</a> (const int top_index) const </td></tr>
<tr class="memdesc:a964ccba33b9a4b69391a72508f764eaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the scalar loss associated with a top blob at a given index. <br /></td></tr>
<tr class="separator:a964ccba33b9a4b69391a72508f764eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a899b09f4b91ada8545b3a43ee91e0d69"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a899b09f4b91ada8545b3a43ee91e0d69"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#a899b09f4b91ada8545b3a43ee91e0d69">set_loss</a> (const int top_index, const Dtype value)</td></tr>
<tr class="memdesc:a899b09f4b91ada8545b3a43ee91e0d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the loss associated with a top blob at a given index. <br /></td></tr>
<tr class="separator:a899b09f4b91ada8545b3a43ee91e0d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af41f004cbe9856c1d6d0b54ba34b6519"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af41f004cbe9856c1d6d0b54ba34b6519"></a>
virtual LayerParameter_LayerType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#af41f004cbe9856c1d6d0b54ba34b6519">type</a> () const </td></tr>
<tr class="memdesc:af41f004cbe9856c1d6d0b54ba34b6519"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the layer type as an enum value. <br /></td></tr>
<tr class="separator:af41f004cbe9856c1d6d0b54ba34b6519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29dba205196d9aeaa1cfeba4dc891093"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29dba205196d9aeaa1cfeba4dc891093"></a>
virtual const string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#a29dba205196d9aeaa1cfeba4dc891093">type_name</a> () const </td></tr>
<tr class="memdesc:a29dba205196d9aeaa1cfeba4dc891093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the layer type name. <br /></td></tr>
<tr class="separator:a29dba205196d9aeaa1cfeba4dc891093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c7a7943a8a6735ac433c9be11e0240"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#a45c7a7943a8a6735ac433c9be11e0240">ExactNumBottomBlobs</a> () const </td></tr>
<tr class="memdesc:a45c7a7943a8a6735ac433c9be11e0240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the exact number of bottom blobs required by the layer, or -1 if no exact number is required.  <a href="#a45c7a7943a8a6735ac433c9be11e0240">More...</a><br /></td></tr>
<tr class="separator:a45c7a7943a8a6735ac433c9be11e0240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade3eee97cc743c4e68fff7eba6484916"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#ade3eee97cc743c4e68fff7eba6484916">MinBottomBlobs</a> () const </td></tr>
<tr class="memdesc:ade3eee97cc743c4e68fff7eba6484916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum number of bottom blobs required by the layer, or -1 if no minimum number is required.  <a href="#ade3eee97cc743c4e68fff7eba6484916">More...</a><br /></td></tr>
<tr class="separator:ade3eee97cc743c4e68fff7eba6484916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6408ef3939f1abed1abcec46ff219289"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#a6408ef3939f1abed1abcec46ff219289">MaxBottomBlobs</a> () const </td></tr>
<tr class="memdesc:a6408ef3939f1abed1abcec46ff219289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of bottom blobs required by the layer, or -1 if no maximum number is required.  <a href="#a6408ef3939f1abed1abcec46ff219289">More...</a><br /></td></tr>
<tr class="separator:a6408ef3939f1abed1abcec46ff219289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c99ed707e8db683a3043412e151af8"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#aa3c99ed707e8db683a3043412e151af8">ExactNumTopBlobs</a> () const </td></tr>
<tr class="memdesc:aa3c99ed707e8db683a3043412e151af8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the exact number of top blobs required by the layer, or -1 if no exact number is required.  <a href="#aa3c99ed707e8db683a3043412e151af8">More...</a><br /></td></tr>
<tr class="separator:aa3c99ed707e8db683a3043412e151af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb143d58a740345fa2dc3d4204d553b"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#a8bb143d58a740345fa2dc3d4204d553b">MinTopBlobs</a> () const </td></tr>
<tr class="memdesc:a8bb143d58a740345fa2dc3d4204d553b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum number of top blobs required by the layer, or -1 if no minimum number is required.  <a href="#a8bb143d58a740345fa2dc3d4204d553b">More...</a><br /></td></tr>
<tr class="separator:a8bb143d58a740345fa2dc3d4204d553b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeff774663c6ec94424901d2746e2f03"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#adeff774663c6ec94424901d2746e2f03">MaxTopBlobs</a> () const </td></tr>
<tr class="memdesc:adeff774663c6ec94424901d2746e2f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of top blobs required by the layer, or -1 if no maximum number is required.  <a href="#adeff774663c6ec94424901d2746e2f03">More...</a><br /></td></tr>
<tr class="separator:adeff774663c6ec94424901d2746e2f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad412187a0483c310bd59fd5f957faf0d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#ad412187a0483c310bd59fd5f957faf0d">EqualNumBottomTopBlobs</a> () const </td></tr>
<tr class="memdesc:ad412187a0483c310bd59fd5f957faf0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the layer requires an equal number of bottom and top blobs.  <a href="#ad412187a0483c310bd59fd5f957faf0d">More...</a><br /></td></tr>
<tr class="separator:ad412187a0483c310bd59fd5f957faf0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad732ca94cb21b4c4e0d6372a530ededf"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#ad732ca94cb21b4c4e0d6372a530ededf">AutoTopBlobs</a> () const </td></tr>
<tr class="memdesc:ad732ca94cb21b4c4e0d6372a530ededf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether "anonymous" top blobs are created automatically by the layer.  <a href="#ad732ca94cb21b4c4e0d6372a530ededf">More...</a><br /></td></tr>
<tr class="separator:ad732ca94cb21b4c4e0d6372a530ededf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2e4ca94eaa1cbc054b512c6657743e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#a4a2e4ca94eaa1cbc054b512c6657743e">AllowForceBackward</a> (const int bottom_index) const </td></tr>
<tr class="memdesc:a4a2e4ca94eaa1cbc054b512c6657743e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether to allow force_backward for a given bottom blob index.  <a href="#a4a2e4ca94eaa1cbc054b512c6657743e">More...</a><br /></td></tr>
<tr class="separator:a4a2e4ca94eaa1cbc054b512c6657743e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3708013b0231e71d725252e10ce6e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#a1a3708013b0231e71d725252e10ce6e3">param_propagate_down</a> (const int param_id)</td></tr>
<tr class="memdesc:a1a3708013b0231e71d725252e10ce6e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies whether the layer should compute gradients w.r.t. a parameter at a particular index given by param_id.  <a href="#a1a3708013b0231e71d725252e10ce6e3">More...</a><br /></td></tr>
<tr class="separator:a1a3708013b0231e71d725252e10ce6e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a6fcb843803ed556f0a69cc2864379b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a6fcb843803ed556f0a69cc2864379b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#a9a6fcb843803ed556f0a69cc2864379b">set_param_propagate_down</a> (const int param_id, const bool value)</td></tr>
<tr class="memdesc:a9a6fcb843803ed556f0a69cc2864379b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether the layer should compute gradients w.r.t. a parameter at a particular index given by param_id. <br /></td></tr>
<tr class="separator:a9a6fcb843803ed556f0a69cc2864379b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a7157e270d38711581246bea58ac77a4f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7157e270d38711581246bea58ac77a4f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#a7157e270d38711581246bea58ac77a4f">Forward_cpu</a> (const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; * &gt; &amp;bottom, vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; * &gt; *top)=0</td></tr>
<tr class="memdesc:a7157e270d38711581246bea58ac77a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Using the CPU device, compute the layer output. <br /></td></tr>
<tr class="separator:a7157e270d38711581246bea58ac77a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a7772c833c4982b337e07acfa3d7ae"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6a7772c833c4982b337e07acfa3d7ae"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#ac6a7772c833c4982b337e07acfa3d7ae">Forward_gpu</a> (const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; * &gt; &amp;bottom, vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; * &gt; *top)</td></tr>
<tr class="memdesc:ac6a7772c833c4982b337e07acfa3d7ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Using the GPU device, compute the layer output. Fall back to <a class="el" href="classcaffe_1_1Layer.html#a7157e270d38711581246bea58ac77a4f" title="Using the CPU device, compute the layer output. ">Forward_cpu()</a> if unavailable. <br /></td></tr>
<tr class="separator:ac6a7772c833c4982b337e07acfa3d7ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a223d932dacb7ff4c010e982f57e775b6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a223d932dacb7ff4c010e982f57e775b6"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#a223d932dacb7ff4c010e982f57e775b6">Backward_cpu</a> (const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; * &gt; &amp;top, const vector&lt; bool &gt; &amp;propagate_down, vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; * &gt; *bottom)=0</td></tr>
<tr class="memdesc:a223d932dacb7ff4c010e982f57e775b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Using the CPU device, compute the gradients for any parameters and for the bottom blobs if propagate_down is true. <br /></td></tr>
<tr class="separator:a223d932dacb7ff4c010e982f57e775b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32dbaea571acd07a443b1bd10d9df4c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a32dbaea571acd07a443b1bd10d9df4c9"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#a32dbaea571acd07a443b1bd10d9df4c9">Backward_gpu</a> (const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; * &gt; &amp;top, const vector&lt; bool &gt; &amp;propagate_down, vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; * &gt; *bottom)</td></tr>
<tr class="memdesc:a32dbaea571acd07a443b1bd10d9df4c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Using the GPU device, compute the gradients for any parameters and for the bottom blobs if propagate_down is true. Fall back to <a class="el" href="classcaffe_1_1Layer.html#a223d932dacb7ff4c010e982f57e775b6" title="Using the CPU device, compute the gradients for any parameters and for the bottom blobs if propagate_...">Backward_cpu()</a> if unavailable. <br /></td></tr>
<tr class="separator:a32dbaea571acd07a443b1bd10d9df4c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa95e30dff155409a25ffcb5c8c885e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#adaa95e30dff155409a25ffcb5c8c885e">CheckBlobCounts</a> (const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; * &gt; &amp;bottom, const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; * &gt; &amp;top)</td></tr>
<tr class="separator:adaa95e30dff155409a25ffcb5c8c885e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bebaf079cff5bff7016be1733bb996e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#a5bebaf079cff5bff7016be1733bb996e">SetLossWeights</a> (vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; * &gt; *top)</td></tr>
<tr class="separator:a5bebaf079cff5bff7016be1733bb996e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90730e177e4b3b3516b1b69ba2f6b06a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90730e177e4b3b3516b1b69ba2f6b06a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DISABLE_COPY_AND_ASSIGN</b> (<a class="el" href="classcaffe_1_1Layer.html">Layer</a>)</td></tr>
<tr class="separator:a90730e177e4b3b3516b1b69ba2f6b06a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a7ed12bb2df25c887e41d7ea9557fc701"><td class="memItemLeft" align="right" valign="top">LayerParameter&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#a7ed12bb2df25c887e41d7ea9557fc701">layer_param_</a></td></tr>
<tr class="separator:a7ed12bb2df25c887e41d7ea9557fc701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8073fcf2c139b47eb99ce71b346b1321"><td class="memItemLeft" align="right" valign="top">vector&lt; shared_ptr&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a><br class="typebreak" />
&lt; Dtype &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#a8073fcf2c139b47eb99ce71b346b1321">blobs_</a></td></tr>
<tr class="separator:a8073fcf2c139b47eb99ce71b346b1321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd4a05def9ff3b42ad72404210613ef7"><td class="memItemLeft" align="right" valign="top">vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#acd4a05def9ff3b42ad72404210613ef7">param_propagate_down_</a></td></tr>
<tr class="separator:acd4a05def9ff3b42ad72404210613ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d347229a139500994e7a926c680486"><td class="memItemLeft" align="right" valign="top">vector&lt; Dtype &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe_1_1Layer.html#af6d347229a139500994e7a926c680486">loss_</a></td></tr>
<tr class="separator:af6d347229a139500994e7a926c680486"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Dtype&gt;<br />
class caffe::Layer&lt; Dtype &gt;</h3>

<p>An interface for the units of computation which can be composed into a <a class="el" href="classcaffe_1_1Net.html" title="Connects Layers together into a directed acyclic graph (DAG) specified by a NetParameter. ">Net</a>. </p>
<p><a class="el" href="classcaffe_1_1Layer.html" title="An interface for the units of computation which can be composed into a Net. ">Layer</a>&amp;s must implement a Forward function, in which they take their input (bottom) <a class="el" href="classcaffe_1_1Blob.html" title="A wrapper around SyncedMemory holders serving as the basic computational unit through which Layers...">Blob</a>&amp;s (if any) and compute their output <a class="el" href="classcaffe_1_1Blob.html" title="A wrapper around SyncedMemory holders serving as the basic computational unit through which Layers...">Blob</a>&amp;s (if any). They may also implement a Backward function, in which they compute the error gradients with respect to their input <a class="el" href="classcaffe_1_1Blob.html" title="A wrapper around SyncedMemory holders serving as the basic computational unit through which Layers...">Blob</a>&amp;s, given the error gradients with their output <a class="el" href="classcaffe_1_1Blob.html" title="A wrapper around SyncedMemory holders serving as the basic computational unit through which Layers...">Blob</a>&amp;s. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7b4e4ccea08c7b8b15acc6829d5735f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcaffe_1_1Layer.html">caffe::Layer</a>&lt; Dtype &gt;::<a class="el" href="classcaffe_1_1Layer.html">Layer</a> </td>
          <td>(</td>
          <td class="paramtype">const LayerParameter &amp;&#160;</td>
          <td class="paramname"><em>param</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>You should not implement your own constructor. Any set up code should go to <a class="el" href="classcaffe_1_1Layer.html#a4f7809d8e708c4408a96af0752aec481" title="Implements common layer setup functionality. ">SetUp()</a>, where the dimensions of the bottom blobs are provided to the layer. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a4a2e4ca94eaa1cbc054b512c6657743e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classcaffe_1_1Layer.html">caffe::Layer</a>&lt; Dtype &gt;::AllowForceBackward </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>bottom_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return whether to allow force_backward for a given bottom blob index. </p>
<p>If AllowForceBackward(i) == false, we will ignore the force_backward setting and backpropagate to blob i only if it needs gradient information (as is done when force_backward == false). </p>

<p>Reimplemented in <a class="el" href="classcaffe_1_1EuclideanLossLayer.html#a3c954fd7c15596fd2f59e0f79601905c">caffe::EuclideanLossLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1ContrastiveLossLayer.html#afbfe9d1707c9e76e31fe381af3d708ef">caffe::ContrastiveLossLayer&lt; Dtype &gt;</a>, and <a class="el" href="classcaffe_1_1LossLayer.html#ad02fe695b06451ac8e6f21db0cba1dad">caffe::LossLayer&lt; Dtype &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ad732ca94cb21b4c4e0d6372a530ededf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classcaffe_1_1Layer.html">caffe::Layer</a>&lt; Dtype &gt;::AutoTopBlobs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return whether "anonymous" top blobs are created automatically by the layer. </p>
<p>If this method returns true, <a class="el" href="classcaffe_1_1Net.html#ae9fcfaabc89165d6c0cb4b14b4c6b584" title="Initialize a network with a NetParameter. ">Net::Init</a> will create enough "anonymous" top blobs to fulfill the requirement specified by <a class="el" href="classcaffe_1_1Layer.html#aa3c99ed707e8db683a3043412e151af8" title="Returns the exact number of top blobs required by the layer, or -1 if no exact number is required...">ExactNumTopBlobs()</a> or <a class="el" href="classcaffe_1_1Layer.html#a8bb143d58a740345fa2dc3d4204d553b" title="Returns the minimum number of top blobs required by the layer, or -1 if no minimum number is required...">MinTopBlobs()</a>. </p>

<p>Reimplemented in <a class="el" href="classcaffe_1_1LossLayer.html#ad272e6792a781ce4f66a65057cc829d1">caffe::LossLayer&lt; Dtype &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a38823aa5348f83afd589ec3ac954657e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcaffe_1_1Layer.html">caffe::Layer</a>&lt; Dtype &gt;::Backward </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>propagate_down</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; * &gt; *&#160;</td>
          <td class="paramname"><em>bottom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the top blob error gradients, compute the bottom blob error gradients. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">top</td><td>the output blobs, whose diff fields store the gradient of the error with respect to themselves </td></tr>
    <tr><td class="paramname">propagate_down</td><td>a vector with equal length to bottom, with each index indicating whether to propagate the error gradients down to the bottom blob at the corresponding index </td></tr>
    <tr><td class="paramname">bottom</td><td>the input blobs, whose diff fields will store the gradient of the error with respect to themselves after Backward is run</td></tr>
  </table>
  </dd>
</dl>
<p>The Backward wrapper calls the relevant device wrapper function (Backward_cpu or Backward_gpu) to compute the bottom blob diffs given the top blob diffs.</p>
<p>Your layer should implement Forward_cpu and (optionally) Forward_gpu. </p>

</div>
</div>
<a class="anchor" id="adaa95e30dff155409a25ffcb5c8c885e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classcaffe_1_1Layer.html">caffe::Layer</a>&lt; Dtype &gt;::CheckBlobCounts </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>top</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called by the parent <a class="el" href="classcaffe_1_1Layer.html" title="An interface for the units of computation which can be composed into a Net. ">Layer</a>'s SetUp to check that the number of bottom and top Blobs provided as input match the expected numbers specified by the {ExactNum,Min,Max}{Bottom,Top}Blobs() functions. </p>

</div>
</div>
<a class="anchor" id="ad412187a0483c310bd59fd5f957faf0d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classcaffe_1_1Layer.html">caffe::Layer</a>&lt; Dtype &gt;::EqualNumBottomTopBlobs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the layer requires an equal number of bottom and top blobs. </p>
<p>This method should be overridden to return true if your layer expects an equal number of bottom and top blobs. </p>

<p>Reimplemented in <a class="el" href="classcaffe_1_1ConvolutionLayer.html#a61ed38dbd57978722c2e369e8892f898">caffe::ConvolutionLayer&lt; Dtype &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a45c7a7943a8a6735ac433c9be11e0240"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classcaffe_1_1Layer.html">caffe::Layer</a>&lt; Dtype &gt;::ExactNumBottomBlobs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the exact number of bottom blobs required by the layer, or -1 if no exact number is required. </p>
<p>This method should be overridden to return a non-negative value if your layer expects some exact number of bottom blobs. </p>

<p>Reimplemented in <a class="el" href="classcaffe_1_1SoftmaxWithLossLayer.html#a4752aed6057b5747e0e72003878da060">caffe::SoftmaxWithLossLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1SliceLayer.html#a7f140bb3775c60a2d3d60298802d2b85">caffe::SliceLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1InfogainLossLayer.html#aef9aa9200a3129d7bddf56f717017cbb">caffe::InfogainLossLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1SplitLayer.html#abdf26784113e37451b5c9e4b5181badb">caffe::SplitLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1SoftmaxLayer.html#a6b8863006cf34812d01354b671406816">caffe::SoftmaxLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1WindowDataLayer.html#ac6c818494dd8d3636523556c858908c4">caffe::WindowDataLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1MVNLayer.html#a5766f86a41a05a585dfceeb944b6ca2c">caffe::MVNLayer&lt; Dtype &gt;</a>, <a class="el" href="singletoncaffe_1_1PoolingLayer.html#a6fc8f79729e17639d3b97781791e352d">caffe::PoolingLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1MemoryDataLayer.html#a46529bcce2bf8b8f3984286ad675cbd6">caffe::MemoryDataLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1InnerProductLayer.html#a53daee4cea7f8902042418a3925ee0a5">caffe::InnerProductLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1ImageDataLayer.html#a95155f868560cf481138deb7a999ee08">caffe::ImageDataLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1HDF5OutputLayer.html#af874ff0bf8f1817f44d18398889bcbe4">caffe::HDF5OutputLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1LRNLayer.html#aabbbcdeb646c188ac2137b003aa1c682">caffe::LRNLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1FlattenLayer.html#ad7abb8ccc06c7943e79d77bf5a7e2521">caffe::FlattenLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1HDF5DataLayer.html#a800a76c3afa9d5ac8042fa08d01b3bef">caffe::HDF5DataLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1Im2colLayer.html#aba3720be3f1f71f9e44fbfba90ae3ac0">caffe::Im2colLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1ContrastiveLossLayer.html#af1b8bcaf8ddacd3e98e26c558c7f49a0">caffe::ContrastiveLossLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1DummyDataLayer.html#ad25325d52be96802665c21acc792c6dc">caffe::DummyDataLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1DataLayer.html#a41c3c270f2f1239808fbd4293e89949d">caffe::DataLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1LossLayer.html#a8a2e16d4691640c34e589aac4ec42e28">caffe::LossLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1AbsValLayer.html#a0e797616508e76aa9c2ce19a1b08dff0">caffe::AbsValLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1ArgMaxLayer.html#ab9acebe420760d367c6e5808842411d0">caffe::ArgMaxLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1AccuracyLayer.html#afcde815835ab4cdf76fbbef610491a91">caffe::AccuracyLayer&lt; Dtype &gt;</a>, and <a class="el" href="classcaffe_1_1NeuronLayer.html#a83678ec7f661054d36d83fa062b639b2">caffe::NeuronLayer&lt; Dtype &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aa3c99ed707e8db683a3043412e151af8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classcaffe_1_1Layer.html">caffe::Layer</a>&lt; Dtype &gt;::ExactNumTopBlobs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the exact number of top blobs required by the layer, or -1 if no exact number is required. </p>
<p>This method should be overridden to return a non-negative value if your layer expects some exact number of top blobs. </p>

<p>Reimplemented in <a class="el" href="classcaffe_1_1SoftmaxWithLossLayer.html#a8222589f986db56372bf00935bae6180">caffe::SoftmaxWithLossLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1SoftmaxLayer.html#ae5c54555352700247a8fe47b73d06ce7">caffe::SoftmaxLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1SilenceLayer.html#a9bea0b5a6e1c15eefc85fdcc58d1c2e7">caffe::SilenceLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1WindowDataLayer.html#ae322bcc85f1d1ac2dc59e1ff28c29e7a">caffe::WindowDataLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1MVNLayer.html#a0c5e5f3645dcc3b9dc5886cee9e6f302">caffe::MVNLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1MemoryDataLayer.html#a973a58b5967809488f0e88c0a9a6fbac">caffe::MemoryDataLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1InnerProductLayer.html#a14a316bbfecc839fc65dc9c8aadc0b6d">caffe::InnerProductLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1ImageDataLayer.html#a288e0fe3bca4334100e077bc0ad20c60">caffe::ImageDataLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1HDF5OutputLayer.html#a2c754adb8c37b1299507865fdb616149">caffe::HDF5OutputLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1LRNLayer.html#aab9056708727154a01866d17756c07cc">caffe::LRNLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1FlattenLayer.html#ab54601497218724036abfcec46a718de">caffe::FlattenLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1HDF5DataLayer.html#aab2cd78cf5abc616fc1f8616e787efce">caffe::HDF5DataLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1Im2colLayer.html#aa4aa1cfc956fa1ab3656ad2adf911f32">caffe::Im2colLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1EltwiseLayer.html#adab35a7e096edeb73670e6682f264774">caffe::EltwiseLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1LossLayer.html#af8dca16967e8e979ebead4e80664dc10">caffe::LossLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1ConcatLayer.html#a3ee6697895b9c39e60b0019eedd7af68">caffe::ConcatLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1AbsValLayer.html#abddadbf826dc2ffaf22738804a484208">caffe::AbsValLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1ArgMaxLayer.html#acb86bae0a6dd2f01688ed4575830b874">caffe::ArgMaxLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1AccuracyLayer.html#a4090d979fa142c19cf90b8f9e37f5ab4">caffe::AccuracyLayer&lt; Dtype &gt;</a>, and <a class="el" href="classcaffe_1_1NeuronLayer.html#a25dfa84e8b46705aa7a822e734b4f04f">caffe::NeuronLayer&lt; Dtype &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a31d00947960a1334be6e45c9a43d8d58"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dtype &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Dtype <a class="el" href="classcaffe_1_1Layer.html">caffe::Layer</a>&lt; Dtype &gt;::Forward </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; * &gt; *&#160;</td>
          <td class="paramname"><em>top</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given the bottom blobs, compute the top blobs and the loss. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bottom</td><td>the input blobs, whose data fields store the input data for this layer </td></tr>
    <tr><td class="paramname">top</td><td>the preshaped output blobs, whose data fields will store this layers' outputs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The total loss from the layer.</dd></dl>
<p>The Forward wrapper calls the relevant device wrapper function (Forward_cpu or Forward_gpu) to compute the top blob values given the bottom blobs. If the layer has any non-zero loss_weights, the wrapper then computes and returns the loss.</p>
<p>Your layer should implement Forward_cpu and (optionally) Forward_gpu. </p>

</div>
</div>
<a class="anchor" id="a11a81d8a3722fcbceab72e6a964695e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classcaffe_1_1Layer.html">caffe::Layer</a>&lt; Dtype &gt;::LayerSetUp </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; * &gt; *&#160;</td>
          <td class="paramname"><em>top</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does layer-specific setup: your layer should implement this function as well as Reshape. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bottom</td><td>the preshaped input blobs, whose data fields store the input data for this layer </td></tr>
    <tr><td class="paramname">top</td><td>the allocated but unshaped output blobs</td></tr>
  </table>
  </dd>
</dl>
<p>This method should do one-time layer specific setup. This includes reading and processing relevent parameters from the <code>layer_param_</code>. Setting up the shapes of top blobs and internal buffers should be done in <code>Reshape</code>, which will be called before the forward pass to adjust the top blob sizes. </p>

<p>Reimplemented in <a class="el" href="classcaffe_1_1SoftmaxWithLossLayer.html#a4e18748879369f229a5b1a211d1fef4a">caffe::SoftmaxWithLossLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1SigmoidCrossEntropyLossLayer.html#a995f9869f2167df152cdec773b53bd90">caffe::SigmoidCrossEntropyLossLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1ThresholdLayer.html#ac7fa6d72dda38d3506de453bd716db62">caffe::ThresholdLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1SliceLayer.html#a0bb1e1e5fdfd69f34688fe88f2167688">caffe::SliceLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1InfogainLossLayer.html#a2c809eec60183f518928918aec8644b6">caffe::InfogainLossLayer&lt; Dtype &gt;</a>, <a class="el" href="singletoncaffe_1_1PoolingLayer.html#ac75e6c81314ed727dbc2549d61c9dff6">caffe::PoolingLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1InnerProductLayer.html#a0e3010530c4a17016b3a9ccd31080b7c">caffe::InnerProductLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1PowerLayer.html#ad34527c12dbeee81099a969746525ede">caffe::PowerLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1HDF5OutputLayer.html#a4b3d6e02ae889972ea7b50f9324adc80">caffe::HDF5OutputLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1LRNLayer.html#a53da4e91f328e3ddf49a53aa03205e24">caffe::LRNLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1HDF5DataLayer.html#a924da9138ea7f0da227b27c2b07d2a22">caffe::HDF5DataLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1DropoutLayer.html#a995adb2cbc22a5765e5a54344f5ea223">caffe::DropoutLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1Im2colLayer.html#a2c3bbefe8461c4849a8dd08f6770b02c">caffe::Im2colLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1EltwiseLayer.html#af70e962c74dbea0c34d0f459561cab26">caffe::EltwiseLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1ContrastiveLossLayer.html#a19f373ec54074bff38760323fa0e78a9">caffe::ContrastiveLossLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1DummyDataLayer.html#aa2ce7cd3c5e727e81add28822474cb73">caffe::DummyDataLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1LossLayer.html#a00f614a20793dcd2a70d93ac0c0a053a">caffe::LossLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1ConcatLayer.html#a3fe4c57658cd34f6bb8e2972cefe4536">caffe::ConcatLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1BasePrefetchingDataLayer.html#a8a060110e5147036d1b8fb757311d4a6">caffe::BasePrefetchingDataLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1ConvolutionLayer.html#a3cd77c2714120705b654a189c1640af9">caffe::ConvolutionLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1AbsValLayer.html#a2a32937ff04041fb76672e1e5bb3e0aa">caffe::AbsValLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1ArgMaxLayer.html#a5db76b74e9d4e48ffde92ab24df0ec3b">caffe::ArgMaxLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1BaseDataLayer.html#aa8d72a4861486993bf21bc702cc9766e">caffe::BaseDataLayer&lt; Dtype &gt;</a>, and <a class="el" href="classcaffe_1_1AccuracyLayer.html#ab1717073a94fb1de4d88e753ad92a383">caffe::AccuracyLayer&lt; Dtype &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a6408ef3939f1abed1abcec46ff219289"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classcaffe_1_1Layer.html">caffe::Layer</a>&lt; Dtype &gt;::MaxBottomBlobs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of bottom blobs required by the layer, or -1 if no maximum number is required. </p>
<p>This method should be overridden to return a non-negative value if your layer expects some maximum number of bottom blobs. </p>

<p>Reimplemented in <a class="el" href="classcaffe_1_1SoftmaxWithLossLayer.html#a922fdce0bace61b8b3996a3427566a9f">caffe::SoftmaxWithLossLayer&lt; Dtype &gt;</a>, and <a class="el" href="classcaffe_1_1InfogainLossLayer.html#ae6cf4ae009630b28583b161c33b582cb">caffe::InfogainLossLayer&lt; Dtype &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="adeff774663c6ec94424901d2746e2f03"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classcaffe_1_1Layer.html">caffe::Layer</a>&lt; Dtype &gt;::MaxTopBlobs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum number of top blobs required by the layer, or -1 if no maximum number is required. </p>
<p>This method should be overridden to return a non-negative value if your layer expects some maximum number of top blobs. </p>

<p>Reimplemented in <a class="el" href="classcaffe_1_1SoftmaxWithLossLayer.html#ac1f31629bf294a9281c5600f7e890232">caffe::SoftmaxWithLossLayer&lt; Dtype &gt;</a>, <a class="el" href="singletoncaffe_1_1PoolingLayer.html#a2a79eac8d3e85873c1fede0f1e8f0a45">caffe::PoolingLayer&lt; Dtype &gt;</a>, and <a class="el" href="classcaffe_1_1DataLayer.html#a67d8d7543045833765d73c850a81941f">caffe::DataLayer&lt; Dtype &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ade3eee97cc743c4e68fff7eba6484916"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classcaffe_1_1Layer.html">caffe::Layer</a>&lt; Dtype &gt;::MinBottomBlobs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the minimum number of bottom blobs required by the layer, or -1 if no minimum number is required. </p>
<p>This method should be overridden to return a non-negative value if your layer expects some minimum number of bottom blobs. </p>

<p>Reimplemented in <a class="el" href="classcaffe_1_1SoftmaxWithLossLayer.html#acf52e9421c1eff42e787321754bdbe4c">caffe::SoftmaxWithLossLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1InfogainLossLayer.html#a71105feb6b206d7f807c86d7dc303c64">caffe::InfogainLossLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1SilenceLayer.html#a0173d01d6408027cba41f5a8391e3d40">caffe::SilenceLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1EltwiseLayer.html#a27e853f4eb0e05ce52f9a3e291d06063">caffe::EltwiseLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1ConcatLayer.html#a5209b379f1c4897414243a155e21602c">caffe::ConcatLayer&lt; Dtype &gt;</a>, and <a class="el" href="classcaffe_1_1ConvolutionLayer.html#a212e67b3e7d0c830d363fc4b3eea86bc">caffe::ConvolutionLayer&lt; Dtype &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a8bb143d58a740345fa2dc3d4204d553b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classcaffe_1_1Layer.html">caffe::Layer</a>&lt; Dtype &gt;::MinTopBlobs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the minimum number of top blobs required by the layer, or -1 if no minimum number is required. </p>
<p>This method should be overridden to return a non-negative value if your layer expects some minimum number of top blobs. </p>

<p>Reimplemented in <a class="el" href="classcaffe_1_1SoftmaxWithLossLayer.html#a8994c9ed80aa3dac79a81aefe8f5ee64">caffe::SoftmaxWithLossLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1SliceLayer.html#a7e2a0c1b2e766e4f156a0c277f1c4810">caffe::SliceLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1SplitLayer.html#a76479b257d53d19d539a09798c81f0cb">caffe::SplitLayer&lt; Dtype &gt;</a>, <a class="el" href="singletoncaffe_1_1PoolingLayer.html#abc72dca274a4ab42f7a12de4d1e8f8eb">caffe::PoolingLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1DummyDataLayer.html#a82dba92b339f5d1e0d987fae8d47cd02">caffe::DummyDataLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1DataLayer.html#a65a81d2aff2703bf94b630ba2657b319">caffe::DataLayer&lt; Dtype &gt;</a>, and <a class="el" href="classcaffe_1_1ConvolutionLayer.html#aa9483eacc6ba8fe91e6639a8501786ef">caffe::ConvolutionLayer&lt; Dtype &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a1a3708013b0231e71d725252e10ce6e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcaffe_1_1Layer.html">caffe::Layer</a>&lt; Dtype &gt;::param_propagate_down </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>param_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies whether the layer should compute gradients w.r.t. a parameter at a particular index given by param_id. </p>
<p>You can safely ignore false values and always compute gradients for all parameters, but possibly with wasteful computation. </p>

</div>
</div>
<a class="anchor" id="a288c68a7fc6882fd3f0bc40126bf61f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classcaffe_1_1Layer.html">caffe::Layer</a>&lt; Dtype &gt;::Reshape </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; * &gt; *&#160;</td>
          <td class="paramname"><em>top</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adjust the shapes of top blobs and internal buffers to accomodate the shapes of the bottom blobs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bottom</td><td>the input blobs, with the requested input shapes </td></tr>
    <tr><td class="paramname">top</td><td>the top blobs, which should be reshaped as needed</td></tr>
  </table>
  </dd>
</dl>
<p>This method should reshape top blobs as needed according to the shapes of the bottom (input) blobs, as well as reshaping any internal buffers and making any other necessary adjustments so that the layer can accomodate the bottom blobs. </p>

<p>Implemented in <a class="el" href="classcaffe_1_1SoftmaxWithLossLayer.html#a424c3ad2e521c4a7010b6634256ed5b6">caffe::SoftmaxWithLossLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1SigmoidCrossEntropyLossLayer.html#a94a74943ac5712c8dc7313eb635d5d50">caffe::SigmoidCrossEntropyLossLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1MultinomialLogisticLossLayer.html#a8c466dc4a388dbf2d2e8de9c1556f56a">caffe::MultinomialLogisticLossLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1SliceLayer.html#ab9c6368200e2bad33529a7639540ac11">caffe::SliceLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1InfogainLossLayer.html#ab621b7c66a853dd2fe54559d50641139">caffe::InfogainLossLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1SplitLayer.html#af02fd58b24f5032797ad22e3793a65d0">caffe::SplitLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1SoftmaxLayer.html#a4bf3c31f0c9f4a735ea919e1277bed21">caffe::SoftmaxLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1SilenceLayer.html#a53a7ebdc6fa0249754f18c90edf86f95">caffe::SilenceLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1MVNLayer.html#a6355edca530bfe3cf6743e60a93a707f">caffe::MVNLayer&lt; Dtype &gt;</a>, <a class="el" href="singletoncaffe_1_1PoolingLayer.html#a2586864dd61492dc75d88d74ea3797f7">caffe::PoolingLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1InnerProductLayer.html#a8b1f2cd3f53676ee7e90d00660722a63">caffe::InnerProductLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1EuclideanLossLayer.html#a294463f3d2a77c84d95a0c27d9a829bb">caffe::EuclideanLossLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1HDF5OutputLayer.html#ab4307f13214739bf6521676a62dc8298">caffe::HDF5OutputLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1LRNLayer.html#a18da34161cfcaca1d7391505e83387f7">caffe::LRNLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1FlattenLayer.html#a3f239ebf5fb15217441fe3504779aa3a">caffe::FlattenLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1HDF5DataLayer.html#a44752182a3b60136760f9f2b4f20ef4d">caffe::HDF5DataLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1DropoutLayer.html#a58af13f6e1c1f36fdb1b980e21f527d6">caffe::DropoutLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1Im2colLayer.html#a3f117a2094734abaf376aca3287197c5">caffe::Im2colLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1EltwiseLayer.html#ad84bf1da66cbc61f36dcc4c7c8750b9d">caffe::EltwiseLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1DummyDataLayer.html#adec638efb5ae6142e9925097a0386a31">caffe::DummyDataLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1LossLayer.html#aafb637144a77ca7bfe5c3194bbe0d484">caffe::LossLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1ConcatLayer.html#a770bdfe345a9cae06064176cd2a03f52">caffe::ConcatLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1ConvolutionLayer.html#a8c224e1ec9f4795d374ca47b68f47c22">caffe::ConvolutionLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1BaseDataLayer.html#a19a2e860f57d26b385d46755f5e43fa6">caffe::BaseDataLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1ArgMaxLayer.html#ad8c47f92f6cb9e3e15101102affe42a8">caffe::ArgMaxLayer&lt; Dtype &gt;</a>, <a class="el" href="classcaffe_1_1AccuracyLayer.html#afff9d4e6b889df03bed7d6102c619c57">caffe::AccuracyLayer&lt; Dtype &gt;</a>, and <a class="el" href="classcaffe_1_1NeuronLayer.html#ae4d8d67cbdb21a2953d6dd36e4ec0572">caffe::NeuronLayer&lt; Dtype &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a5bebaf079cff5bff7016be1733bb996e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcaffe_1_1Layer.html">caffe::Layer</a>&lt; Dtype &gt;::SetLossWeights </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; * &gt; *&#160;</td>
          <td class="paramname"><em>top</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called by SetUp to initialize the weights associated with any top blobs in the loss function. Store non-zero loss weights in the diff blob. </p>

</div>
</div>
<a class="anchor" id="a4f7809d8e708c4408a96af0752aec481"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcaffe_1_1Layer.html">caffe::Layer</a>&lt; Dtype &gt;::SetUp </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt; Dtype &gt; * &gt; *&#160;</td>
          <td class="paramname"><em>top</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements common layer setup functionality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bottom</td><td>the preshaped input blobs </td></tr>
    <tr><td class="paramname">top</td><td>the allocated but unshaped output blobs, to be shaped by Reshape</td></tr>
  </table>
  </dd>
</dl>
<p>Checks that the number of bottom and top blobs is correct. Calls LayerSetUp to do special layer setup for individual layer types, followed by Reshape to set up sizes of top blobs and internal buffers. Sets up the loss weight multiplier blobs for any non-zero loss weights. This method may not be overridden. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a8073fcf2c139b47eb99ce71b346b1321"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;shared_ptr&lt;<a class="el" href="classcaffe_1_1Blob.html">Blob</a>&lt;Dtype&gt; &gt; &gt; <a class="el" href="classcaffe_1_1Layer.html">caffe::Layer</a>&lt; Dtype &gt;::blobs_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The vector that stores the learnable parameters as a set of blobs. </p>

</div>
</div>
<a class="anchor" id="a7ed12bb2df25c887e41d7ea9557fc701"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">LayerParameter <a class="el" href="classcaffe_1_1Layer.html">caffe::Layer</a>&lt; Dtype &gt;::layer_param_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The protobuf that stores the layer parameters </p>

</div>
</div>
<a class="anchor" id="af6d347229a139500994e7a926c680486"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;Dtype&gt; <a class="el" href="classcaffe_1_1Layer.html">caffe::Layer</a>&lt; Dtype &gt;::loss_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The vector that indicates whether each top blob has a non-zero weight in the objective function. </p>

</div>
</div>
<a class="anchor" id="acd4a05def9ff3b42ad72404210613ef7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Dtype&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;bool&gt; <a class="el" href="classcaffe_1_1Layer.html">caffe::Layer</a>&lt; Dtype &gt;::param_propagate_down_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Vector indicating whether to compute the diff of each param blob. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/caffe/<a class="el" href="layer_8hpp_source.html">layer.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Oct 14 2014 10:19:05 for Caffe by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
