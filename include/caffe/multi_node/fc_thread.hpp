
#ifndef MULTI_NODE_FC_THREAD_H_
#define MULTI_NODE_FC_THREAD_H_

#include "caffe/multi_node/node_env.hpp"
#include "caffe/multi_node/worker_thread.hpp"
#include "caffe/sgd_solvers.hpp"

namespace caffe {

template <typename Dtype>
class ParamBuf
{
public:
  ParamBuf() { pparam_ = NULL; }
  ~ParamBuf() { }

  // worker threads get latest version of param (unlocked)
  vector<Blob<Dtype>*> *GetParam();
  
  // associate the param with a solver pointer
  // increase reference count of a pointer by 1
  vector<Blob<Dtype>*> *RefParam(void *psolver);
 
  // decrease the reference count of a point by 1
  int DeRefParam(void *psolver);

  void InitParamBuf(const vector<Blob<Dtype>*>& params);
  
  // create new parameter using a template
  vector<Blob<Dtype>*> *CreateParam(const vector<Blob<Dtype>*>& params);

  // replace the old version of parameters with a new version
  void ReplaceParam(vector<Blob<Dtype>*> *p);

  // find a param with reference count 0
  // return NULL if fail to find
  vector<Blob<Dtype>*> *FindFreeParam();
 
protected:
  // a vetor of paramters
  vector<vector<Blob<Dtype>*>* > param_vec_;

  // the reference count of each paramter
  // the param thread can use parameter with ref count 0
  vector<int> ref_cnt_vec_;

  // the latest param generated by parameter thread
  vector<Blob<Dtype>*> *pparam_;

  // map a param pointer to ref index
  unordered_map<void *, int> pointer_to_idx_;
  
  // map a solver pointer to ref index
  unordered_map<void *, int> psolver_to_idx_;
  
  // mutex which protects the parameter pointer
  boost::mutex param_mutex_;
  
  // mutex which protects reference count
  boost::mutex ref_mutex_;

DISABLE_COPY_AND_ASSIGN(ParamBuf);
};


template <typename Dtype>
class FcWorker : public WorkerThread<Dtype>
{
public:
  FcWorker() { }
  virtual ~FcWorker() { }

  static ParamBuf<Dtype> *GetParamBuf() {
    boost::call_once(once_, CreateParamBuf);

    return pbuf_;
  }

private:
  static void CreateParamBuf() {
    pbuf_ = new ParamBuf<Dtype>();
  }

private:
  static ParamBuf<Dtype> *pbuf_;
  static boost::once_flag once_;

DISABLE_COPY_AND_ASSIGN(FcWorker);
};


template <typename Dtype>
class FcThread : public FcWorker<Dtype>
{
public:
  FcThread() { }
  virtual ~FcThread() { }

  virtual void Run();

protected:
  shared_ptr<Msg> FcForward(shared_ptr<Msg> m);
  void FcBackward(shared_ptr<Msg> m, vector<shared_ptr<Msg> >& replies, bool copy_diff);

  // copy Input data from Message
  void CopyInputDataFromMsg(shared_ptr<Net<Dtype> > fc_net, shared_ptr<Msg> m);

  // Copy Output Diff from Message
  void CopyOutputDiffFromMsg(shared_ptr<Net<Dtype> > fc_net, shared_ptr<Msg> m);
  

DISABLE_COPY_AND_ASSIGN(FcThread);
};


//the last part of FC layers
template <typename Dtype>
class FcLossThread : public FcThread<Dtype>
{
public:
  FcLossThread() { }
  virtual ~FcLossThread() { }
  virtual void Run();

protected:
  static boost::atomic_int iter_;

DISABLE_COPY_AND_ASSIGN(FcLossThread);
};


// for updating FC parameters
template <typename Dtype>
class FcParamThread : public FcWorker<Dtype>
{
public:
  FcParamThread() {
    train_iter_ = 0;
    test_node_id_ = -1;
    num_workers_ = NodeEnv::Instance()->num_workers();
    sub_batches_ = 0;
    sub_loss_ = 0;
  }

  virtual void Run();

protected:
  void SendParam(shared_ptr<Msg> m);

  void UpdateParam(shared_ptr<Msg> m);
  
  virtual Solver<Dtype> *CreateSolver(const Solver<Dtype> *root_solver, const SolverParameter& solver_param) {
    return NULL;
  }
  
  void SendNotify();

protected:
  int train_iter_;

  int test_node_id_;
  
  // number of conv. clients
  int num_workers_;
  
  // number of sub batches the param thread processed
  int sub_batches_;

  // sum of loss the param thread processed
  Dtype sub_loss_;

DISABLE_COPY_AND_ASSIGN(FcParamThread);
};

} //end caffe

#endif


