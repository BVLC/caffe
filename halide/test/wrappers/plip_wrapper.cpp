#include "plip_wrapper.h"

#include "Halide.h"
#include "caffe/util/halide.hpp"

// This is the header generated by halide
#include "plip.h"


using namespace Halide;

template <typename Dtype>
int inline PlipWrapper<Dtype>::ExactNumBottomBlobs() { return 1; }

template <typename Dtype>
int inline PlipWrapper<Dtype>::ExactNumTopBlobs() { return 1; }

template <typename Dtype>
void PlipWrapper<Dtype>::LayerSetUp(const vector<Blob<Dtype>*>& bottom,
    const vector<Blob<Dtype>*>& top) {}

template <typename Dtype>
void PlipWrapper<Dtype>::Forward_gpu(const vector<Blob<Dtype>*>& bottom,
      const vector<Blob<Dtype>*>& top) {
  // There is an argv implementation of all halide functions
  // in case dynamic behaviour is needed.

  bottom_buf_ = HalideWrapBlob(*bottom[0]);
  top_buf_ = HalideWrapBlob(*top[0]);
  plip(&bottom_buf_, &top_buf_);
  HalideSyncBlob(bottom_buf_, bottom[0]);
  HalideSyncBlob(top_buf_, top[0]);
}


template <typename Dtype>
void PlipWrapper<Dtype>::Backward_gpu(const vector<Blob<Dtype>*>& top,
        const vector<bool>& propagate_down, const vector<Blob<Dtype>*>& bottom) {
  bottom_diff_buf_ = HalideWrapBlob(*bottom[0], false);
  top_diff_buf_ = HalideWrapBlob(*top[0], false);
  plip(&top_diff_buf_, &bottom_diff_buf_);
  HalideSyncBlob(top_diff_buf_, top[0], false);
  HalideSyncBlob(bottom_diff_buf_, bottom[0], false);
}


template <typename Dtype>
void PlipWrapper<Dtype>::Reshape(const vector<Blob<Dtype>*>& bottom,
      const vector<Blob<Dtype>*>& top) {
  // CHECK_EQ(bottom[0]->shape(0), bottom[0]->shape(1));
  top[0]->ReshapeLike(*bottom[0]);
}


// the class factories
extern "C" DLLInterface<float>* create() {
    return new PlipWrapper<float>;
}

extern "C" void destroy(DLLInterface<float>* p) {
    delete p;
}
