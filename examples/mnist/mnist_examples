#!/usr/bin/env python

import os, struct
import numpy as np
from array import array as pyarray
from numpy import append, array, int8, uint8, zeros
import argparse

CAFFE_ROOT = '../../' 

parser = argparse.ArgumentParser(description='Extracts images from the MNIST dataset as numpy array')
parser.add_argument("--digit",help='the hand-written digit you want to predict, e.g. 2',type=int,default=2)
parser.add_argument("--count",help='how many images you want to predict, e.g. 100',type=int,default=100)
parser.add_argument("--output",help='name of output file',default='mnist-sample.npy')
args = parser.parse_args()

def read(digits, dataset = "training", path = "."):
    """
    Load MNIST files into 3D numpy arrays, scaled over unit interval
    """
 
    CONF  = { "training" :
               { "img" : os.path.join(path, 'train-images-idx3-ubyte'),
                 "lbl" : os.path.join(path, 'train-labels-idx1-ubyte'),
                 "size" : 60000 },
              "testing":
               { "img" : os.path.join(path, 't10k-images-idx3-ubyte'),
                 "lbl" : os.path.join(path, 't10k-labels-idx1-ubyte'),
                 "size" : 10000 } }
    
    try:
    	IMAGES_FILE = CONF[dataset]["img"]
	LABELS_FILE = CONF[dataset]["lbl"]
        N           = CONF[dataset]["size"]
    except (TypeError, KeyError, ValueError):
	print( "dataset must be 'testing' or 'training'" )
    else:
        try:
            f = open(LABELS_FILE, 'rb')
        except IOError:
            print('Could not open labels file')
        else:
            f.read(8) # skip the header
            labels = np.fromstring(f.read(N), dtype=np.uint8)
            f.close()
            try:
                f = open(IMAGES_FILE, 'rb')
            except IOError:
                print('Could not open images file')
            else:
                f.read(16) # skip the header
                images = np.fromstring(f.read(N * 28 * 28), dtype=np.uint8)
                f.close()
                # select digits we are interested in
                ind = [ k for k in xrange(N) if labels[k] in digits ]
                n  = len(ind)
                # init return values
                digits_we_want = zeros((n, 28, 28), dtype=np.float32)
                labels_we_want = zeros((n, 1), dtype=np.uint8)
                # fill return values with expected images and labels
                for i in xrange(n):
                    startIdx = ind[i]*28*28
                    endIdx   = (ind[i]+1)*28*28
                    digits_we_want[i] = images[startIdx:endIdx].reshape((28,28)).astype(np.float32) / 255.
                    labels_we_want[i] = labels[ind[i]]                
        
                return digits_we_want, labels_we_want
 
"""
Let's read test images for the digit passed as argument to the script
TODO: add sampling, output labels for downstream side-by-side comparison with predictions
"""

try:
    images, labels = read([args.digit], 'testing', os.path.join(CAFFE_ROOT,'data/mnist'))
except: 
    print('could not load images and labels')
else:
    outputs = zeros((args.count,28,28,1),dtype=float)

    """
    our classifier expects values between [0,1) and MNIST is 0-255
    this is already handled by the reader above and no further scaling is necessary
    """
    outputs[:,:,:,0] = images[0:args.count]
    np.save(args.output, outputs)

